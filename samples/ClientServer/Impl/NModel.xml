<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NModel</name>
    </assembly>
    <members>
        <member name="T:NModel.Algorithms.FsmTraversals">
            <summary>
            Provides utilities for fsm traversal and analysis
            </summary>
        </member>
        <member name="M:NModel.Algorithms.FsmTraversals.#ctor">
            <summary>
            It is not possible to create an instance of this class
            </summary>
        </member>
        <member name="M:NModel.Algorithms.FsmTraversals.GenerateTestSequences(NModel.FSM)">
            <summary>
            Generate a test suite from the given finite automaton.
            Dead states and transitions involving dead states are eliminated first,
            where a dead state is a state from which an accepting state is not reachable.
            The test suite will have the property that each action sequence in it 
            will lead to an accepting state of the finite automaton.
            The test suite provides transition coverage of all the alive transitions of the fa.
            The Rural Chinese Postman algorithm is used to compute the sequences.
            </summary>
            <returns>The resulting test suite</returns>
        </member>
        <member name="M:NModel.Algorithms.FsmTraversals.GenerateTestSequenceAutomaton(System.String,NModel.Sequence{NModel.Sequence{NModel.Terms.CompoundTerm}},NModel.Set{NModel.Terms.Symbol})">
            <summary>
            Generates a finite automaton that encodes the given test sequences.
            The provided action symbols must be a superset of the action symbols that 
            appear in the sequences.
            The additional action symbol given by testcaseName is 
            added to the set of action symbols of the generated automaton.
            The accepting states of the automaton are the end states of all the test sequences.
            </summary>
            <param name="testcaseName">the name of a test sequence is used as the first action name parameterized with an integer</param>
            <param name="testseqs">given test sequences as sequences of actions</param>
            <param name="actionSymbols">action symbols in the vocabulary</param>
            <returns>a finite automaton encoding of the test sequences</returns>
        </member>
        <member name="M:NModel.Algorithms.FsmTraversals.GetDeadStates(NModel.FSM)">
            <summary>
            Get all states in the given finite automaton from which no accepting state is reachable.
            </summary>
            <param name="fa">given finite automaton</param>
            <returns>all dead states in the finite automaton</returns>
        </member>
        <member name="T:NModel.Algorithms.FsmTraversals.IntermediateState">
            <summary>
            Represents the intermediate state of a test sequence
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphIsomorphism">
            <summary>
            Includes two algorithms:
            
            1) Based on Ullmann's SUBGRAPH isomorphism algorithm from JACM, Vol.23(1), pp 31-42, 1976
            specialized as a GRAPH isomorphism algorithm for directed labelled graphs
            
            2) Implements a backtracking extension of the linearization algorithm for 
            rooted directed ordered labelled graphs.
            The algorithm uses optimizations that rely on strong
            objectid independent hashing.
            
            Currently there are two variations of the second algorithm, one with partitioning and one without it.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.ComputeBuckets">
            <summary>
            Computes the buckets for all nodes.
            Returns false if this fails, in which case
            isomorphism from g1 to g2 is not possible.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphIsomorphism.Bucket">
            <summary>
            Represents a pair of buckets of nodes
            from g1 and g2, both buckets have the same label and the same size
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.ComputeIsomorphism1(NModel.Internals.RootedLabeledDirectedGraph,NModel.Internals.RootedLabeledDirectedGraph)">
            <summary>
            Returns an isomorphism from g1 to g2, if g1 and g2 are isomorphic;
            returns null, otherwise.
            
            Implements a backtracking extension of the linearization algorithm for 
            rooted directed ordered labelled graphs.
            The algorithm uses optimizations that rely on strong
            objectid independent hashing.
            
            (This version uses partitioning)
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.ComputeIsomorphism2(NModel.Internals.RootedLabeledDirectedGraph,NModel.Internals.RootedLabeledDirectedGraph)">
            <summary>
            Returns an isomorphism from g1 to g2, if g1 and g2 are isomorphic;
            returns null, otherwise.
            
            Implements a backtracking extension of the linearization algorithm for 
            rooted directed ordered labelled graphs.
            The algorithm uses optimizations that rely on strong
            objectid independent hashing.
            
            (This version does not use partitioning)
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphIsomorphism.Bijection">
            <summary>
            Represents a one-to-one map of nodes from g1 to nodes in g2.
            For efficiency includes the range of the map.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphIsomorphism.BacktrackPoint">
            <summary>
            A class used to capture information that needs to be stored and retrieved in order to
            make backtracking work.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphIsomorphism.BacktrackPointWithPartitions">
            <summary>
            A class used to capture information that needs to be stored and retrieved in order to
            make backtracking work.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphIsomorphism.Permuter">
            <summary>
            Permuter facilitates walking two collections in parallel using a permutation of indexes each time.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.GraphIsomorphism.Permuter.Item(System.Int32)">
            <summary>
            Makes it possible to access the <code>Permuter p;</code> in the convenient
            <code>int j = p[i];</code> way.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.Permuter.Next">
            <summary>
             Next() function is made along the lines of an implementation from a forthcoming book by JÃ¶rg Arndt
             http://www.jjj.de/fxt/#fxtbook where the implementation is transitively attributed
             to Glenn Rhoads and then to Edsger Dijkstra. Here we have made changes relevant to our application
             and C#.
             </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphIsomorphism.IterativeIsomorphismExtensionWithBacktrackingAndPartitioning">
            <summary>
            Implementation of the backtracking isomorphism checking algorithm described in Forte07 paper
            with a version of on the fly partitioning.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.IterativeIsomorphismExtensionWithBacktrackingAndPartitioning.ExtendForOnlyFunctionalEdges(System.Int32,System.Int32)">
            <summary>
            Walk all reachable functional edges. No backtracking involved. If not possible, then return FAIL,
            which might get handled by backtracking upstream the stack. x and y get added to the bijection array if successful.
            </summary>
            <param name="x1">a vertex from the first graph</param>
            <param name="y1">a vertex from the second graph</param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.IterativeIsomorphismExtensionWithBacktrackingAndPartitioning.GetPartitions(NModel.Internals.RootedLabeledDirectedGraph,System.Int32,NModel.Terms.CompoundTerm)">
            <summary>
            Partition the set of neighbors of all outgoing unordered edges of a node x in g.
            Returns all the partitions indexed by the pair (E,L) where
            E is an edge label and L is the label of the neighbor.
            
            A partition is marked order-independent if some node in that partition is 
            order-independent, which implies that all nodes in the same partition must be 
            order-independent as well (this is a property implied by the node labeling/hashing algorithm).
            </summary>
            <param name="g">given graph</param>
            <param name="node">given node in g</param> 
            <param name="edgeLabel">given edge label</param>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.IterativeIsomorphismExtensionWithBacktrackingAndPartitioning.IsOrderIndependent(System.Int32,NModel.Internals.RootedLabeledDirectedGraph)">
            <summary>
            A node n is order-independent in g if all nodes in 
            its neighborhood are in singleton buckets
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.IterativeIsomorphismExtensionWithBacktrackingAndPartitioning.PartitionsAreConsistent(NModel.Map{NModel.Pair{System.IComparable,System.Boolean},NModel.Set{System.Int32}},NModel.Map{NModel.Pair{System.IComparable,System.Boolean},NModel.Set{System.Int32}})">
            <summary>
            Returns true if both partitions have the same number of elements
            and the same keys, and for each key, the corresponding partitions 
            have the same size and order-idependence property.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphIsomorphism.IterativeIsomorphismExtensionWithBacktracking">
            <summary>
            Implementation of the backtracking isomorphism checking algorithm described in Forte07 paper
            without on the fly partitioning.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.IterativeIsomorphismExtensionWithBacktracking.ExtendForOnlyFunctionalEdges(System.Int32,System.Int32)">
            <summary>
            Walk all reachable functional edges. No backtracking involved. If not possible, then return FAIL,
            which might get handled by backtracking upstream the stack. x and y get added to the bijection array if successful.
            </summary>
            <param name="x1">a vertex from the first graph</param>
            <param name="y1">a vertex from the second graph</param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.ComputeIsomorphismUllmann(NModel.Internals.RootedLabeledDirectedGraph,NModel.Internals.RootedLabeledDirectedGraph)">
            <summary>
            Returns an isomorphism from g1 to g2, if g1 and g2 are isomorphic;
            returns null, otherwise.
            
            Based on Ullmann's SUBGRAPH isomorphism algorithm from JACM, Vol.23(1), pp 31-42, 1976
            specialized as a GRAPH isomorphism algorithm for rooted directed labelled graphs.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.ComputeIsomorphismFromNode(NModel.Set{System.Int32},NModel.Map{System.Int32,NModel.Set{System.Int32}})">
            <summary>
            Computes an isomorphism that is consistent with M.
            M already includes a partial isomorphism from all g1 nodes not in ns.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.Refine(NModel.Map{System.Int32,NModel.Set{System.Int32}})">
            <summary>
            Refinement procedure adapted from Ullmann's algorithm
            that eliminates candidates from M. In combination with 
            the main procedure it guarantees that the endresult is indeed an isomorphism
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphIsomorphism.CannotBeIsomorphic(System.Int32,System.Int32,NModel.Map{System.Int32,NModel.Set{System.Int32}})">
            <summary>
            Returns true if node i from g1 and node j from g2 cannot be isomorphic
            Corresponds to the negation of condition (2) for directed graphs in Ullmann's paper
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.BasicGraph">
            <summary>
            Summary description for BasicGraph.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.BasicGraph.#ctor(System.Int32,System.Collections.ICollection[])">
            <summary>
            
            </summary>
            <param name="initVertex"></param>
            <param name="links"></param>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.CHPP_N_M_logN">
            <summary>
            calculates a tour in O(n(n+m)log(n)) time
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.ClosureOfConnectedComps">
            <summary>
            calculates the new mustLinks and optionalLinks arrays
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.EulerianTour">
            <summary>
            Eulerian Tour - A walk on a graph edges  
            which uses each graph edge exactly once. 
            A connected graph has an Eulerian tour iff it has at most two graph vertices of odd degree. 
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.EulerianTour.#ctor(System.Int32,NModel.Algorithms.GraphTraversals.Edge[])">
            <summary>
            The walk starts at u
            </summary>
            <param name="u">start of the walk</param>
            <param name="edges">edges of the graph</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.EulerianTour.GetTour">
            <summary>
            Returns an Euler tour over the graph.
            </summary>
            <returns>Returns an empty array if there is no tour.</returns>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.WeakClosureEnum">
            <summary>
            This enum is used in the weak closure of the must edges set.
            A weak closure is the one disregarding edge directions.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.WeakClosureEnum.Close">
            <summary>
            Instruction to build a closure.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.WeakClosureEnum.DoNotClose">
            <summary>
            Instruction to not build a closure.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.Edge">
            <summary>
            Edge of a graph: has source,target, label and weight.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.Edge.source">
            <summary>
            Must be a non-negative number.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.Edge.target">
            <summary>
            Must be a non-negative number.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.Edge.label">
            <summary>
            Any number.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.Edge.weight">
            <summary>
            Any number.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Edge.Equals(System.Object)">
            <summary>
            Memberwise comparison
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Edge.GetHashCode">
            <summary>
            Hashcode - weight does not participate
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Edge.#ctor">
            <summary>
            An empty constructor.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Edge.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Source,target,label constructor.
            </summary>
            <param name="source">a non-negative integer</param>
            <param name="target">a non-negative integer</param>
            <param name="label">any integer</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Edge.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Source,target,label,weight constructor.
            </summary>
            <param name="source">a non-negative integer</param>
            <param name="target">a non-negative integer</param>
            <param name="label">any integer</param>
            <param name="weight">any integer, or non-negative if you intend to run Chinese Postman</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Edge.ToString">
            <summary>
            "source label target"
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Edge.CompareTo(System.Object)">
            <summary>
            Compares in the lexicographical order touples (source,target,label,weight).
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.IGraph">
            <summary>
            Some shortest path algorithms of GraphTraversal use this interface.
            Class Graph implements IGraph.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.IGraph.NumberOfVertices">
            <summary>
            Vertices should be enumerated from 0 to NumberOfVertices()-1 - the holes are acceptable
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.IGraph.InitialVertices">
            <summary>
            Enumerates through initial vertices
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.IGraph.EdgesAtVertex(System.Int32)">
            <summary>
            Enumerates through outgoing edges
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.IGraph.GetVertexWeight(System.Int32)">
             <summary>
            Gets the weight of an edge 
             </summary>
             <param name="vertex"></param>
             <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.IGraph.EdgeProbability(NModel.Algorithms.GraphTraversals.Edge)">
            <summary>
            Gets the probability of an edge
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.Graph">
            <summary>
            A graph object has a distinguished start vertex, initVertex, and a set of directed 
            labeled and weighted edges. The weights of the edges are integers. 
            Graph has optional and must edges. Must edges are taken by Rural Chinese Postman tour and
            optional ones can be skipped by it. If you don't use Rural Chinese Postman set optional links to an empty array.
            Some vertices can be marked as nondeterministic and a double valued function edgeProbabilites
            is defined on edges exiting such vertices.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.Graph.InitVertex">
            <summary>
            The initial vertex - usually 0.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.Graph.Infinity">
            <summary>
            Returns a very big integer.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.Succ(System.Int32)">
            <summary>
            Enumerates through the vertex successors.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.Pred(System.Int32)">
            <summary>
            Enumerates through the vertex predecessors.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.GetStrategiesToP(System.Collections.IEnumerable,NModel.Algorithms.GraphTraversals.IOrder,System.Int32)">
             <summary>
             Returns map from V*{0..n} to Strategy
             </summary>
             <param name="P">the set ov verices to reach</param>
             <param name="order">must be an acceptable order 
             We call an order O on pairs of real numbers acceptable if 
             for any integer m for any real numbers Pi, Ci, P'i, C'i, pi and ci where i changes from 0 to m if 
             (pi, ci) less or equal (p'i, c'i) according to O for every i from 0 to m
            		pi > 0 for every i from 0 to m and sum{ pi:  0 \leq i \leq n }=1
            then (sum{ piPi: 0 \leq i leq n },max{ ci+Ci: 0 \leq i \leq n }) \leq (sum{ piP'i: 0 \leq i \leq n },max{ ci+C'i: 0 \leq i \leq n }) </param>
             <param name="maxSteps">maximal number of edges to use for reachin P</param>
             <returns>array of strategies Strategy with length equals to the number of vertices</returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.DeadStates(System.Int32[])">
             <summary>
            Calculates all vertices from which accepting states are not reachable. 
             </summary>
             <param name="acceptingStates"></param>
             <returns>the set of dead states</returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.CleanTheStrategy(NModel.Algorithms.GraphTraversals.Edge[],System.Int32[])">
            <summary>
            removes edges which are not reachable from the initial vertex
            </summary>
            <param name="edgeToGo">from the vertix i we go to edgeToGo[i]</param>
            <param name="source">the sources where we can start the game</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.#ctor(System.Int32,NModel.Algorithms.GraphTraversals.Edge[],NModel.Algorithms.GraphTraversals.Edge[],System.Int32[],NModel.Algorithms.GraphTraversals.WeakClosureEnum)">
            <summary>
            </summary>
            <param name="initialVertex">the initial vertex - usually 0</param>
            <param name="mustEdges">the edge considered as must in Chinese Postman route</param>
            <param name="optionalEdges">the edges considered as optional in Chinese Postman route</param>
            <param name="nondetVertices">the vertices where the system behaves non-deterministically</param>
            <param name="closureInstr">this instruction will shuffle some optional edges to must ones. Chinese Rural Postman works only when the set of must links is weakly closed</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.#ctor(System.Int32,NModel.Algorithms.GraphTraversals.Edge[],NModel.Algorithms.GraphTraversals.Edge[],NModel.Algorithms.GraphTraversals.WeakClosureEnum)">
            <summary>
            </summary>
            <param name="initialVertex">the initial vertex - usually 0</param>
            <param name="mustEdges">the edge considered as must in Chinese Postman route</param>
            <param name="optionalEdges">the edges considered as optional in Chinese Postman route</param>
            <param name="closureInstruction">this instruction will shuffle some optional edges to must ones. </param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.CreateWeakClosureForMustEdges(NModel.Algorithms.GraphTraversals.Edge[]@,NModel.Algorithms.GraphTraversals.Edge[]@,System.Int32)">
            <summary>
            The function will shuffle some optional edges to the must edges
            in a way that must  edges will create a weakly connected component 
            including initVertex. For this function n is already known.
            
            </summary>
            <param name="mustEdges"></param>
            <param name="optionalEdges"></param>
            <param name="numberOfVertices"></param>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.Graph.MustEdges">
            <summary>
            Edges which have to be taken by the Chinese Postman tour or path.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.Graph.OptionalEdges">
            <summary>
            Edges which don't have to be taken by the Chinese Postman tour or path.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.GetRuralChinesePostmanTour">
            <summary>
            Returns a tour, a cycle, passing through all must edges and using optional edges if it has to.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.EdgesAtVertex(System.Int32)">
            <summary>
            Enumerates through the vertex outgoing edges.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.GetRuralChinesePostmanPath">
            <summary>
            Returns a path, that is a connected sequence of edges, not necesserely closed in a cycle
            containing all graph must edges.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.ShortestPath(System.Int32,System.Int32)">
            <summary>
            Returns a shortest path between the vertices.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.CreateFromFile(System.String)">
            <summary>
            Creates a graph from a file.
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.GetDistanceToAcceptingStates(System.Int32[])">
            <summary>
            Calculates distances from graph vertices to some selected set of vertices; accepting states.
            </summary>
            <param name="acceptingStates"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.ToFile(System.String)">
            <summary>
            Writes the graph to a file.
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.Graph.NumberOfVertices">
            <summary>
            The number of vertices in the graph - actually the max +1 of vertices.
            It should be taken in to account; do not add edges as new Edge(10000000000,3).
            The program would go out of memory.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.InitialVertices">
            <summary>
            Enumerates through initial vertices.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.GetVertexWeight(System.Int32)">
            <summary>
            Gets the vertex weight.
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.EdgeProbability(NModel.Algorithms.GraphTraversals.Edge)">
            <summary>
            Gets the edge probability.
            </summary>
            <param name="edge"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.SetEdgeProbability(NModel.Algorithms.GraphTraversals.Edge,System.Double)">
            <summary>
            Sets edge probability.
            </summary>
            <param name="edge">the edge</param>
            <param name="prob">the probability: a number between 0 and 1</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Graph.GetReachableEdges(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns the set of vertices reachable from the given initial vertex for no more than n steps.
            </summary>
            <param name="vertex">an initial vertex to start the search</param>
            <param name="steps">limit on the depth</param>
            <param name="skipChoicePoints">This parameter influences the definition of a non-reachable state;
            if it is true then a  state is unreachable in n steps if there is a strategy on choice points ensuring that.</param>
            <returns>set of vertices</returns>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.HSet">
            <summary>
            A set implementation using Hashtable.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.Insert(System.Object)">
            <summary>
            Insert an element; does not have effect if the element is already inside.
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.Contains(System.Object)">
            <summary>
            Check for the containments.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.Delete(System.Object)">
            <summary>
            Deletes an element from the set; does not have effect if the element is not inside.
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.HSet.Count">
            <summary>
            Yields the number of element in the set
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.GetEnumerator">
            <summary>
            Emumerates through the set elements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.Find(System.Object)">
            <summary>
            Finds an object in the set.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the set to array.
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.ToString">
            <summary>
            Returns a string representation of the set.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.Clear">
            <summary>
            Clears the set.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.Clone">
            <summary>
            Clones the set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.#ctor(System.Collections.IEnumerable)">
            <summary>
            Puts all elements of i to the set
            </summary>
            <param name="i">all elements of i woild be put in to the set</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.ToArray(System.Type)">
            <summary>
            Return the set as array.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.op_Subtraction(NModel.Algorithms.GraphTraversals.HSet,NModel.Algorithms.GraphTraversals.HSet)">
            <summary>
            Set difference.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.op_Addition(NModel.Algorithms.GraphTraversals.HSet,NModel.Algorithms.GraphTraversals.HSet)">
            <summary>
            Set union.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.HSet.IsSynchronized">
            <summary>
            </summary>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.HSet.SyncRoot">
            <summary>
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.HSet.#ctor">
            <summary>
            An empty constructor.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.Elem">
            <summary>
            Summary description for IntBinaryHeapPriorityQueue.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.IntBinaryHeapPriorityQueue.cache">
            <summary>
            cache[k]=A[cache[k].indexToA] this is the invariant
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.IntBinaryHeapPriorityQueue.#ctor(System.Int32)">
            <summary>
            the constructor
            we suppose that all integers inserted into the queue will be less then n
            </summary>
            <param name="n">it is the number of different integers taht will be inserted into the queue </param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.IntBinaryHeapPriorityQueue.decrease_priority(System.Int32,System.Int32)">
            <summary>
            sets the object priority to c
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.MultipleSourcesShortestPaths">
            <summary>
            Summary description for MultipleSourcesShortestPaths.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.PriorityQueue">
            <summary>
            Summary description for PriorityQueue.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.PriorityQueue.set_priority(System.Int32,System.Int32,System.Int32)">
            <summary>
            sets the object priority to c
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.SingleSourceShortestPaths">
            <summary>
            In graph theory, the single-source shortest path problem is 
            the problem of finding a path between two vertices such that the sum of the
             weights of its constituent edges is minimized. More formally, given a 
             weighted graph (that is, a set V of vertices, a set E of edges, 
             and a real-valued weight function f : E -> R), and given 
             further two elements n, n' of N, find a path P from n to n' so that 
             the sum of {f(p):p in P}	is minimal among all paths connecting n to n'.
             Here we use Dijkstra algorithm to find a path.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.GraphTraversals.SingleSourceShortestPaths.Pred">
            <summary>
            The array of predecessors.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.SingleSourceShortestPaths.Calculate">
            <summary>
            Performs the main calculation.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.SingleSourceShortestPaths.GetPathTo(System.Int32)">
            <summary>
            Gets a path to the target.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.SingleSourceShortestPaths.GetDistTo(System.Int32)">
            <summary>
            Returns the distance from the source to the target.
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.SingleSourceShortestPaths.#ctor(NModel.Algorithms.GraphTraversals.IGraph,System.Int32)">
            <summary>
            </summary>
            <param name="graph">any object implementing IGraph</param>
            <param name="source">the source of a path</param>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.SingleSourceSingleTargetUpperDistSP">
            <summary>
            In graph theory, the single-source shortest path problem is 
            the problem of finding a path between two vertices such that the sum of the
             weights of its constituent edges is minimized. More formally, given a 
             weighted graph (that is, a set V of vertices, a set E of edges, 
             and a real-valued weight function f : E ? R), and given 
             further two elements n, n' of N, find a path P from n to n' so that 
             the sum of {f(p):p in P}	is minimal among all paths connecting n to n'.
             Here we use Dijkstra algorithm to find the path, and use the
             given upper bound for the speed up.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.SingleSourceSingleTargetUpperDistSP.GetPath">
            <summary>
            Returns  a  path
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.SingleSourceSingleTargetUpperDistSP.#ctor(NModel.Algorithms.GraphTraversals.IGraph,System.Int32,System.Int32,System.Int32)">
            <summary>
            </summary>
            <param name="graph">the graph</param>
            <param name="source">the source of a path</param>
            <param name="target">the target of a path</param>
            <param name="udist">the upper distance; it is given here that the distance from source to target is no more than udist</param>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.SSMTSP">
            <summary>
            Single Source Multiple Target Shortest Path.
            The algorithm follows the paper
            http://www.mpi-sb.mpg.de/~mehlhorn/ftp/wbm-heur.ps.gz
            </summary>
            
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.SSMTSP.dist">
            <summary>
            The array of distances.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.SSMTSP.#ctor(NModel.Algorithms.GraphTraversals.IGraph,System.Int32,System.Int32[])">
            <summary>
            Single Source Multiple Target Shortest Path
            </summary>
            <param name="graph">an instance of IGraph</param>
            <param name="source">the source vertex</param>
            <param name="targets">an array of target vertices</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.SSMTSP.GetPath">
            <summary>
            Returns a path as a sequence of vertices.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.SSMTSP.GetPathAsEdges">
            <summary>
            Returns a path as a sequence of edges.
            </summary>
            <returns></returns>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.EdgesAndExpectations">
            <summary>
            Strategy representation.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.EdgesAndExpectations.edges">
            <summary>
            for a vertex i edges[i] is the move at i 
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.EdgesAndExpectations.expectations">
            <summary>
            expectations[i] is the expected weight of a path
            in a game starting from i 
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.EdgesAndExpectations.#ctor(NModel.Algorithms.GraphTraversals.Edge[],System.Double[])">
            <summary>
            constructor
            </summary>
            <param name="ls"></param>
            <param name="exps"></param>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.StaticStrategies">
            <summary>
            Class calculating strategies for reachability games. See MSR technical report "Play to test".
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.StaticStrategies.GetStaticStrategy(NModel.Algorithms.GraphTraversals.Graph,System.Int32[],NModel.Algorithms.GraphTraversals.HSet,System.Int32,System.Int32,System.Int32[])">
            <summary>
            Calculates an optimal strategy leading from sources to targets.
            If the number of vertices in the graph is big, more than 500, then expected
            values sometimes are not correct - they just express the length of a shortest path from sources 
            to targets. It can happen because the value iteration process converges too slowly
            and we use just shortest path weights to estimate expectations.
            </summary>
            <param name="graph">the test graph</param>
            <param name="sources">the start vertices of the game</param>
            <param name="targets">the target vertices of the game</param>
            <param name="nStates">active states are enumerated from 0 to nStates-1,
            and passive from nStates to graph.NumberOfVertices-1</param>
            <param name="resetCost">it is the cost of a link which could be added to connect a state with the initial vertex</param>
            <param name="deadStates">the set of vertices which are forbidden to use in a path to targets</param>
            <returns>a structure containing strategy edges and expected weight of a path to the targets</returns>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.IOrder">
            <summary>
            Defines an interface for acceptable order. This order is defined on pairs of (float,int) and
            is used to select a better strategy. The second component of a pair represents
            the maximal weight of a path to the targets and the first one is the probability to
            reach the target for some number of steps. See the paper at
            http://research.microsoft.com/users/nikolait/papers/OptimalStrategiesForTestingNondeterminsticSystems(ISSTA2004).pdf 
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.IOrder.Less(System.Single,System.Int32,System.Single,System.Int32)">
            <summary>
            Compare (a0,b0) with (a1,b1).
            </summary>
            <param name="a0"></param>
            <param name="b0"></param>
            <param name="a1"></param>
            <param name="b1"></param>
            <returns></returns>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.Strategy">
            <summary>
            Strategy representation for a finite number of steps game.
            See http://research.microsoft.com/users/nikolait/papers/OptimalStrategiesForTestingNondeterminsticSystems(ISSTA2004).pdf
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.Strategy.edge">
            <summary>
            The strategy edge
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.Strategy.prob">
            <summary>
            The probability to reach targets.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.GraphTraversals.Strategy.weight">
            <summary>
            The maximal weight of a path to targets.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.Strategy.#ctor(NModel.Algorithms.GraphTraversals.Edge,System.Single,System.Int32)">
            <summary>
            </summary>
            <param name="edge"></param>
            <param name="prob">probability</param>
            <param name="weight"></param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.StrategyWithUpdate.#ctor(NModel.Algorithms.GraphTraversals.Edge,System.Single,System.Int32)">
            <summary>
            Strategy at node constructor
            </summary>
            <param name="edge">where to go </param>
            <param name="prob">probability</param>
            <param name="weight">weight</param>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.StrategyCalculator">
            <summary>
            This class calculates strategies which are optimal for a finite number of steps.
            See the paper at http://research.microsoft.com/users/nikolait/papers/OptimalStrategiesForTestingNondeterminsticSystems(ISSTA2004).pdf
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.StrategyCalculator.#ctor(NModel.Algorithms.GraphTraversals.IGraph,System.Collections.IEnumerable,NModel.Algorithms.GraphTraversals.IOrder,System.Int32)">
             <summary>
             </summary>
             <param name="graph">is the graph we are playing the game on</param>
             <param name="P">the set to reach</param>
            <param name="order">compares strategies</param>
            <param name="maxSteps">maximum number of steps to go in the game</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.StrategyCalculator.#ctor(NModel.Algorithms.GraphTraversals.IGraph,System.Collections.IEnumerable,System.Int32)">
            <summary>
            </summary>
            <param name="graph">the test graph</param>
            <param name="P">set of target vertices</param>
            <param name="maxSteps">maximum number of steps in the game</param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.StrategyCalculator.Calculate">
            <summary>
            The main calclulation; works no more than maxSteps times.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.StrategyCalculator.Process(NModel.Algorithms.GraphTraversals.Edge)">
            <summary>
            edge[u,v] where v is in the front
            take values from S and updates Sn
            </summary>
            <param name="edge"></param>
        </member>
        <member name="M:NModel.Algorithms.GraphTraversals.StrategyCalculator.GetStrategyReachableFromVertex(System.Int32)">
            <summary>
            Returns a strategy to reach targets from a vertex.
            </summary>
            <param name="vertex"></param>
            <returns></returns>
        </member>
        <member name="T:NModel.Algorithms.GraphTraversals.WeightedCompleteBipartiteMatching">
            <summary>
            Weighted Bipartite Matching
            This is a special version when the bipartite graph 
            is complete.
            We do matching between nodes [0..n-1] and [n..2n-1]
            </summary>
        </member>
        <member name="T:NModel.Algorithms.IEdge">
            <summary>
            Edge of a graph with source and destination vertices.
            The source and destination may be the same in the case of self-loops.
            Also, source and destination may be freely swapped in the case of undirected graphs.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.IEdge.Source">
            <summary>
            Source vertex of the edge.  This is the vertex the edge travels from in directed graphs.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.IEdge.Target">
            <summary>
            Target vertex of the edge.  This is the vertex the edge travels to in directed graphs.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.IEdge.Cost">
            <summary>
            Positive integral cost associated with traversing the edge, relative to other edges in the graph.
            Note: The name "Weight" is not used here since some applications such as MDE associate Weight as a Reward.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.IEdge.Optional">
            <summary>
            Whether the edge is optional for inclusion in the graph and/or graph traversals.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.IVertex">
            <summary>
            Vertex of a graph with a set of (outgoing for directed graphs) edges.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.IVertex.Edges">
            <summary>
            Set of edges leaving this vertex.
            They may also be edges entering this vertex in the case of self-loops or undirected graphs.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.IVertex.ChoicePoint">
            <summary>
            Flag representing whether the vertex represents a choice point in a graph.
            </summary>
        </member>
        <member name="T:NModel.Algorithms.Reachability">
            <summary>
            A class containing algorithms for performing reachability checks on models.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.Reachability.ModelProgram">
            <summary>
            A field to get or set the model program on which the reachability algorithm is run.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Reachability.CheckReachability">
            <summary>
            Show all transitions from the given node and from the nodes that are reached from 
            the given node etc., until the state space is exhausted or the maximum number
            of transitions is reached.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Reachability.processGoal(NModel.Execution.ModelProgram,System.String)">
            <summary>
            Process the goal in the format "ModelProgramName1(stateName1(value1)),ModelProgramName2(stateName2(value2)" to a compound term of the corresponding model program.
            In the case of FSMs the format is "ModelProgramName(stateNumber)".
            </summary>
            <param name="mp">model program</param>
            <param name="goalString">goal as string</param>
            <returns>A set of compound terms corresponding to the goal string.</returns>
        </member>
        <member name="M:NModel.Algorithms.Reachability.CheckReachability(System.String)">
            <summary>
            Check if the term represented by goal is reachable. Empty string results in traversing the whole state space.
            </summary>
            <param name="goal">The goal term involving the model program name as outer function symbol.</param>
        </member>
        <member name="M:NModel.Algorithms.Reachability.Check(NModel.Execution.ModelProgram,System.String,System.Boolean)">
            <summary>
            Check if the term represented by goal is reachable in the given model program.
            Empty string as goal results in traversing the whole state space.
            </summary>
            <param name="mp">The model program to be checked.</param>
            <param name="goal">The goal term involving the model program name as outer function symbol.</param>
            <param name="excludeIsomorphicStates">Whether to use the symmetry reduction. Default is false.</param>
        </member>
        <member name="M:NModel.Algorithms.Reachability.RunWithCommandLineArguments(System.String[])">
            <summary>
            A method that is used by the command line interface.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:NModel.Algorithms.Reachability.Run(System.Collections.Generic.List{System.Reflection.Assembly},System.String)">
            <summary>
            A method that is used by the command line interface.
            Currently incomplete!!!!
            </summary>
            <param name="assemblies">A list of assemblies that constitute a model program</param>
            <param name="goalString">A string representation of compound term representing the goal to be reached. E.g. "Login(Name,CorrectPW)"</param>
        </member>
        <member name="T:NModel.Algorithms.ReachabilityResult">
            <summary>
            A class containing the result of performing reachability.
            Currently only the number of states and transitions visited.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.ReachabilityResult.StateCount">
            <summary>
            Field representing the count of states encountered in state space traversal.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.ReachabilityResult.TransitionCount">
            <summary>
            Field representing the count of transitions encountered in state space traversal.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.ReachabilityResult.GoalReached">
            <summary>
            Field representing the count of transitions encountered in state space traversal.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.ReachabilityResult.Goal">
            <summary>
            Field representing the count of transitions encountered in state space traversal.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.ReachabilityResult.#ctor(System.UInt32,System.UInt32)">
            <summary>
            A convenience constructor for producing a result with appropriate state and transition counts.
            </summary>
            <param name="stateCount"></param>
            <param name="transitionCount"></param>
        </member>
        <member name="T:NModel.Algorithms.OfflineTestGenerator">
            <summary>
            Provides a utility to generate an offline test suite from a model program 
            and to save the generated test suite in a file.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.OfflineTestGenerator.FileName">
            <summary>
            Gets or sets the name of the file where the generated test suite is saved.
            If null or empty, the test suite is written to the console.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.OfflineTestGenerator.Append">
            <summary>
            If true, the generated test suite is appended at the end of the file,
            otherwise the content of the file is overwritten.
            Default is false.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.OfflineTestGenerator.#ctor(NModel.Execution.ModelProgram)">
            <summary>
            Constructs an instance of an offline test suite generator from a model program.
            </summary>
            <param name="model">given model program</param>
        </member>
        <member name="M:NModel.Algorithms.OfflineTestGenerator.GenerateTestSuite">
            <summary>
            Generates a testsuite that covers the transitions of the state machine generated from the 
            model program. The state machine generated from the model program
            is assumed to be finite. If a nonempty filename is provided, 
            writes the generated test suite in the file, otherwise writes the
            testsuite to the console.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.OfflineTestGenerator.RunWithCommandLineArguments(System.String[])">
            <summary>
            Provides programmatic access to the offline test generator 'otg.exe'.
            </summary>
            <param name="args">command line arguments: references (required), model program(s) (required), name of test suite file and other settings (optional)</param>
            <remarks>The settings are displayed when 'otg.exe /?' is executed from the command line.</remarks>
        </member>
        <member name="M:NModel.Algorithms.OfflineTestGenCommandLineSettings.#ctor">
            <summary>
            Create an instance and initializes some of the fields
            </summary>
        </member>
        <member name="T:NModel.Algorithms.Path">
            <summary>
            Represents a path of edges
            </summary>
        </member>
        <member name="F:NModel.Algorithms.Path.Empty">
            <summary>
            Empty path
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.#ctor(NModel.Algorithms.IVertex)">
            <summary>
            Path containing a single vertex
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.#ctor(NModel.Algorithms.IEdge)">
            <summary>
            Path containing a single edge
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.#ctor(System.Collections.Generic.IEnumerable{NModel.Algorithms.IEdge})">
            <summary>
            Path containing the given edges
            </summary>
        </member>
        <member name="P:NModel.Algorithms.Path.Count">
            <summary>
            The length of the path
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.op_Addition(NModel.Algorithms.Path,NModel.Algorithms.IEdge)">
            <summary>
            Add the edge at the end of the path
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.op_Addition(NModel.Algorithms.Path,System.Collections.Generic.IEnumerable{NModel.Algorithms.IEdge})">
            <summary>
            Add the edges at the end of the path
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.Add(NModel.Algorithms.Path,NModel.Algorithms.IEdge)">
            <summary>
            Add the edge at the end of the path
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.Add(NModel.Algorithms.Path,System.Collections.Generic.IEnumerable{NModel.Algorithms.IEdge})">
            <summary>
            Add the edges at the end of the path
            </summary>
        </member>
        <member name="P:NModel.Algorithms.Path.Source">
            <summary>
            The start vertex of the path
            </summary>
        </member>
        <member name="P:NModel.Algorithms.Path.Target">
            <summary>
            The end vertex of the path
            </summary>
        </member>
        <member name="P:NModel.Algorithms.Path.Cost">
            <summary>
            The cost of the path
            </summary>
        </member>
        <member name="P:NModel.Algorithms.Path.Optional">
            <summary>
            True if the path is optional
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.CompareTo(NModel.Algorithms.Path)">
            <summary>
            Compares the costs of the paths
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.CompareTo(NModel.Algorithms.IEdge)">
            <summary>
            Compares the path cost to the edge cost
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.GetEnumerator">
            <summary>
            Enumerates the edges along the path
            </summary>
        </member>
        <member name="M:NModel.Algorithms.Path.ToString">
            <summary>
            Returns a string description of the path
            </summary>
        </member>
        <member name="T:NModel.Algorithms.PathNotFoundException">
            <summary>
            The exception that is thrown when compilation fails.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.PathNotFoundException.#ctor">
            <summary>
            Creates a new instance of this exception with a default error message.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.PathNotFoundException.#ctor(System.String)">
            <summary>
            Creates a new isntance of this class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:NModel.Algorithms.PathNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new isntance of this class with a specified error message and an inner exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:NModel.Algorithms.PathNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            This constructor exists only for serialization.
            </summary>
            <param name="info">The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:NModel.Algorithms.PathNotFoundException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            This method exists only for serialization.
            </summary>
            <param name="info">The System.Runtime.Serialization.SerializationInfo that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The System.Runtime.Serialization.StreamingContext that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:NModel.Algorithms.PriorityQueue`2">
            <summary>
            Priority queue of keys with given values
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:NModel.Algorithms.PriorityQueue`2.#ctor">
            <summary>
            Constructs an empty priority queue
            </summary>
        </member>
        <member name="M:NModel.Algorithms.PriorityQueue`2.#ctor(System.Boolean)">
            <summary>
            Constructs an empty priority queue with a boolean indicating whether 
            the priority order is inverted
            </summary>
            <param name="invert"></param>
        </member>
        <member name="M:NModel.Algorithms.PriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`1})">
            <summary>
            Constructs a priority queue with the given comparer
            </summary>
        </member>
        <member name="M:NModel.Algorithms.PriorityQueue`2.Enqueue(`0,`1)">
            <summary>
            Enqueue a new element into the queue with the given priority
            </summary>
        </member>
        <member name="M:NModel.Algorithms.PriorityQueue`2.Dequeue">
            <summary>
            Dequeue an element with highest priority from the queue
            </summary>
        </member>
        <member name="M:NModel.Algorithms.PriorityQueue`2.Peek">
            <summary>
            Peek what is the next element in the queue
            </summary>
        </member>
        <member name="M:NModel.Algorithms.PriorityQueue`2.TryGetValue(`0,`1@)">
            <summary>
            Try to get the priority of the given element
            </summary>
        </member>
        <member name="P:NModel.Algorithms.PriorityQueue`2.Item(`0)">
            <summary>
            Get the value associated with the given key
            </summary>
        </member>
        <member name="P:NModel.Algorithms.PriorityQueue`2.Count">
            <summary>
            The number of elements
            </summary>
        </member>
        <member name="T:NModel.Algorithms.GraphAlgorithms">
            <summary>
            Contains a set of shortest path graph algorithms.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.GraphAlgorithms.HasPath(NModel.Algorithms.IVertex,NModel.Algorithms.IVertex)">
            <summary>
            Returns true if there exists a path from source to target.
            Implemented using single-source single-target version of Dijkstra's shortest path algorithm, 
            </summary>
            <param name="source">Source vertex to start searching from.</param>
            <param name="target">Target vertex to find a path to.</param>
            <returns>True if a path was found; false otherwise.</returns>
            <remarks>
            The graph attached to <paramref name="source"/> must not contain any negative cycles.
            </remarks>
        </member>
        <member name="M:NModel.Algorithms.GraphAlgorithms.ShortestPath(NModel.Algorithms.IVertex,NModel.Algorithms.IVertex)">
            <summary>
            Single-source single-target version of Dijkstra's shortest path algorithm.
            </summary>
            <param name="source">Source vertex to start searching from.</param>
            <param name="target">Target verticex to find the shortest path to.</param>
            <returns>Shortest path from the source to the target.</returns>
            <remarks>
            The graph attached to <paramref name="source"/> must not contain any negative cycles.
            </remarks>
        </member>
        <member name="M:NModel.Algorithms.GraphAlgorithms.ShortestPath(NModel.Algorithms.IVertex,System.Collections.Generic.ICollection{NModel.Algorithms.IVertex})">
            <summary>
            Single-source multiple-target version of Dijkstra's shortest path algorithm that returns a single shortest path.
            </summary>
            <param name="source">Source vertex to start searching from.</param>
            <param name="targets">Target vertices to find shortest paths to.</param>
            <returns>Shortest path from the source to the closest target.</returns>
            <remarks>
            The graph attached to <paramref name="source"/> must not contain any negative cycles.
            </remarks>
        </member>
        <member name="M:NModel.Algorithms.GraphAlgorithms.ShortestPath(NModel.Algorithms.IVertex,System.Collections.Generic.ICollection{NModel.Algorithms.IVertex},System.Collections.Generic.IDictionary{NModel.Algorithms.IVertex,NModel.Algorithms.Path}@)">
            <summary>
            Single-source multiple-target version of Dijkstra's shortest path algorithm that returns a single shortest path.
            </summary>
            <param name="source">Source vertex to start searching from.</param>
            <param name="targets">Target vertices to find shortest paths to.</param>
            <param name="inclusive">Output of all paths shorter than (and including) the shortest path to the closest target.</param>
            <returns>Shortest path from the source to the closest target.</returns>
            <remarks>
            The graph attached to <paramref name="source"/> must not contain any negative cycles.
            </remarks>
        </member>
        <member name="M:NModel.Algorithms.GraphAlgorithms.ShortestPaths(NModel.Algorithms.IVertex,System.Collections.Generic.ICollection{NModel.Algorithms.IVertex},System.Int32)">
            <summary>
            Single-source multiple-target version of Dijkstra's shortest path algorithm that returns shortest paths to a specified number of targets.
            </summary>
            <param name="source">Source vertex to start searching from.</param>
            <param name="targets">Target vertices to find shortest paths to.</param>
            <param name="count">Number of targets to find.</param>
            <returns>Mapping of all shortest paths from the source to all vertices up to <paramref name="count"/> targets.</returns>
            <remarks>
            The graph attached to <paramref name="source"/> should not contain any negative cycles.
            </remarks>
        </member>
        <member name="T:NModel.Algorithms.TimedQueue`1">
            <summary>
            Implements a thread-safe unbounded queue of elements of type T.
            </summary>
        </member>
        <member name="F:NModel.Algorithms.TimedQueue`1.queue">
            <summary>
            Shared queue of T elements
            </summary>
        </member>
        <member name="M:NModel.Algorithms.TimedQueue`1.#ctor">
            <summary>
            Construct an instance with an initially empty queue
            </summary>
        </member>
        <member name="M:NModel.Algorithms.TimedQueue`1.Clear">
            <summary>
            Remove all entries from the queue
            </summary>
        </member>
        <member name="M:NModel.Algorithms.TimedQueue`1.TryPeek(`0@)">
            See if there is an element in the queue.
            If there is one return true
            and put it in the out parameter elem, 
            otherwise return false and put default(T) in elem.
        </member>
        <member name="M:NModel.Algorithms.TimedQueue`1.TryDequeue(System.TimeSpan,`0@)">
            <summary>
            Like TryPeek, but wait for at most 'waitAtMost' amount of time 
            to see if something arrives in the queue and remove it from the queue.
            A negative 'waitAtMost' means wait idefinitely.
            </summary>
        </member>
        <member name="M:NModel.Algorithms.TimedQueue`1.Enqueue(`0)">
            <summary>
            Enqueue the given element.
            </summary>
        </member>
        <member name="P:NModel.Algorithms.TimedQueue`1.IsEmpty">
            <summary>
            True if the queue is empty
            </summary>
        </member>
        <member name="M:NModel.Algorithms.TimedQueue`1.Dequeue">
            <summary>
            Dequeues the first term from the queue.
            Requires that the queue is nonempty
            </summary>
        </member>
        <member name="T:NModel.Algorithms.TimedWorker">
            <summary>
            A singleton threadpool consisting of one worker thread
            and a manager thread that aborts the worker when a timeout elapses
            </summary>
        </member>
        <member name="T:NModel.Conformance.ConformanceTester">
            <summary>
            Provides conformance testing functionality. 
            </summary>
        </member>
        <member name="M:NModel.Conformance.ConformanceTester.#ctor(NModel.Conformance.IStrategy,NModel.Conformance.IStepper)">
            <summary>
            Creates an instance of the conformance tester for an IUT stepper.
            </summary>
            <param name="model">given model stepper</param>
            <param name="impl">given implementation stepper</param>
        </member>
        <member name="M:NModel.Conformance.ConformanceTester.Reset">
            <summary>
            Reset the implementation and the model
            </summary>
            <exception cref="T:NModel.Conformance.ConformanceTesterException">Is thrown when Reset fails</exception>
        </member>
        <member name="M:NModel.Conformance.ConformanceTester.Run">
            <summary>
            Call RunTestCase runsCnt times, reset in between runs.
            </summary>
            <exception cref="T:NModel.Conformance.ConformanceTesterException">Is thrown when Run does not finish normally</exception>
        </member>
        <member name="M:NModel.Conformance.ConformanceTester.RunTestCase(System.Int32)">
            <summary>
            Run a single test case.
            Returns the result of the test case, containing the action trace
            </summary>
            <param name="testNr">test case number</param>
            <returns>test result</returns>
        </member>
        <member name="M:NModel.Conformance.ConformanceTester.Dispose">
            <summary>
            Dispose the conformance tester
            </summary>
        </member>
        <member name="M:NModel.Conformance.ConformanceTester.RunWithCommandLineArguments(System.String[])">
            <summary>
            Provides programmatic access to the conformance tester commandline utility 'ct.exe'.
            </summary>
            <param name="args">command line arguments: model program(s), implementation stepper, optional settings for conformance tester</param>
            <remarks>The settings are displayed when 'ct.exe /?' is executed from the command line.</remarks>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.AllRequirements">
            <summary>
            List of all the requirements that we want to check against 
            the executed requirements to get coverage metrics
            Pairs of: id,description
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.ShowTestCaseCoveredRequirements">
            <summary>
            Show executed requirements by each test-case?
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.ShowMetrics">
            <summary>
            Show test-suite metrics at the end of the ct log?
            </summary>
        </member>
        <member name="M:NModel.Conformance.ConformanceTester.AddExecutedRequirementsToTest(NModel.Conformance.TestResult,System.IO.StreamWriter)">
            <summary>
            The list of executed requierments by each test case
            </summary>
            <param name="testResult"></param>
            <param name="sw"></param>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.testResultNotifier">
            <summary>
            Test result delegate that is called each time a test run is completed.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.TestResultNotifier">
            <summary>
            Gets or sets the test result delegate that is called each time a test run is completed.
            The default notifier prettyprints the term representation of each test result to the console or 
            a logfile (if one is provided).
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.ContinueOnFailure">
            <summary>
            If set to false, the default test result notifier returns false when 
            a test case fails. Default is true.
            This setting has no effect if the <see cref="P:NModel.Conformance.ConformanceTester.TestResultNotifier"/> has been set
            to a custom notifier.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.StepsCnt">
            <summary>
            The desired number of steps that a single test run should have.
            After the number is reached, only cleanup tester actions are used
            and the test run continues until an accepting state is reached or 
            the number of steps is MaxStepsCnt (whichever occurs first).
            </summary>
            <remarks>Negative value or 0 implies no bound and a test case is executed 
            until either a failure occurs or no more actions are enabled.
            Default is 0.</remarks>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.MaxStepsCnt">
            <summary>
            The maximum number of steps that a single test run can have. This value must be 0, which means that there is no bound, or greater than or equal to stepsCnt.
            If stepsCnt is 0 then stepsCnt is set to be equal to maxStepsCnt.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.RunsCnt">
            <summary>
            The desired number of test runs. Must be nonnegative. Testing stops when this number has been reached.
            Test runs are numbered from 0 to RunsCnt-1.
            </summary>
            <remarks>0 implies no bound. Default is 0.</remarks>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.testerActionTimeout">
            <summary>
            Returns the amount of time within which the given tester action 
            call to the implementation must return. 
            If the action does not return, a conformance failure occurs.
            Default is 100ms.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.TesterActionTimeout">
            <summary>
            Returns the amount of time within which the given tester action 
            call to the implementation must return. 
            If the action does not return, a conformance failure occurs.
            Default is 100ms.
            </summary>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.testerActionSymbols">
            <summary>
            Set of action symbols controlled by the tester.
            Default is all action symbols of the model program.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.ObservableActionSymbols">
            <summary>
            Set of action symbols controlled by the implementation.
            Default is the empty set.
            </summary>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.cleanupActionSymbols">
            <summary>
            Subset of tester action symbols that are cleanup action symbols.
            Default is the empty set.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.CleanupActionSymbols">
            <summary>
            Subset of tester action symbols that are cleanup action symbols.
            Default is the empty set.
            </summary>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.internalActionSymbols">
            <summary>
            Subset of tester action symbols that are not shared with the implementation.
            Default is the empty set.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.InternalActionSymbols">
            <summary>
            Subset of tester action symbols that are not shared with the implementation.
            Default is the empty set.
            </summary>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.logfile">
            <summary>
            Filename where test results are logged by the default test result notifier. 
            The console is used if no logfile is provided.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.Logfile">
            <summary>
            Filename where test results are logged by the default test result notifier. 
            The console is used if no logfile is provided.
            </summary>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.overwriteLog">
            <summary>
            If true the log file is overwritten, otherwise the testresults are appended to the logfile (if provided).
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.OverwriteLog">
            <summary>
            If true the log file is overwritten, otherwise the testresults are appended to the logfile (if provided).
            </summary>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.randomSeed">
            <summary>
            A number used to calculate the starting value for the pseudo-random number sequence 
            that is used by the global choice controller. 
            If a negative number is specified, the absolute value is used.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.RandomSeed">
            <summary>
            A number used to calculate the starting value for the pseudo-random number sequence 
            that is used by the global choice controller.
            If a negative number is specified, the absolute value is used.
            Setting this property resets the GlobalChoiceController with a new instance 
            of the System.Random class with the given random seed.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.WaitAction">
            <summary>
            A name of an action that is used to wait for observable actions in a 
            state where no controllable actions are enabled. A wait action is controllable 
            and internal and must take one integer argument that determines the time to 
            wait in milliseconds during which an observable action is expected. Default is "Wait".
            Only used with IAsyncStepper.
            </summary>
        </member>
        <member name="F:NModel.Conformance.ConformanceTester.timeoutAction">
            <summary>
            A name of an action that happens when a wait action has been executed and no 
            obsevable action occurred within the time limit provided in the wait action. 
            A timeout action is observable and takes no arguments. Default is "Timeout".
            Only used with IAsyncStepper.
            </summary>
        </member>
        <member name="P:NModel.Conformance.ConformanceTester.TimeoutAction">
            <summary>
            A name of an action that happens when a wait action has been executed and no 
            obsevable action occurred within the time limit provided in the wait action. 
            A timeout action is observable and takes no arguments. Default is "Timeout".
            Only used with IAsyncStepper.
            </summary>
        </member>
        <member name="T:NModel.Conformance.ConformanceTesterException">
            <summary>
            Exception that is thrown by the ConformanceTester
            </summary>
        </member>
        <member name="M:NModel.Conformance.ConformanceTesterException.#ctor(System.String,System.Exception)">
            <summary>
            Create a conformance tester exception with a given message and given inner exception
            </summary>
        </member>
        <member name="M:NModel.Conformance.ConformanceTesterException.#ctor(System.String)">
            <summary>
            Create a conformance tester exception with a given message
            </summary>
        </member>
        <member name="M:NModel.Conformance.ConformanceTesterException.#ctor">
            <summary>
            Create a conformance tester exception
            </summary>
        </member>
        <member name="M:NModel.Conformance.ConfTesterCommandLineSettings.#ctor">
            <summary>
            Create an instance and initializes some of the fields explicitly to avoid warnings
            </summary>
        </member>
        <member name="T:NModel.Conformance.TestResultDelegate">
            <summary>
            Delegate for passing information about completed test runs.
            </summary>
            <param name="testResult">test result containig the verdict and the action trace</param>
            <returns>testing stops if false is returned, testing continues otherwise</returns>
        </member>
        <member name="T:NModel.Conformance.TesterActionTimeoutDelegate">
            <summary>
            Delegate for returning the amount of time within which the given tester action 
            call to the implementation must return. 
            If the action does not return, a conformance failure occurs.
            </summary>
            <param name="state">given model state</param>
            <param name="action">given tester action</param>
            <returns>amount of time to wait</returns>
        </member>
        <member name="T:NModel.Conformance.CoveragePointProvider">
            <summary>
            Provides functionality to define custom coverage point providers from a model program
            </summary>
        </member>
        <member name="M:NModel.Conformance.CoveragePointProvider.#ctor(NModel.Execution.ModelProgram,NModel.Set{System.String})">
            <summary>
            Create a coverage point provider for a model program and a given set of property names
            </summary>
            <param name="mp">given model program</param>
            <param name="transitionPropertyNames">property names of interest</param>
        </member>
        <member name="M:NModel.Conformance.CoveragePointProvider.GetCoveragePoints(NModel.Execution.IState,NModel.Terms.CompoundTerm)">
            <summary>
            Get coverage points from a given state and given action
            </summary>
            <param name="state">from given state</param>
            <param name="action">given action</param>
            <returns>coverage points</returns>
        </member>
        <member name="T:NModel.Conformance.IStrategy">
            <summary>
            A strategy is a stepper of a model program.
            Enabledness of actions is checked explicitly (exceptions are not thrown).
            Controllable actions can be enumerated.
            </summary>
        </member>
        <member name="M:NModel.Conformance.IStrategy.DoAction(NModel.Terms.CompoundTerm)">
            <summary>
            Make a step according to the given action, the current state
            becomes the target state of this transition.
            The action is required to be enabled in the current state.
            </summary>
        </member>
        <member name="P:NModel.Conformance.IStrategy.ActionSymbols">
            <summary>
            The action symbols of the model
            </summary>
        </member>
        <member name="P:NModel.Conformance.IStrategy.ObservableActionSymbols">
            <summary>
            The observable action symbols of the strategy
            </summary>
        </member>
        <member name="M:NModel.Conformance.IStrategy.Reset">
            <summary>
            Return to the initial state of the model.
            </summary>
        </member>
        <member name="M:NModel.Conformance.IStrategy.IsActionEnabled(NModel.Terms.CompoundTerm,System.String@)">
            <summary>
            Returns true if the given action is enabled in the current state.
            </summary>
            <param name="action">The action to be tested</param>
            <param name="failureReason">Null if result is true; otherwise a string describing the requirement that was not met.</param>
            <returns>True if <paramref name="action"/> is enabled; false otherwise.</returns>
        </member>
        <member name="P:NModel.Conformance.IStrategy.CurrentState">
            <summary>
            The current state of the model.
            </summary>
        </member>
        <member name="P:NModel.Conformance.IStrategy.IsInAcceptingState">
            <summary>
            Returns true if the state is an accepting state, and thus may be used
            to terminate a test case.
            </summary>
        </member>
        <member name="M:NModel.Conformance.IStrategy.SelectAction(NModel.Set{NModel.Terms.Symbol})">
            <summary>
            Select a concrete action that is enabled in the current state
            and whose action symbol is in the set <paramref name="actionSymbols"/>
            using a particular strategy.
            </summary>
            <param name="actionSymbols">set of candidate action symbols</param>
            <returns>the selected action or null if no choice is possible</returns>
        </member>
        <member name="T:NModel.Conformance.ObserverDelegate">
            <summary>
            Delegate that is used by the implementation to notify about observable actions.
            </summary>
            <param name="action">observable action</param>
        </member>
        <member name="T:NModel.Conformance.IStepper">
            <summary>
            Must be implemented by an IUT for conformance testing
            </summary>
        </member>
        <member name="M:NModel.Conformance.IStepper.DoAction(NModel.Terms.CompoundTerm)">
            <summary>
            Make a step according to the given action, the current state
            becomes the target state of this transition.
            If the action is not enabled an exception is thrown and the 
            resulting state is undefined.
            An action on null may be returned.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Conformance.IStepper.Reset">
            <summary>
            Return to the initial state.
            If Reset is not enabled in the current state, an exception is thrown 
            and the resulting state is undefined
            and is thus not guaranteed to be the initial state
            </summary>
        </member>
        <member name="T:NModel.Conformance.IAsyncStepper">
            <summary>
            Must be implemented by an IUT for conformance testing with asynchronous observables
            </summary>
        </member>
        <member name="M:NModel.Conformance.IAsyncStepper.SetObserver(NModel.Conformance.ObserverDelegate)">
            <summary>
            Sets the observer callback. The observer is called by the IUT each time an 
            observable action happens.
            </summary>
            <param name="observer">the provided observer</param>
        </member>
        <member name="T:NModel.Conformance.TextType">
            <summary>
            Type of text line: Header or an indented line
            </summary>
        </member>
        <member name="T:NModel.Conformance.Strategy">
            <summary>
            Provides a basic strategy for a model program.
            Selects actions randomly.
            </summary>
        </member>
        <member name="F:NModel.Conformance.Strategy.modelProgram">
            <summary>
            Model program of the model stepper
            </summary>
        </member>
        <member name="F:NModel.Conformance.Strategy.currState">
            <summary>
            Current state of the model stepper
            </summary>
        </member>
        <member name="F:NModel.Conformance.Strategy.initialState">
            <summary>
            Initial state of the model stepper
            </summary>
        </member>
        <member name="P:NModel.Conformance.Strategy.AllActionSymbols">
            <summary>
            Action symbols in the vocabulary
            </summary>
        </member>
        <member name="P:NModel.Conformance.Strategy.CoverageNames">
            <summary>
            Names of coverage points used by the strategy
            </summary>
        </member>
        <member name="M:NModel.Conformance.Strategy.#ctor(NModel.Execution.ModelProgram)">
            <summary>
            Construct a strategy with random action selection from the given model program.
            </summary>
            <param name="modelProgram">model program</param>
        </member>
        <member name="M:NModel.Conformance.Strategy.Create(NModel.Execution.ModelProgram,System.String[])">
            <summary>
            Create a strategy with random action selection from the given model program.
            </summary>
            <param name="modelProgram">model program</param>
            <param name="coverage">coverage point names (this argument is ignored)</param>
        </member>
        <member name="M:NModel.Conformance.Strategy.GetEnabledActions(NModel.Set{NModel.Terms.Symbol})">
            <summary>
            Yields all the enabled actions with the given action symbols 
            in the current model state. 
            </summary>
            <param name="actionSymbols">given action symbols</param>
            <returns></returns>
        </member>
        <member name="M:NModel.Conformance.Strategy.IsActionEnabled(NModel.Terms.CompoundTerm,System.String@)">
            <summary>
            Returns true if the action is enabled in the current state.
            If the action is not enabled, provides a reason in <paramref name="failureReason"/>.
            </summary>
            <param name="action">action whose enabledness is being checked</param>
            <param name="failureReason">failure reason if the action is not enabled</param>
            <returns>true if the action is enabled, false otherwise</returns>
        </member>
        <member name="P:NModel.Conformance.Strategy.CurrentState">
            <summary>
            The current state
            </summary>
        </member>
        <member name="M:NModel.Conformance.Strategy.DoAction(NModel.Terms.CompoundTerm)">
            <summary>
            Update the current state to the target state of the action from the current state.
            Can be overwritten in a derived class to record history that affects action selection strategy.
            </summary>
            <param name="action">given action</param>
        </member>
        <member name="M:NModel.Conformance.Strategy.Reset">
            <summary>
            Reset the model stepper to the initial state of the model.
            Can be overwritten in a derived class to record history that affects action selection strategy.
            </summary>
        </member>
        <member name="P:NModel.Conformance.Strategy.IsInAcceptingState">
            <summary>
            Returns true if the current state is an accepting state.
            </summary>
        </member>
        <member name="P:NModel.Conformance.Strategy.ActionSymbols">
            <summary>
            The action symbols in the vocabulary.
            </summary>
        </member>
        <member name="M:NModel.Conformance.Strategy.SelectAction(NModel.Set{NModel.Terms.Symbol})">
            <summary>
            Select an action that is enabled in the current state
            and whose action symbol is in the set <paramref name="actionSymbols"/>.
            Default action selection strategy is random.
            </summary>
            <param name="actionSymbols">set of candidate action symbols</param>
            <returns>the chosen action or null if no choice is possible</returns>
            <remarks>Can be overwritten in a dervied class to encorporate different 
            action selection strategies.</remarks>
        </member>
        <member name="P:NModel.Conformance.Strategy.ObservableActionSymbols">
            <summary>
            Observable action symbols of the strategy
            </summary>
        </member>
        <member name="T:NModel.Conformance.RewardPolicy">
            <summary>
            Action reward policy used by ModelStepperWithCoverage
            </summary>
        </member>
        <member name="F:NModel.Conformance.RewardPolicy.MaximumReward">
            <summary>
            Select an action that provides a maximum reward
            </summary>
        </member>
        <member name="F:NModel.Conformance.RewardPolicy.ProbableReward">
            <summary>
            Select an action with likelihood that is proportional to the reward
            </summary>
        </member>
        <member name="T:NModel.Conformance.CoveragePointDelegate">
            <summary>
            Computes a bag of coverage points for the given action from the given source state.
            </summary>
            <param name="state">given state</param>
            <param name="action">given action</param>
            <returns>bag of coverage points</returns>
        </member>
        <member name="T:NModel.Conformance.StrategyWithCoverage">
            <summary>
            Provides a model stepper that uses coverage points to direct the selection of actions.
            </summary>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.#ctor(NModel.Execution.ModelProgram,NModel.Conformance.RewardPolicy,NModel.Conformance.CoveragePointDelegate)">
            <summary>
            Construct a model stepper that records coverage points.
            </summary>
            <param name="modelProgram">model program</param>
            <param name="policy">reward policy</param>
            <param name="coveragePointProvider">(optional) coverage point provider</param>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.#ctor(NModel.Execution.ModelProgram,NModel.Conformance.RewardPolicy)">
            <summary>
            Construct a model stepper that records coverage points.
            Defines the coverage point for a given action a and state s 
            as the bag containig the pair (s.GetHashCode(),a.GetHashCode())
            </summary>
            <param name="modelProgram">model program</param>
            <param name="policy">reward policy</param>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.#ctor(NModel.Execution.ModelProgram,NModel.Conformance.RewardPolicy,NModel.Set{System.String})">
            <summary>
            Construct a model stepper that records coverage points.
            Coverage points of interest are provided by <paramref name="transitionPropertyNames"/>
            </summary>
            <param name="modelProgram">model program</param>
            <param name="policy">reward policy</param>
            <param name="transitionPropertyNames">(optional) coverage points of interest</param>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.DefaultCoveragePointProvider(NModel.Execution.IState,NModel.Terms.CompoundTerm)">
            <summary>
            Returns a bag containing a single coverage point that is a pair of integers 
            that are the hashcodes of the state and the action.
            </summary>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.GetWeight(NModel.Execution.IState,NModel.Terms.CompoundTerm)">
            <summary>
            Compute the weight of an action a in state s as 1000 * GetReward(s,a) as integer
            </summary>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.Update(NModel.Execution.IState,NModel.Terms.CompoundTerm)">
            <summary>
            Update the bag of coverage points seen so far, by adding 
            the coverage points provided by the transition labeled by action a from state s.
            </summary>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.ChooseAction(NModel.Sequence{NModel.Terms.CompoundTerm},NModel.Execution.IState)">
            <summary>
            Choose the next action from the given set of actions in the given state.
            </summary>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.DoAction(NModel.Terms.CompoundTerm)">
            <summary>
            Update the current state to the target state of the action from the current state.
            Records coverage points of this transition.
            </summary>
            <param name="action">given action</param>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.SelectAction(NModel.Set{NModel.Terms.Symbol})">
            <summary>
            Select an action that is enabled in the current state
            and whose action symbol is in the set <paramref name="actionSymbols"/>.
            Use coverage points and reward policy.
            </summary>
            <param name="actionSymbols">set of candidate action symbols</param>
            <returns>the chosen action or null if no choice is possible</returns>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.CreateWithMaximumReward(NModel.Execution.ModelProgram,System.String[])">
            <summary>
            Creates a model stepper that uses coverage points (when != null) to direct the selection of actions.
            If coverage == null, uses default coverage points that are (state.GetHashCode(), action.GetHashCode()) pairs.
            Uses RewardPolicy.MaximumReward for action selection.
            </summary>
            <param name="modelProgram">given model program</param>
            <param name="coverage">given coverage point names (may be null)</param>
        </member>
        <member name="M:NModel.Conformance.StrategyWithCoverage.CreateWithProbableReward(NModel.Execution.ModelProgram,System.String[])">
            <summary>
            Creates a model stepper that uses coverage points (when != null) to direct the selection of actions.
            If coverage == null, uses default coverage points that are (state.GetHashCode(), action.GetHashCode()) pairs.
            Uses RewardPolicy.ProbableReward for action selection.
            </summary>
            <param name="modelProgram">given model program</param>
            <param name="coverage">given coverage point names (may be null)</param>
        </member>
        <member name="T:NModel.Conformance.TestResult">
            <summary>
            Describes the result of a single test case
            </summary>
        </member>
        <member name="F:NModel.Conformance.TestResult.testNr">
            <summary>
            Test case number.
            </summary>
        </member>
        <member name="F:NModel.Conformance.TestResult.verdict">
            <summary>
            The verdict of the test case. 
            If the verdict is Failure, the last action of 
            the test case violated conformance
            </summary>
        </member>
        <member name="F:NModel.Conformance.TestResult.reason">
            <summary>
            Provides the reason for failure
            </summary>
        </member>
        <member name="F:NModel.Conformance.TestResult.trace">
            <summary>
            The sequence of actions in the test case
            </summary>
        </member>
        <member name="F:NModel.Conformance.TestResult.executedRequirements">
            <summary>
            A Bag that contains all the executed requirements during this test-case run
            </summary>
        </member>
        <member name="M:NModel.Conformance.TestResult.#ctor(System.Int32,NModel.Conformance.Verdict,System.String,NModel.Sequence{NModel.Terms.CompoundTerm},NModel.Bag{NModel.Pair{System.String,System.String}})">
            <summary>
            Constructs a test case result
            </summary>
            <param name="testNr">test case number</param>
            <param name="verdict">verdict of the test case</param>
            <param name="trace">actions of the test case</param>
            <param name="reason">failure reason</param>
            <param name="executedRequirements">executed requirements</param>
        </member>
        <member name="T:NModel.Conformance.Verdict">
            <summary>
            Verdict of a test case
            </summary>
        </member>
        <member name="F:NModel.Conformance.Verdict.Success">
            <summary>
            Successful test case
            </summary>
        </member>
        <member name="F:NModel.Conformance.Verdict.Failure">
            <summary>
            Failed test case
            </summary>
        </member>
        <member name="T:NModel.Conformance.TestSuiteStepper">
            <summary>
            Provides a model stepper for a test suite given as a sequence of test cases in form of action sequences.
            </summary>
        </member>
        <member name="M:NModel.Conformance.TestSuiteStepper.#ctor(System.String,NModel.Sequence{NModel.Sequence{NModel.Terms.CompoundTerm}})">
            <summary>
            Constructs a model stepper for a given test suite
            </summary>
            <param name="startTest">name of start action of a test case</param>
            <param name="testsuite">given test suite as a nonempty sequence of test cases</param>
        </member>
        <member name="M:NModel.Conformance.TestSuiteStepper.#ctor(System.String,NModel.Sequence{NModel.Sequence{NModel.Terms.CompoundTerm}},NModel.Execution.ModelProgram)">
            <summary>
            Constructs a model stepper for a given test suite and a given model program,
            using the product of the test suite and the model program.
            </summary>
            <param name="startTest">name of start action of a test case</param>
            <param name="testsuite">given test suite as a nonempty sequence of test cases</param>
            <param name="mp">given model program</param>
        </member>
        <member name="M:NModel.Conformance.TestSuiteStepper.DoAction(NModel.Terms.CompoundTerm)">
            <summary>
            Update the current state to the target state of the action from the current state.
            If the action is the current action in the current test case, consume that action.
            </summary>
            <param name="action">given action</param>
        </member>
        <member name="M:NModel.Conformance.TestSuiteStepper.SelectAction(NModel.Set{NModel.Terms.Symbol})">
            <summary>
            Select the next action in the current test case.
            The action symbol must be among the given set of action symbols.
            </summary>
            <param name="actionSymbols">given action symbols</param>
            <returns>selected action or null if no action could be selected</returns>
        </member>
        <member name="M:NModel.Conformance.TestSuiteStepper.Reset">
            <summary>
            Reset the model stepper to the initial state of the model.
            If the current test case is in progress, go to the next test case
            </summary>
        </member>
        <member name="T:NModel.Execution.TransitionPredicate">
            <summary>
            A delegate for desciding if a transition is to be included 
            in the gererated finite automaton or not.
            </summary>
            <param name="startState">start state of the transition</param>
            <param name="action">action label of the transition</param>
            <param name="endState">end state of the transition</param>
            <param name="evaluatedProperties">evaluated properties, the value of each property is a bag of terms</param>
            <returns>returns true if the transition is to be included in the finite automaton, returns false otherwise</returns>
        </member>
        <member name="T:NModel.Execution.FSMBuilder">
            <summary>
            Utility for exploring model programs. 
            </summary>
        </member>
        <member name="M:NModel.Execution.FSMBuilder.#ctor(NModel.Execution.ModelProgram)">
            <summary>
            Builder that can create a finite automaton by exploring the possible steps of a model program.
            </summary>
            <param name="m">Model program to be explored</param>
        </member>
        <member name="M:NModel.Execution.FSMBuilder.#ctor(NModel.Execution.ModelProgram,NModel.Execution.TransitionPredicate)">
            <summary>
            Builder that can create a finite automaton by exploring the possible steps of a model program.
            </summary>
            <param name="m">Model program to be explored</param>
            <param name="transitionPredicate">User defined predicate that returns true if a 
            transition is to be included in the gererated finite automaton</param>
        </member>
        <member name="M:NModel.Execution.FSMBuilder.Explore(System.Collections.Generic.Dictionary{NModel.Terms.Term,NModel.Execution.IState})">
            <summary>
            Explores the model associated with this instance.
            The dictionary stateMap (if not null) is used to record the mapping 
            from generated finite automata states to IStates.
            Explore(null) is the same as Explore()
            </summary>
            <returns>A list of transitions. Each transition is a start state,
            an action label and an end state.</returns>
        </member>
        <member name="M:NModel.Execution.FSMBuilder.Explore">
            <summary>
            Explores the model associated with this instance.
            </summary>
            <returns>A list of transitions. Each transition is a start state,
            an action label and an end state.</returns>
        </member>
        <member name="T:NModel.Execution.FSMBuilder.Branch">
            <summary>
            Indicates whether to take the left or the right branch in a binary tree construction (such as a pair state)
            </summary>
        </member>
        <member name="F:NModel.Execution.FSMBuilder.Branch.Left">
            <summary>
            Left branch
            </summary>
        </member>
        <member name="F:NModel.Execution.FSMBuilder.Branch.Right">
            <summary>
            Right branch
            </summary>
        </member>
        <member name="M:NModel.Execution.FSMBuilder.ProjectFromProduct(NModel.FSM,NModel.Set{NModel.Terms.Symbol},NModel.Sequence{NModel.Execution.FSMBuilder.Branch},System.Collections.Generic.Dictionary{NModel.Terms.Term,NModel.Execution.IState},System.Collections.Generic.Dictionary{NModel.Terms.Term,NModel.Execution.IState}@)">
            <summary>
            Returns a finite automaton that is the projection of an automaton with product states.
            </summary>
            <param name="finiteAutomaton">The product automaton</param>
            <param name="projectedSymbols">Project to these action symbols</param>
            <param name="treePosition">A sequence of enum values indicating the position in the product tree of the state to project. 
            For example, Sequence&lt;Branch.Left, Branch.Right&gt; indicates the right leaf of the left branch from the root.</param>
            <param name="stateMap">Dictionary of state terms (of <paramref name="finiteAutomaton"/>) that contain the associated IState values.
            May be null if the out parameter <paramref name="reductStateMap"/> is not required to be created.</param>
            <param name="reductStateMap">Output that is produced by projecting the states of the <paramref name="stateMap"/>, if nonnull.</param>
            <returns>The projected automaton</returns>
        </member>
        <member name="T:NModel.Execution.ActionMethod">
            <summary>
            Action symbol that maps to a .Net method
            </summary>
        </member>
        <member name="F:NModel.Execution.FsmState.automatonStates">
            <summary>
            DFA states are sets of NFA states. The set represents all of the possible
            NFA states that are possible given the trace so far.
            </summary>
        </member>
        <member name="T:NModel.Execution.FsmModelProgram">
            <summary>
            A model program constructed from a (potentially nondeterministic finite automaton). The internal
            states of the model program are chosen so that actions are deterministic.
            </summary>
        </member>
        <member name="T:NModel.Execution.FsmModelProgram.Parameter">
            <summary>
            Value type of parameter indices of a finite automaton-- a triple (state, actionSymbol, integerIndex)
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.Parameter.FieldValues">
            <summary>
            Enumerates the constituents of this compound value.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NModel.Execution.FsmModelProgram.Parameter.State">
            <summary>
            The start state of the step.
            </summary>
        </member>
        <member name="P:NModel.Execution.FsmModelProgram.Parameter.ActionSymbol">
            <summary>
            The action label of the step.
            </summary>
        </member>
        <member name="P:NModel.Execution.FsmModelProgram.Parameter.Index">
            <summary>
            The target data state of the step.
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.#ctor(NModel.FSM,System.String)">
            <summary>
            Constructs a model program from a (potentially) nondeterministic finite automaton. The internal
            states of the model program are chosen so that actions are deterministic.
            </summary>
            <param name="automaton">The underlying finite automaton that will provide the steps</param>
            <param name="modelName">A string identifying this model program</param>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.ActionSymbols">
            <summary>
            Nonempty set of actions symbols.
            <br><c>ensures result.Count &gt; 0</c></br>
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.ActionArity(NModel.Terms.Symbol)">
            <summary>
            Number of arguments associated with action symbol <paramref name="actionSymbol"/>
            <br><c>requires actionSymbol != null;</c></br>
            <br><c>requires this.ActionSymbols.Contains(actionSymbol);</c></br>
            <br><c>ensures result &gt;= 0</c></br>
            </summary>
            <param name="actionSymbol">A symbol naming an action of this model program.</param>
            <returns>The number of arguments required in a <see cref="T:NModel.Terms.Term"/> invoking this <paramref name="actionSymbol"/></returns>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.ActionParameterSort(NModel.Terms.Symbol,System.Int32)">
            <summary>
            Gets the sort (i.e., abstract type) of the ith parameter of action <paramref name="actionSymbol"/>
            <br><c>requires actionSymbol != null;</c></br>
            <br><c>requires this.ActionSymbols.Contains(actionSymbol);</c></br>
            </summary>
            <param name="actionSymbol">A symbol naming an action of this model program.</param>
            <param name="parameterIndex">An integer in the interval [0, this.ActionArity(actionSymbol))</param>
            <returns>The sort (abstract type) of the ith parameter of action <paramref name="actionSymbol"/></returns>
        </member>
        <member name="P:NModel.Execution.FsmModelProgram.LocationValueCount">
            <summary>
            Number of location values in the state signature of this model program
            <br><c>ensures result >= 0;</c></br>
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.LocationValueName(System.Int32)">
            <summary>
            String name identifying the ith location value in the state signature of this model program
            <br><c>requires 0 &lt;= i &amp;&amp; i &lt; this.LocationValueCount;</c></br>
            </summary>
            <param name="i">An index in the interval [0,  LocationValueClount)</param>
            <returns>String name identifying the ith location value</returns>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.LocationValueModelName(System.Int32)">
            <summary>
            It is an error to call this method.
            Throws NotImplementedException.
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.LocationValueSort(System.Int32)">
            <summary>
            Returns the sort representing a set of terms
            </summary>
        </member>
        <member name="P:NModel.Execution.FsmModelProgram.InitialState">
            <summary>
            Initial state
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.IsPotentiallyEnabled(NModel.Execution.IState,NModel.Terms.Symbol)">
            <summary>
            Returns true if the action symbol is potentially enabled in the given state
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.PotentiallyEnabledActionSymbols(NModel.Execution.IState)">
            <summary>
            Returns the set of all potentially enabled action symbols
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.HasActionParameterDomain(NModel.Execution.IState,NModel.Terms.Symbol,System.Int32)">
            <summary>
            Does this model program have an interface to parameter generation for this parameter?
            </summary>
            <param name="state"></param>
            <param name="actionSymbol"></param>
            <param name="parameterIndex"></param>
            <returns>A set of terms representing the possible values</returns>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.ActionParameterDomain(NModel.Execution.IState,NModel.Terms.Symbol,System.Int32)">
            <summary>
            Action parameter domain of the given action and parameter index in the given state
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.IsEnabled(NModel.Execution.IState,NModel.Terms.CompoundTerm)">
            <summary>
            Returns true if the action is enabled in the given state
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.GetEnablingConditionDescriptions(NModel.Execution.IState,NModel.Terms.CompoundTerm,System.Boolean)">
            <summary>
            Gets string descriptions of the enabling conditions
            </summary>
            <param name="state">The state in which the </param>
            <param name="action">The action whose enabling conditions will queried</param>
            <param name="returnFailures">If <c>true</c>, enabling conditions that fail in state 
            <paramref name="state"/> will be returned. If <c>false</c>, all enabling conditions
            that are satisfied will be returned.</param>
            <returns>An array of description strings for the enabling conditions of action <paramref name="action"/></returns>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.GetActions(NModel.Execution.IState,NModel.Terms.Symbol)">
            <summary>
            Enumerate all the enabled actions with the given symbol in the given state
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.GetTransitionPropertyNames">
            <summary>
            Returns the names of meta-properties that may be collected
            during the calculation of the <see cref="M:NModel.Execution.FsmModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>.
            </summary>
            <returns>The names of meta-properties to be collected
            during the calculation of the step.</returns>
            <seealso cref="M:NModel.Execution.FsmModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)">
            <summary>
            Produces the target state that results from invoking <paramref name="action"/>
            in the context of <paramref name="startState"/>.
            </summary>
            <param name="startState">The state in which the action is invoked</param>
            <param name="action">The action to be invoked</param>
            <param name="transitionPropertyNames">The names of meta-properties to be collected
            during the calculation of the step.</param>
            <param name="transitionProperties">Output parameter that will contain a 
            map of property names to property values. Each property value multiset of
            terms. For example, the property value might be the value of a Boolean function
            that controls state filtering. Or, it might correspond to the "coverage" of the model that results from this
            step. In this case, the value might denote the line numbers or blocks of the 
            model program that were exercised in this step, or a projection of the state 
            space or a reference to section numbers of a requirements document to indicate
            that the functionality defined by that section was exercised.</param>
            <returns>The state that results from the invocation of <paramref name="action"/>
            in <paramref name="startState"/>.</returns>
            <seealso cref="M:NModel.Execution.FsmModelProgram.GetTransitionPropertyNames"/>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.IsAccepting(NModel.Execution.IState)">
            <summary>
            Returns true if the given state is an accepting state
            </summary>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.SatisfiesStateInvariant(NModel.Execution.IState)">
            <summary>
            Boolean value indicating whether all state invariant predicates
            defined by this model program are satisfied by <paramref name="state"/>. In general,
            failure to satisfy the state invariants indicates a modeling error.
            </summary>
            <param name="state">The state</param>
            <returns>Returs true</returns>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.SatisfiesStateFilter(NModel.Execution.IState)">
            <summary>
            Boolean value indicating whether all state filter predicates
            defined by this model program are satisfied by <paramref name="state"/>. 
            </summary>
            <param name="state">The state</param>
            <returns>Returns true</returns>
        </member>
        <member name="M:NModel.Execution.FsmModelProgram.IsSortAbstract(NModel.Terms.Symbol)">
            <summary>
            Checks whether a sort is an abstract type. The corresponding set is created once in the constructor.
            </summary>
            <param name="s">A symbol denoting a sort (i.e. abstract type)</param>
            <returns>Returns always false for <see cref="T:NModel.Execution.FsmModelProgram"/></returns>
        </member>
        <member name="P:NModel.Execution.FsmModelProgram.Name">
            <summary>
            Returns the name of this model program.
            </summary>
        </member>
        <member name="T:NModel.Execution.ModelProgram">
            <summary>
            The interface to a model program. A model program is an abstraction of a program 
            in terms of a transition system. States of the program and transitions between
            them are explicit.
            </summary>
        </member>
        <member name="M:NModel.Execution.ModelProgram.ActionSymbols">
            <summary>
            Nonempty set of actions symbols.
            </summary>
            <returns>A value greater than or equal to zero.</returns>
            <remarks>A model program has a fixed vocabulary of action symbols.</remarks>
        </member>
        <member name="M:NModel.Execution.ModelProgram.ActionArity(NModel.Terms.Symbol)">
            <summary>
            Number of arguments associated with action symbol <paramref name="actionSymbol"/>
            </summary>
            <param name="actionSymbol">A symbol naming an action of this model program.</param>
            <returns>The number of arguments required in a <see cref="T:NModel.Terms.Term"/> invoking 
            this <paramref name="actionSymbol"/>. The value returned will be greater than or equal to zero.</returns>
            <remarks>
            Every action symbol has a fixed number of parameters associated with it. The number of parameters
            is called the action's <i>arity</i>.
            </remarks>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="actionSymbol"/> is not in this
            model program's fixed vocabulary given by <see cref="M:NModel.Execution.ModelProgram.ActionSymbols"/>.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="actionSymbol"/> is null</exception>
        </member>
        <member name="M:NModel.Execution.ModelProgram.ActionParameterSort(NModel.Terms.Symbol,System.Int32)">
            <summary>
            Gets the sort (i.e., abstract type) of the ith parameter of action <paramref name="actionSymbol"/>
            </summary>
            <param name="actionSymbol">A symbol naming an action of this model program.</param>
            <param name="parameterIndex">An integer in the interval [0, this.ActionArity(actionSymbol))</param>
            <returns>The sort (abstract type) of the ith parameter of action <paramref name="actionSymbol"/></returns>
            <remarks>
            <br><c>requires actionSymbol != null;</c></br>
            <br><c>requires this.ActionSymbols.Contains(actionSymbol);</c></br>
            <br><c>ensures parameterIndex &gt;= this.ActionArity(actionSymbol) ==&gt; result == new Symbol("Object");</c></br>
            </remarks>
        </member>
        <member name="P:NModel.Execution.ModelProgram.LocationValueCount">
            <summary>
            Number of location values in the state signature of this model program
            </summary>
            <remarks>
            <br><c>ensures result >= 0;</c></br>
            </remarks>
        </member>
        <member name="M:NModel.Execution.ModelProgram.LocationValueName(System.Int32)">
            <summary>
            String name identifying the ith location value in the state signature of this model program
            </summary>
            <param name="i">An index in the interval [0,  LocationValueClount)</param>
            <returns>String name identifying the ith location value</returns>
            <remarks>
            <br><c>requires 0 &lt;= i &amp;&amp; i &lt; this.LocationValueCount;</c></br>
            </remarks>
        </member>
        <member name="M:NModel.Execution.ModelProgram.LocationValueModelName(System.Int32)">
            <summary>
            Model program that provides the ith location value of the state signature of this model program.
            The result will be this model program, except under composition, when the result will the be 
            a leaf of the composition tree.
            <br><c>requires 0 &lt;= i &amp;&amp; i &lt; this.LocationValueCount;</c></br>
            </summary>
            <param name="i">An index in the interval [0,  LocationValueClount)</param>
            <returns>Model program that provides the ith location value.</returns>
        </member>
        <member name="M:NModel.Execution.ModelProgram.LocationValueSort(System.Int32)">
            <summary>
            Symbol denoting the sort (abstract type) of the ith location value in the state signature 
            of this model program
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NModel.Execution.ModelProgram.InitialState">
            <summary>
            The initial state.
            </summary>
            <remarks>
            <br>ensures result != null;</br>
            <br>ensures result.ModelProgram == this; </br>
            </remarks>
        </member>
        <member name="M:NModel.Execution.ModelProgram.IsPotentiallyEnabled(NModel.Execution.IState,NModel.Terms.Symbol)">
            <summary>
            Checks whether a given action is potentially enabled 
            in this state.
            <br><c>requires state != null;</c></br>
            <br>requires state.ModelProgram == this; </br>
            <br>requires actionSymbol != null;</br>
            </summary>
        </member>
        <member name="M:NModel.Execution.ModelProgram.PotentiallyEnabledActionSymbols(NModel.Execution.IState)">
            <summary>
            Enumerates the action symbols that are potentially enabled with respect to this
            control point and data state.
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Execution.ModelProgram.IsEnabled(NModel.Execution.IState,NModel.Terms.CompoundTerm)">
            <summary>
            Checks if a ground label is enabled in this control state with respect to a data state
            
            requires: data != null
            requires: label != null and label.IsGround
            </summary>
        </member>
        <member name="M:NModel.Execution.ModelProgram.GetEnablingConditionDescriptions(NModel.Execution.IState,NModel.Terms.CompoundTerm,System.Boolean)">
            <summary>
            Gets string descriptions of the enabling conditions
            </summary>
            <param name="state">The state in which the </param>
            <param name="action">The action whose enabling conditions will queried</param>
            <param name="returnFailures">If <c>true</c>, enabling conditions that fail in state 
            <paramref name="state"/> will be returned. If <c>false</c>, all enabling conditions
            that are satisfied will be returned.</param>
            <returns>Description strings for the enabling conditions of action <paramref name="action"/></returns>
        </member>
        <member name="M:NModel.Execution.ModelProgram.HasActionParameterDomain(NModel.Execution.IState,NModel.Terms.Symbol,System.Int32)">
            <summary>
            Does this model program have an interface to parameter generation for this parameter?
            </summary>
            <param name="state"></param>
            <param name="actionSymbol"></param>
            <param name="parameterIndex"></param>
            <returns>A set of terms representing the possible values</returns>
        </member>
        <member name="M:NModel.Execution.ModelProgram.ActionParameterDomain(NModel.Execution.IState,NModel.Terms.Symbol,System.Int32)">
            <summary>
            Interface to parameter generation
            </summary>
            <param name="state"></param>
            <param name="actionSymbol"></param>
            <param name="parameterIndex"></param>
            <returns>A set of terms representing the possible values</returns>
        </member>
        <member name="M:NModel.Execution.ModelProgram.GetActions(NModel.Execution.IState,NModel.Terms.Symbol)">
            <summary>
            Gets the actions of an action symbol in the given state.
            Note: interface to parameter generation. May return non-ground terms.
            </summary>
        </member>
        <member name="M:NModel.Execution.ModelProgram.GetTransitionPropertyNames">
            <summary>
            Returns the names of meta-properties that may be collected
            during the calculation of the <see cref="M:NModel.Execution.ModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>.
            </summary>
            <returns>The names of meta-properties to be collected
            during the calculation of the step.</returns>
            <seealso cref="M:NModel.Execution.ModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>
        </member>
        <member name="M:NModel.Execution.ModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)">
            <summary>
            Produces the target state that results from invoking <paramref name="action"/>
            in the context of <paramref name="startState"/>.
            </summary>
            <param name="startState">The state in which the action is invoked</param>
            <param name="action">The action to be invoked</param>
            <param name="transitionPropertyNames">The names of meta-properties to be collected
            during the calculation of the step.</param>
            <param name="transitionProperties">Output parameter that will contain a 
            map of property names to property values. Each property value multiset of
            terms. For example, the property value might be the value of a Boolean function
            that controls state filtering. Or, it might correspond to the "coverage" of the model that results from this
            step. In this case, the value might denote the line numbers or blocks of the 
            model program that were exercised in this step, or a projection of the state 
            space or a reference to section numbers of a requirements document to indicate
            that the functionality defined by that section was exercised.</param>
            <returns>The state that results from the invocation of <paramref name="action"/>
            in <paramref name="startState"/>.</returns>
            <seealso cref="M:NModel.Execution.ModelProgram.GetTransitionPropertyNames"/>
        </member>
        <member name="M:NModel.Execution.ModelProgram.IsAccepting(NModel.Execution.IState)">
            <summary>
            The accepting status of a state of this model program. Valid runs of 
            a model program must terminate in an accepting state.
            <br>requires state != null;</br>
            <br>requires state.ModelProgram == this; </br>
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Execution.ModelProgram.SatisfiesStateInvariant(NModel.Execution.IState)">
            <summary>
            Boolean value indicating whether all state invariant predicates
            defined by this model program are satisfied by <paramref name="state"/>. In general,
            failure to satisfy the state invariants indicates a modeling error.
            </summary>
            <param name="state">The state</param>
            <returns>True if <paramref name="state"/>satisfies all state invariants of 
            this model program; false otherwise.</returns>
        </member>
        <member name="M:NModel.Execution.ModelProgram.SatisfiesStateFilter(NModel.Execution.IState)">
            <summary>
            Boolean value indicating whether all state filter predicates
            defined by this model program are satisfied by <paramref name="state"/>. 
            States not satisfying a state filter are excluded during exploration.
            </summary>
            <param name="state">The state</param>
            <returns>True if <paramref name="state"/>satisfies all state filters of 
            this model program; false otherwise.</returns>
        </member>
        <member name="M:NModel.Execution.ModelProgram.IsSortAbstract(NModel.Terms.Symbol)">
            <summary>
            Checks whether a sort is an abstract type. The corresponding set is created once in the constructor.
            </summary>
            <param name="s">A symbol denoting a sort (i.e. abstract type)</param>
            <returns>true if the sort is abstract, false otherwise.</returns>
        </member>
        <member name="M:NModel.Execution.ModelProgram.IsFieldStatic(System.Int32)">
            <summary>
            Checks whether the field denoted by the index is a static field or a fieldmap.
            This check is only valid with the <see cref="T:NModel.Execution.LibraryModelProgram"/> type.
            </summary>
            <param name="i">Index of the field</param>
            <returns>true if the field is static</returns>
        </member>
        <member name="T:NModel.Execution.IName">
            <summary>
            Interface to provide a name.
            </summary>
        </member>
        <member name="P:NModel.Execution.IName.Name">
            <summary>
            Provided name
            </summary>
        </member>
        <member name="T:NModel.Execution.IState">
            <summary>
            <para>State is a value type that represents a distinct control and data configuration
            of a model program.</para>
            <para>Values are terms.</para>
            </summary>
            <note><c>IState</c> is a value type. <c>Equals()</c> and <c>GetHashCode()</c> must
            be overridden appropriately. <c>IComparable</c> must be implemented to allow state to
            appear in value collections such as sets and maps.</note>
        </member>
        <member name="P:NModel.Execution.IState.ControlMode">
            <summary>
            A term denoting the control state of the model program in this state
            </summary>
        </member>
        <member name="T:NModel.Execution.IExtendedState">
            <summary>
            A state of a model program with data fields, in the spirit of 
            extended finite state machines (EFSMs).
            </summary>
        </member>
        <member name="M:NModel.Execution.IExtendedState.GetLocationValue(System.Int32)">
            <summary>
            Accessor for elements of data state
            </summary>
            <param name="i">An index in [0, this.LocationValuesCount) </param>
            <returns>The term representing the value of this location</returns>
        </member>
        <member name="P:NModel.Execution.IExtendedState.LocationValuesCount">
            <summary>
            The number of location values
            </summary>
        </member>
        <member name="P:NModel.Execution.IExtendedState.DomainMap">
            <summary>
            A map of domain names to integers that repesent the next available id. This is used
            when generating labels of dynamically created instances.
            </summary>
        </member>
        <member name="P:NModel.Execution.IExtendedState.ModelName">
            <summary>
            The string name of the model program that produced this state. Used for printing; 
            not guaranteed to be distinct.
            </summary>
        </member>
        <member name="M:NModel.Execution.IExtendedState.GetLocationName(System.Int32)">
            <summary>
            Returns the string name of the model program state variable indexed by <paramref name="locationId"/>.
            This is not guaranteed to be distinct.
            </summary>
            <param name="locationId">The ith location of this state</param>
            <returns>The string name of the model program state variable for <paramref name="locationId"/></returns>
        </member>
        <member name="T:NModel.Execution.IPairState">
            <summary>
            A state of a product machine.
            </summary>
        </member>
        <member name="P:NModel.Execution.IPairState.First">
            <summary>
            The first state
            </summary>
        </member>
        <member name="P:NModel.Execution.IPairState.Second">
            <summary>
            The second state
            </summary>
        </member>
        <member name="T:NModel.Execution.ActionInfo">
            <summary>
            Action symbol that maps to a .Net method
            </summary>
        </member>
        <member name="M:NModel.Execution.EnablingCondition.#ctor(System.Boolean,System.Type[],System.Reflection.MethodInfo)">
            <summary>
            Creates an enabling condition for an action method.
            </summary>
        </member>
        <member name="T:NModel.Execution.Field">
            <summary>
            A field of a .Net class that has corresponds to a state variable. May be a static field or an instance field.
            </summary>
        </member>
        <member name="T:NModel.Execution.ActionKind">
            <summary>
            Represents the kind of an action
            </summary>
        </member>
        <member name="F:NModel.Execution.ActionKind.Atomic">
            <summary>
            Atomic action
            </summary>
        </member>
        <member name="F:NModel.Execution.ActionKind.Start">
            <summary>
            Start action
            </summary>
        </member>
        <member name="F:NModel.Execution.ActionKind.Finish">
            <summary>
            Finish action
            </summary>
        </member>
        <member name="T:NModel.Execution.LibraryModelProgram">
            <summary>
            Creates a model program from an assembly
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.name">
            <summary>
            Model name given by attribute. A model is a collection of class declarations 
            have the same the same [Model] attribute.
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.modelAssembly">
            <summary>
            .NET assembly that contains this model
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.context">
            <summary>
            Runtime environment (or context) that allows terms to be interpreted with respect
            to this model program. For example, the context shows what type corresponds to a given 
            model sort.
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.stateChangedPredicate">
            <summary>
            "Dirty bit" used to indicate that the .NET state no longer matches the values given by the
            current state field.
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.currentState">
            <summary>
            The most recent argument to "SetState". 
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.continuations">
            <summary>
            Table of enabled actions for states with continuations given by suspension points.
            A state's control mode is the "readyControlMode" iff there are no continuations.
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.readyControlMode">
            <summary>
            The control mode that indicates that any enabled action may occur.
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.stateFields">
            <summary>
            The .NET fields that form the basis of states of this model program. The ith state variable 
            corresponds to the ith instance field
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.locationNames">
            <summary>
            The name of each location of state. This matches positionally with stateFields 
            and stateVariables. This is a cache-- it is always equal to the names found in 
            stateVariables.
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.stateVariables">
            <summary>
            Table of location names and sorts that make up state. 
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.actionInfoMap">
            <summary>
            Table of actions to .NET reflection info. All actions (Start, Atomic and Finish) 
            are representated in the table. 
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.finishActionSymbols">
            <summary>
            Cache: dictionary mapping start action symbols to corresponding finish action symbols
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.actionSymbols">
            <summary>
            The vocabulary of actions for this model program
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.acceptingStateConditions">
            <summary>
            Accepting state conditions
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.stateInvariants">
            <summary>
            State invariants
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.stateFilters">
            <summary>
            State filters
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.initialState">
            <summary>
            Field for caching the initial state;
            </summary>
        </member>
        <member name="F:NModel.Execution.LibraryModelProgram.abstractSorts">
            <summary>
            A dictionary that to distinguish which sort is abstract.
            </summary>
        </member>
        <member name="P:NModel.Execution.LibraryModelProgram.AllModeledRequirements">
            <summary>
            Returns all the requirements documents in the model
            </summary>
        </member>
        <member name="P:NModel.Execution.LibraryModelProgram.ModelAssembly">
            <summary>
            Get the model assembly
            </summary>
        </member>
        <member name="P:NModel.Execution.LibraryModelProgram.Name">
            <summary>
            Returns the model name of this model program.
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.#ctor(System.String,System.String,NModel.Set{System.String})">
            <summary>
            Create an instance of LibraryModelProgram for a given assembly
            </summary>
            <param name="modelAssemblyFile">The full path to the assembly file.</param>
            <param name="modelName">Name of the model namespace to be loaded. 
            Only classes in the model namespace will be loaded.</param>
            <param name="featureNames">The names of features to be loaded. If null, all
            features will be loaded for the given modelName. See <see cref="T:NModel.Attributes.FeatureAttribute"/>.</param>
            <exception cref="T:NModel.Execution.ModelProgramUserException">Thrown if there is a usage error in the given assembly.</exception>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.#ctor(System.String,System.String)">
            <summary>
            Create an instance of LibraryModelProgram for a given assembly
            </summary>
            <param name="modelAssemblyFile">The full path to the assembly file.</param>
            <param name="modelName">Name of the model namespace to be loaded. 
            Only classes in the model namespace will be loaded.</param>
            <exception cref="T:NModel.Execution.ModelProgramUserException">Thrown if there is a usage error in the given assembly.</exception>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.#ctor(System.Reflection.Assembly,System.String)">
            <summary>
            Create an instance of LibraryModelProgram for a given assembly
            </summary>
            <param name="modAssembly">Loaded assembly</param>
            <param name="modelName">Name of the model namespace to be loaded. 
            Only classes in the model namespace will be loaded.</param>
            <exception cref="T:NModel.Execution.ModelProgramUserException">Thrown if there is a usage error in the given assembly.</exception>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.#ctor(System.Reflection.Assembly,System.String,NModel.Set{System.String})">
            <summary>
            Create an instance of LibraryModelProgram for a given assembly
            </summary>
            <param name="modAssembly">Loaded assembly</param>
            <param name="modelName">Name of the model namespace to be loaded. 
            Only classes in the model namespace will be loaded.</param>
            <param name="featureNames">The names of features to be loaded. If null, all
            features will be loaded for the given modelName. See <see cref="T:NModel.Attributes.FeatureAttribute"/>.</param>
            <exception cref="T:NModel.Execution.ModelProgramUserException">Thrown if there is a usage error in the given assembly.</exception>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.InsertActionMethodStart(NModel.Execution.Method,NModel.Terms.CompoundTerm,NModel.Execution.ActionMethodFinish,System.Collections.Generic.Dictionary{NModel.Terms.Symbol,NModel.Execution.ActionInfo})">
            <summary>
            Adds an <see>ActionMethod</see> entry for <paramref name="startActionLabel"/> in the dictionary.
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.InsertActionMethodFinish(NModel.Execution.Method,NModel.Terms.CompoundTerm,System.Collections.Generic.Dictionary{NModel.Terms.Symbol,NModel.Execution.ActionInfo})">
            <summary>
            Adds an <see>ActionMethod</see> entry for <paramref name="finishActionLabel"/> in the dictionary.
            </summary>
            <param name="method"></param>
            <param name="finishActionLabel"></param>
            <param name="aInfoMap"></param>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.ActionSymbolKind(NModel.Terms.Symbol)">
            <summary>
            Returns the kind of the action symbol
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.Create(System.Reflection.Assembly,System.String,NModel.Set{System.String})">
            <summary>
            Create a library model program from a given assembly, given a model 
            in that assembly, and a given set of features within that model.
            </summary>
            <param name="assembly">loaded assembly</param>
            <param name="model">model namespace within the assembly</param>
            <param name="features">features within the model namespace</param>
            <returns>Model porogram including the given features</returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.Create(System.Type,System.String[])">
            <summary>
            Create a library model program from a given type t.
            The namespace of t is the name of the model program.
            Only listed features are included in the model program.
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.GetInitialState">
            <summary>
            Gets the initial state of the ModelProgram. 
            </summary>
            <returns>The initial state</returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.ActionSymbols">
            <summary>
            Action vocabulary
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.ActionArity(NModel.Terms.Symbol)">
            <summary>
            Number of arguments taken by the action symbol
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.ActionParameterSort(NModel.Terms.Symbol,System.Int32)">
            <summary>
            Parameter sort of the given parameter index and given action symbol
            </summary>
        </member>
        <member name="P:NModel.Execution.LibraryModelProgram.LocationValueCount">
            <summary>
            Number of locations (state variables)
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.LocationValueName(System.Int32)">
            <summary>
            Name of the i'th state variable
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.LocationValueModelName(System.Int32)">
            <summary>
            Returns this.Name
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.LocationValueSort(System.Int32)">
            <summary>
            Sort of the i'th variable
            </summary>
        </member>
        <member name="P:NModel.Execution.LibraryModelProgram.InitialState">
            <summary>
            The initial state.
            <br>ensures result != null;</br>
            <br>ensures result.ModelProgram == this; </br>
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.IsAccepting(NModel.Execution.IState)">
            <summary>
            Evaluates the conjunction of all the accepting state conditions in the given state
            </summary>
            <param name="state">given state</param>
            <returns>true if the state is an accepting state</returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.SatisfiesStateInvariant(NModel.Execution.IState)">
            <summary>
            Boolean value indicating whether all state invariant predicates
            defined by this model program are satisfied by <paramref name="state"/>. In general,
            failure to satisfy the state invariants indicates a modeling error.
            </summary>
            <param name="state">The state</param>
            <returns>True if <paramref name="state"/>satisfies all state invariants of 
            this model program; false otherwise.</returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.SatisfiesStateFilter(NModel.Execution.IState)">
            <summary>
            Boolean value indicating whether all state filter predicates
            defined by this model program are satisfied by <paramref name="state"/>. 
            States that do not satisfy a filter are excluded during exploration.
            </summary>
            <param name="state">The state</param>
            <returns>True if <paramref name="state"/>satisfies all state filters of 
            this model program; false otherwise.</returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.IsSortAbstract(NModel.Terms.Symbol)">
            <summary>
            Checks whether a sort is an abstract type. The corresponding set is created once in the constructor.
            </summary>
            <param name="s">A symbol denoting a sort (i.e. abstract type)</param>
            <returns>true if the sort is abstract, false otherwise.</returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.IsFieldStatic(System.Int32)">
            <summary>
            Checks whether the field denoted by the index is a static field or a fieldmap. 
            </summary>
            <param name="i">Index of the field</param>
            <returns>true if the field is static</returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.IsPotentiallyEnabled(NModel.Execution.IState,NModel.Terms.Symbol)">
            <summary>
            Returns true if the given action symbol is possibly enabled in the given state
            </summary>
            <param name="state"></param>
            <param name="actionSymbol"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.PotentiallyEnabledActionSymbols(NModel.Execution.IState)">
            <summary>
            Returns all the possibly (potentially) enabled action symbols in the given state
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.HasMissingParameterDomains(NModel.Execution.IState)">
            <summary>
            Returns true if the library model program has missing parameter domains
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.MissingParameterDomains(NModel.Execution.IState)">
            <summary>
            Enumerates the missing parameter domains in the given state
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.HasActionParameterDomain(NModel.Execution.IState,NModel.Terms.Symbol,System.Int32)">
            <summary>
            Does this model program have an interface to parameter generation for this parameter?
            </summary>
            <param name="state"></param>
            <param name="actionSymbol"></param>
            <param name="parameterIndex"></param>
            <returns>A set of terms representing the possible values</returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.ActionParameterDomain(NModel.Execution.IState,NModel.Terms.Symbol,System.Int32)">
            <summary>
            
            </summary>
            <param name="state"></param>
            <param name="actionSymbol"></param>
            <param name="parameterIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.IsEnabled(NModel.Execution.IState,NModel.Terms.CompoundTerm)">
            <summary>
            Returns true if the given action is enabeld in the given state
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.GetEnablingConditionDescriptions(NModel.Execution.IState,NModel.Terms.CompoundTerm,System.Boolean)">
            <summary>
            Gets string descriptions of the enabling conditions
            </summary>
            <param name="state">The state in which the </param>
            <param name="action">The action whose enabling conditions will queried</param>
            <param name="returnFailures">If <c>true</c>, enabling conditions that fail in state 
            <paramref name="state"/> will be returned. If <c>false</c>, all enabling conditions
            that are satisfied will be returned.</param>
            <returns>An array of description strings for the enabling conditions of action <paramref name="action"/></returns>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.GetActions(NModel.Execution.IState,NModel.Terms.Symbol)">
            <summary>
            Enumerates all the enabled actions in the given state with the given action symbol.
            </summary>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.GetTransitionPropertyNames">
            <summary>
            Returns the names of meta-properties that may be collected
            during the calculation of the <see cref="M:NModel.Execution.LibraryModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>.
            </summary>
            <returns>The names of meta-properties to be collected
            during the calculation of the step.</returns>
            <seealso cref="M:NModel.Execution.LibraryModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>
        </member>
        <member name="M:NModel.Execution.LibraryModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)">
            <summary>
            Produces the target state that results from invoking <paramref name="action"/>
            in the context of <paramref name="startState"/>.
            </summary>
            <param name="startState">The state in which the action is invoked</param>
            <param name="action">The action to be invoked</param>
            <param name="transitionPropertyNames">The names of meta-properties to be collected
            during the calculation of the step.</param>
            <param name="transitionProperties">Output parameter that will contain a 
            map of property names to property values. Each property value multiset of
            terms. For example, the property value might be the value of a Boolean function
            that controls state filtering. Or, it might correspond to the "coverage" of the model that results from this
            step. In this case, the value might denote the line numbers or blocks of the 
            model program that were exercised in this step, or a projection of the state 
            space or a reference to section numbers of a requirements document to indicate
            that the functionality defined by that section was exercised.</param>
            <returns>The state that results from the invocation of <paramref name="action"/>
            in <paramref name="startState"/>.</returns>
            <seealso cref="M:NModel.Execution.LibraryModelProgram.GetTransitionPropertyNames"/>
        </member>
        <member name="T:NModel.Execution.MachineStep">
            <summary>
            The value type of machine steps.
            </summary>
        </member>
        <member name="M:NModel.Execution.MachineStep.FieldValues">
            <summary>
            Enumerates the constituents of this compound value.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NModel.Execution.MachineStep.Action">
            <summary>
            The action label of the step.
            </summary>
        </member>
        <member name="P:NModel.Execution.MachineStep.TargetState">
            <summary>
            The target data state of the step.
            </summary>
        </member>
        <member name="M:NModel.Execution.MachineStep.#ctor(NModel.Terms.CompoundTerm,NModel.Execution.IState)">
            <summary>
            A step is an action term and a target state.
            </summary>
            <param name="action">The action term that was invoked</param>
            <param name="targetState">The state that resulted from the invocation</param>
        </member>
        <member name="T:NModel.Execution.ModelProgramUserException">
            <summary>
            Exception thrown on invalid user input to the ModelProgram library
            </summary>
        </member>
        <member name="M:NModel.Execution.ModelProgramUserException.#ctor(System.String)">
            <summary>
            Constructor of <c>ModelProgramUserException</c>
            </summary>
            <param name="msg">The error message</param>
        </member>
        <member name="M:NModel.Execution.ModelProgramUserException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor of <c>ModelProgramUserException</c>
            </summary>
            <param name="msg">The error message</param>
            <param name="e">inner exception</param>
        </member>
        <member name="M:NModel.Execution.ModelProgramUserException.#ctor">
            <summary>
            Empty constructor of <c>ModelProgramUserException</c>
            </summary>
        </member>
        <member name="M:NModel.Execution.ModelProgramUserException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor of <c>ModelProgramUserException</c>
            </summary>
        </member>
        <member name="T:NModel.Execution.ProductModelProgram">
            <summary>
            Represents a model program that is a product composition of other model programs
            </summary>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.#ctor(NModel.Execution.ModelProgram,NModel.Execution.ModelProgram)">
            <summary>
            Constructs m1 * m2
            </summary>
        </member>
        <member name="P:NModel.Execution.ProductModelProgram.M1">
            <summary>
            The first operand of the composed model program M1 * M2
            </summary>
        </member>
        <member name="P:NModel.Execution.ProductModelProgram.M2">
            <summary>
            The second operand of the composed model program M1 * M2
            </summary>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.ActionSymbols">
            <summary>
            Nonempty set of actions symbols.
            <br><c>ensures result.Count &gt; 0</c></br>
            </summary>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.ActionArity(NModel.Terms.Symbol)">
            <summary>
            Number of arguments associated with action symbol <paramref name="actionSymbol"/>
            <br><c>requires actionSymbol != null;</c></br>
            <br><c>requires this.ActionSymbols.Contains(actionSymbol);</c></br>
            <br><c>ensures result &gt;= 0</c></br>
            </summary>
            <param name="actionSymbol">A symbol naming an action of this model program.</param>
            <returns>The number of arguments required in a <see cref="T:NModel.Terms.Term"/> invoking this <paramref name="actionSymbol"/></returns>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.ActionParameterSort(NModel.Terms.Symbol,System.Int32)">
            <summary>
            Gets the sort (i.e., abstract type) of the ith parameter of action <paramref name="actionSymbol"/>
            <br><c>requires actionSymbol != null;</c></br>
            <br><c>requires this.ActionSymbols.Contains(actionSymbol);</c></br>
            <br><c>requires 0 &lt;= parameterIndex &amp;&amp; parameterIndex &lt; this.ActionArity(actionSymbol);</c></br>
            </summary>
            <param name="actionSymbol">A symbol naming an action of this model program.</param>
            <param name="parameterIndex">An integer in the interval [0, this.ActionArity(actionSymbol))</param>
            <returns>The sort (abstract type) of the ith parameter of action <paramref name="actionSymbol"/></returns>
        </member>
        <member name="P:NModel.Execution.ProductModelProgram.LocationValueCount">
            <summary>
            Number of location values in the state signature of this model program
            <br><c>ensures result >= 0;</c></br>
            </summary>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.LocationValueName(System.Int32)">
            <summary>
            String name identifying the ith location value in the state signature of this model program
            <br><c>requires 0 &lt;= i &amp;&amp; i &lt; this.LocationValueCount;</c></br>
            </summary>
            <param name="i">An index in the interval [0,  LocationValueClount)</param>
            <returns>String name identifying the ith location value</returns>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.LocationValueModelName(System.Int32)">
            <summary>
            Model program that provides the ith location value of the state signature of this model program.
            The result will be this model program, except under composition, when the result will the be 
            a leaf of the composition tree.
            <br><c>requires 0 &lt;= i &amp;&amp; i &lt; this.LocationValueCount;</c></br>
            </summary>
            <param name="i">An index in the interval [0,  LocationValueClount)</param>
            <returns>Model program that provides the ith location value.</returns>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.LocationValueSort(System.Int32)">
            <summary>
            Symbol denoting the sort (abstract type) of the ith location value in the state signature 
            of this model program
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NModel.Execution.ProductModelProgram.InitialState">
            <summary>
            Initial state
            </summary>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.IsPotentiallyEnabled(NModel.Execution.IState,NModel.Terms.Symbol)">
            <summary>
            Checks whether a given action is potentially enabled 
            in this state.
            <br><c>requires state != null;</c></br>
            <br>requires state.ModelProgram == this; </br>
            <br>requires actionSymbol != null;</br>
            </summary>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.PotentiallyEnabledActionSymbols(NModel.Execution.IState)">
            <summary>
            Enumerates the action symbols that are potentially enabled with respect to this
            control point and data state.
            </summary>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.HasActionParameterDomain(NModel.Execution.IState,NModel.Terms.Symbol,System.Int32)">
            <summary>
            Does this model program have an interface to parameter generation for this parameter?
            </summary>
            <param name="state"></param>
            <param name="actionSymbol"></param>
            <param name="parameterIndex"></param>
            <returns>A set of terms representing the possible values</returns>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.ActionParameterDomain(NModel.Execution.IState,NModel.Terms.Symbol,System.Int32)">
            <summary>
            Get the value domain of the given action parameter in the given state
            </summary>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.IsEnabled(NModel.Execution.IState,NModel.Terms.CompoundTerm)">
            <summary>
            Returns true if the action is enabled in the given state
            </summary>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.GetEnablingConditionDescriptions(NModel.Execution.IState,NModel.Terms.CompoundTerm,System.Boolean)">
            <summary>
            Gets string descriptions of the enabling conditions
            </summary>
            <param name="state">The state in which the </param>
            <param name="action">The action whose enabling conditions will queried</param>
            <param name="returnFailures">If <c>true</c>, enabling conditions that fail in state 
            <paramref name="state"/> will be returned. If <c>false</c>, all enabling conditions
            that are satisfied will be returned.</param>
            <returns>An array of description strings for the enabling conditions of action <paramref name="action"/></returns>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.GetActions(NModel.Execution.IState,NModel.Terms.Symbol)">
            <summary>
            Gets all enabled actions in the given state that have the given action symbol
            </summary>
            <param name="state"></param>
            <param name="actionSymbol"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.GetTransitionPropertyNames">
            <summary>
            Returns the names of meta-properties that may be collected
            during the calculation of the <see cref="M:NModel.Execution.ProductModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>.
            </summary>
            <returns>The names of meta-properties to be collected
            during the calculation of the step.</returns>
            <seealso cref="M:NModel.Execution.ProductModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)">
            <summary>
            Produces the target state that results from invoking <paramref name="action"/>
            in the context of <paramref name="startState"/>.
            </summary>
            <param name="startState">The state in which the action is invoked</param>
            <param name="action">The action to be invoked</param>
            <param name="transitionPropertyNames">The names of meta-properties to be collected
            during the calculation of the step.</param>
            <param name="transitionProperties">Output parameter that will contain a 
            map of property names to property values. Each property value multiset of
            terms. For example, the property value might be the value of a Boolean function
            that controls state filtering. Or, it might correspond to the "coverage" of the model that results from this
            step. In this case, the value might denote the line numbers or blocks of the 
            model program that were exercised in this step, or a projection of the state 
            space or a reference to section numbers of a requirements document to indicate
            that the functionality defined by that section was exercised.</param>
            <returns>The state that results from the invocation of <paramref name="action"/>
            in <paramref name="startState"/>.</returns>
            <seealso cref="M:NModel.Execution.ProductModelProgram.GetTransitionPropertyNames"/>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.IsAccepting(NModel.Execution.IState)">
            <summary>
            Returns true if all the component states are accepting states
            </summary>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.SatisfiesStateInvariant(NModel.Execution.IState)">
            <summary>
            Boolean value indicating whether all state invariant predicates
            defined by this model program are satisfied by <paramref name="state"/>. In general,
            failure to satisfy the state invariants indicates a modeling error.
            </summary>
            <param name="state">The state</param>
            <returns>True if <paramref name="state"/>satisfies all state invariants of 
            this model program; false otherwise.</returns>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.SatisfiesStateFilter(NModel.Execution.IState)">
            <summary>
            Boolean value indicating whether all state filter predicates
            defined by this model program are satisfied by <paramref name="state"/>. 
            States not satisfying a state filter are excluded during exploration.
            </summary>
            <param name="state">The state</param>
            <returns>True if <paramref name="state"/>satisfies all state filters of 
            this model program; false otherwise.</returns>
        </member>
        <member name="M:NModel.Execution.ProductModelProgram.IsSortAbstract(NModel.Terms.Symbol)">
            <summary>
            Checks whether a sort is an abstract type. The corresponding set is created once in the constructor.
            </summary>
            <param name="s">A symbol denoting a sort (i.e. abstract type)</param>
            <returns>Returns true if the sort corresponding to the symbol is abstract.</returns>
        </member>
        <member name="T:NModel.Execution.SimpleState">
            <summary>
            SimpleState implements a basic mapping of fields to values.
            </summary>
        </member>
        <member name="P:NModel.Execution.SimpleState.ControlMode">
            <summary>
            A term denoting the control state of the machine in this state
            </summary>
        </member>
        <member name="P:NModel.Execution.SimpleState.DomainMap">
            <summary>
            A map of sorts (abstract types) to integers that repesent the next available id
            </summary>
        </member>
        <member name="M:NModel.Execution.SimpleState.GetLocationValue(System.Int32)">
            <summary>
            Accessor for elements of data state
            </summary>
            <param name="i">An index in [0, this.LocationValuesCount) </param>
            <returns>The term representing the value of this location</returns>
        </member>
        <member name="P:NModel.Execution.SimpleState.LocationValuesCount">
            <summary>
            The number of location values
            </summary>
        </member>
        <member name="F:NModel.Execution.SimpleState.cache">
            <summary>
            Since states are immutable, we intern states in a table to improve the performance of
            subsequent comparisons for equality. To prevent a memory leak, we use a weak cache that does not prevent
            the garbage collector from reclaiming an otherwise unreferenced state.
            
            This will optimize comparison at the expense of more work during construction. The assumption is 
            that states will be compared many more times than they will be constructed.
            </summary>
        </member>
        <member name="M:NModel.Execution.SimpleState.CreateState(NModel.Terms.Term,NModel.Terms.Term[],NModel.Map{NModel.Terms.Symbol,System.Int32},System.String,NModel.ValueArray{System.String})">
            <summary>
            Creates a state.
            </summary>
            <param name="controlMode">The control state of the machine</param>
            <param name="fieldValues">The values of each data field. This array is captured; the method
            assumes that the array passed as an argument will never be modified.</param>
            <param name="domainMap">A mapping of domain names to integers that represent the next available id.</param>
            <param name="modelName">name of the model</param>
            <param name="locationNames">names of locations</param>
            <returns>A state with the given control mode, field values and domain map.</returns>
        </member>
        <member name="M:NModel.Execution.SimpleState.ReplaceControlMode(NModel.Terms.Term)">
            <summary>
            Retuns a new simple state where the control mode has been replaced with the new one
            </summary>
        </member>
        <member name="M:NModel.Execution.SimpleState.CreateState(NModel.Terms.Term,NModel.Terms.Term[],System.String,NModel.ValueArray{System.String})">
            <summary>
            Can be used when no instance fields are present
            </summary>
        </member>
        <member name="M:NModel.Execution.SimpleState.#ctor(NModel.Terms.Term,NModel.Terms.Term[],NModel.Map{NModel.Terms.Symbol,System.Int32},System.String,NModel.ValueArray{System.String})">
            <summary>
            <para>The constructor of a State value</para>
            <para>This constructor should only be called by an implementer of ModelProgram.</para>
            </summary>
            <param name="fieldValues">
            An array of values that denote the interpretation of fields in this state. Fields
            are identified positionally. <see>class StateCollection</see>
            <para>Since the caller guarantess to transfer ownership no clone of the input argument is used here.</para>
            </param>
            <param name="controlMode">control mode of the simple state</param>
            <param name="domainMap">domain map</param>
            <param name="locationNames">string names of locations</param>
            <param name="modelName">name of the model</param>
        </member>
        <member name="M:NModel.Execution.SimpleState.#ctor(NModel.Terms.Term,NModel.Terms.Term[],System.String,NModel.ValueArray{System.String})">
            <summary>
            Constructs a simple state with the given arguments
            </summary>
        </member>
        <member name="M:NModel.Execution.SimpleState.GetHashCode">
            <summary>
            Override of Object.GetHashCode(). 
            </summary>
            <returns>The hash value associated with this state.</returns>
        </member>
        <member name="M:NModel.Execution.SimpleState.Equals(System.Object)">
            <summary>
            Override of Object.Equal for States.
            </summary>
            <param name="obj">The second object.</param>
            <returns></returns>
        </member>
        <member name="M:NModel.Execution.SimpleState.FieldValues">
            <summary>
            Field values
            </summary>
            <returns>Structure field values</returns>
        </member>
        <member name="P:NModel.Execution.SimpleState.ModelName">
            <summary>
            Get the model name
            </summary>
        </member>
        <member name="M:NModel.Execution.SimpleState.GetLocationName(System.Int32)">
            <summary>
            Get the name of the location for the given location id
            </summary>
        </member>
        <member name="T:NModel.Execution.PairState">
            <summary>
            Represents a pair of states.
            Pair states are used in product model programs.
            </summary>
        </member>
        <member name="P:NModel.Execution.PairState.First">
            <summary>
            First state of the pair state
            </summary>
        </member>
        <member name="P:NModel.Execution.PairState.Second">
            <summary>
            Second state of the pair state
            </summary>
        </member>
        <member name="F:NModel.Execution.PairState.cache">
            <summary>
            Since states are immutable, we intern states in a table to improve the performance of
            subsequent comparisons for equality. To prevent a memory leak, we use a weak cache that does not prevent
            the garbage collector from reclaiming an otherwise unreferenced state.
            
            This will optimize comparison at the expense of more work during construction. The assumption is 
            that states will be compared many more times than they will be constructed.
            </summary>
        </member>
        <member name="M:NModel.Execution.PairState.CreateState(NModel.Execution.IState,NModel.Execution.IState)">
            <summary>
            Create a pair state from two states
            </summary>
        </member>
        <member name="M:NModel.Execution.PairState.#ctor(NModel.Execution.IState,NModel.Execution.IState)">
            <summary>
            Create a pair state from two states
            </summary>
        </member>
        <member name="M:NModel.Execution.PairState.FieldValues">
            <summary>
            Get the field values in the first and the second states
            </summary>
        </member>
        <member name="P:NModel.Execution.PairState.ControlMode">
            <summary>
            Control mode of the state
            </summary>
        </member>
        <member name="T:NModel.Execution.Location">
            <summary>
            Locations are labels that identify elements of state.
            There is one location per field in the case of static fields.
            </summary>
        </member>
        <member name="M:NModel.Execution.Location.#ctor(NModel.Terms.Term[])">
            <summary>
            Creates a location with the given values
            </summary>
        </member>
        <member name="M:NModel.Execution.Location.Values">
            <summary>
            Get values of the location
            </summary>
            <returns></returns>
        </member>
        <member name="T:NModel.Execution.StateVariable">
            <summary>
            State variables are dynamic function symbols 
            that are used to form locations
            </summary>
        </member>
        <member name="M:NModel.Execution.StateVariable.FieldValues">
            <summary>
            Yields first the name and then the sort
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Execution.StateVariable.#ctor(System.String,NModel.Terms.Symbol)">
            <summary>
            Constructs a state variable with given name and sort
            </summary>
        </member>
        <member name="P:NModel.Execution.StateVariable.Name">
            <summary>
            Name of the state variable
            </summary>
        </member>
        <member name="P:NModel.Execution.StateVariable.VariableSort">
            <summary>
            Sort of the state variable
            </summary>
        </member>
        <member name="T:NModel.Execution.StateCollection">
            <summary>
            A collection is a pool of states. 
            </summary>
        </member>
        <member name="F:NModel.Execution.StateCollection.States">
            <summary>
            Implements a set of states as a dictionary that maps keys to themselves.
            </summary>
        </member>
        <member name="F:NModel.Execution.StateCollection.Fields">
            <summary>
            For all i, j in range, this.Fields[i] is the location of this.States[j].LocationValues[i]
            </summary>
        </member>
        <member name="M:NModel.Execution.StateCollection.#ctor(NModel.Execution.Location[])">
            <summary>
            
            </summary>
            <param name="fields"></param>
        </member>
        <member name="M:NModel.Execution.StateCollection.InternState(NModel.Execution.IState)">
            <summary>
            Adds a state to the state space and canonicalizes the reference
            The caller can use the returned value in place of the argument 
            for better efficiency. (It is guaranteed that arg.Equals(result) == true.)
            </summary>
            <param name="newState">The state to be added</param>
            <returns>The canonical representation of the added state</returns>
        </member>
        <member name="M:NModel.Execution.StateCollection.GetEnumerator">
            <summary>
            Enumerates all the states in this collection
            </summary>
        </member>
        <member name="T:NModel.Execution.TransitionProperties">
            <summary>
            Set of named properties used to report meta-information such as coverage and state filtering predicates.
            </summary>
            <seealso cref="M:NModel.Execution.ModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>
        </member>
        <member name="P:NModel.Execution.TransitionProperties.Properties">
            <summary>
            Map of property names to property values. Each property value consists of a 
            multiset of terms. For example, the property value might be the value of a Boolean function
            that controls state filtering. Or, it might correspond to the "coverage" of the model that 
            results from a step of a <see cref="T:NModel.Execution.ModelProgram"/>. In this case, the value might denote the 
            line numbers or blocks of the model program that were exercised in this step, or a projection of the state 
            space or a reference to section numbers of a requirements document to indicate
            that the functionality defined by that section was exercised.
            </summary>
        </member>
        <member name="M:NModel.Execution.TransitionProperties.TryGetPropertyValue(System.String,NModel.Bag{NModel.Terms.Term}@)">
            <summary>
            Retrieve a property by name
            </summary>
            <param name="propertyName">The name of the property to be retrieved</param>
            <param name="propertyValue">Output parameter that yields the value corresponding to <paramref name="propertyName"/>
            or the empty bag if not found</param>
            <returns>True if <paramref name="propertyName"/> was found; false otherwise.</returns>
        </member>
        <member name="M:NModel.Execution.TransitionProperties.#ctor">
            <summary>
            TransitionProperties constructor
            </summary>
        </member>
        <member name="M:NModel.Execution.TransitionProperties.Union(NModel.Execution.TransitionProperties)">
            <summary>
            Merges two property sets by multiset-union of corresponding entries.
            </summary>
            <param name="other">The property set to be merged</param>
            <returns>The union of this property set and <paramref name="other"/></returns>
        </member>
        <member name="M:NModel.Execution.TransitionProperties.AddProperty(System.String,NModel.Bag{NModel.Terms.Term})">
            <summary>
            Updates the properties by adding a new value. If <paramref name="propertyName"/>
            already exists, then the existing value will be merged with <paramref name="propertyValue"/>
            via multiset union.
            </summary>
            <param name="propertyName">The name of the property to be added</param>
            <param name="propertyValue">The value to be added</param>
        </member>
        <member name="T:NModel.Internals.ArrayEqualityComparer`1">
            <summary>
            Compares array elements for order and equality.
            </summary>
            <typeparam name="T">Type of elements contained by arrays to be compared.</typeparam>
        </member>
        <member name="F:NModel.Internals.ArrayEqualityComparer`1.elementComparer">
            <summary>
            Stores the comparer for individual array elements.
            </summary>
        </member>
        <member name="F:NModel.Internals.ArrayEqualityComparer`1.defaultComparer">
            <summary>
            Stores the default comparer in the same pattern as EqualityComparer.
            </summary>
        </member>
        <member name="P:NModel.Internals.ArrayEqualityComparer`1.Default">
            <summary>
            Returns a default equality comparer for arrays with the element type specified by the generic argument. 
            </summary>
        </member>
        <member name="M:NModel.Internals.ArrayEqualityComparer`1.#ctor">
            <summary>
            Instances of this class are only available through the Default property, as per the pattern of EqualityComparer.
            </summary>
        </member>
        <member name="M:NModel.Internals.ArrayEqualityComparer`1.Equals(`0[],`0[])">
            <summary>
            Determines whether the specified arrays have equal elements in the same order. 
            </summary>
            <param name="x">The first array of type <typeparamref name="T"/>[] to compare.</param>
            <param name="y">The second array of type <typeparamref name="T"/>[] to compare.</param>
            <returns><c>true</c> if the specified arrays have equal elements in the same order; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:NModel.Internals.ArrayEqualityComparer`1.GetHashCode(`0[])">
            <summary>
            Returns a hash code for the specified array. 
            </summary>
            <param name="obj">The array for which a hash code is to be returned.</param>
            <returns>A hash code for the specified array.</returns>
        </member>
        <member name="T:NModel.Internals.CachedHashCollectionValue`1">
            <summary>
            Abstract implementation helper. Use <see cref="T:NModel.Internals.CollectionValue`1" /> instead.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NModel.Internals.CachedHashCollectionValue`1.Equals(System.Object)">
            <summary>
            Structural equality 
            </summary>
            <param name="obj">The value to be compared with this value.</param>
            <returns>True if structurally equal, false otherwise.</returns>
        </member>
        <member name="M:NModel.Internals.CachedHashCollectionValue`1.GetHashCode">
            <summary>
            The hash code
            </summary>
            <returns>The hash code (either from the cache or calculated)</returns>
        </member>
        <member name="M:NModel.Internals.CachedHashCollectionValue`1.CalculateHashCode">
            <summary>
            Calculates the hash code to be cached.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:NModel.Internals.CachedHashCollectionValue`1.InvalidateCache">
            <summary>
            Required to be invoked when any internal state could invalidate the cached hash code.
            </summary>
        </member>
        <member name="T:NModel.Internals.CollectionValue">
            <summary>
            A helper class. See <see cref="T:NModel.Internals.CollectionValue`1"/>.
            </summary>
        </member>
        <member name="T:NModel.Internals.CollectionValue`1">
            <summary>
            Immutable collection of elements with structural equality. Value collections include
            sets, maps, mags (multisets) and sequences.
            </summary>
            <typeparam name="T">The type of element contained</typeparam>
            <remarks>   
            Value collections are parameterized by type T. Formally, we interpret a value collection
            as the pair (T, collection) where T is the type and collection is an untyped collection 
            (such as a set or a map). This has implications for reasoning about such types-- in particular,
            if <c>a = new Set&lt;int&gt;()</c> and <c>b = new Set&lt;string&gt;()</c> then <c>a != b</c>. To understand this, we can see that
             
                          <c>(typeof(int), {}) != (typeof(string), {})</c>
             </remarks>
        </member>
        <member name="P:NModel.Internals.CollectionValue`1.Count">
            <summary>
            Returns the number of elements in the collection value.
            </summary>
        </member>
        <member name="P:NModel.Internals.CollectionValue`1.IsEmpty">
            <summary>
            Returns true if the collection value has no elements. False otherwise.
            </summary>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.Contains(`0)">
            <summary>
            Tests whether the given element is found in the collection value.
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the item is in this collection value, false otherwise.</returns>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.Choose">
            <summary>
            Selects an arbitrary value from the collection using internal choice.        
            </summary>
            <returns>An element of the collection.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the collection is empty.</exception>
            <remarks>
            This method may return different values whenever it is invoked. (This is not a pure function.)  
            The method makes changes to the state of an internal chooser. The state of the
            internal chooser is available via the property <see cref="P:NModel.Internals.HashAlgorithms.GlobalChoiceController" />.
            </remarks>
            <seealso cref="P:NModel.Internals.HashAlgorithms.GlobalChoiceController"/>
            <overloads>
            <summary>Selects an arbitrary value from the collection.</summary>
            </overloads>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.Choose(System.Int32)">
            <summary>
            Select an arbitrary value from the collection, with external choice.
            </summary>
            <param name="i">An externally chosen integer in the interval [0, this.Count).</param>
            <returns>An element of the collection.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="i"/> is outside 
            the interval [0, this.Count).</exception>
            <remarks>As a pure function, this method will always return the same value 
            for each pair of arguments (<paramref name="this"/> and <paramref name="i"/>).</remarks>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the items in the collection into an array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.Forall(System.Predicate{`0})">
            <summary>
            Universal quantification. Returns true if the predicate is true for all elements of the collection value and 
            false otherwise.
            </summary>
            <param name="predicate">Boolean-valued delegate to be applied to each value</param>
            <returns>True, if the predicate is true for all elements of the collection value, false otherwise </returns>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.Exists(System.Predicate{`0})">
            <summary>
            Existential quantification. Returns true if the predicate is true for at least one element of the collection value.
            </summary>
            <param name="predicate">Boolean-valued delegate to be applied to each value</param>
            <returns>True, if the predicate is true for at least one of elements of the collection value, false otherwise</returns>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.ExistsOne(System.Predicate{`0})">
            <summary>
            Unique quantification. Returns true if the predicate is true for exactly one element 
            of the collection, false otherwise.
            </summary>
            <param name="predicate">Boolean-valued delegate to be applied to each value</param>
            <returns>True, if the predicate is true for at exactly one of elements 
            of the collection value, false otherwise</returns>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.Minimum">
            <summary>
            Returns the least value in the collection under the term ordering 
            defined by <see cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />.
            </summary>
            <returns>The minimal element</returns>
            <exception cref="T:System.ArgumentException">Thrown if the collection is empty.</exception>
            <seealso cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.Maximum">
            <summary>
            Returns the least value in the collection under the term ordering 
            defined by <see cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />.
            </summary>
            <returns>The minimal element</returns>
            <exception cref="T:System.ArgumentException">Thrown if the collection is empty.</exception>
            <seealso cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.Reduce``1(NModel.Reducer{`0,``0},``0)">
            <summary>
            Iteratively applies a reducing function to map a collection value to a single summarized value.
            </summary>
            <typeparam name="S">The type of the result; also, the return type of the reducer function.</typeparam>
            <param name="r">The reducer function to be iteratively applied</param>
            <param name="initialValue">The value passed on the first iteration of the reducing function</param>
            <returns>The value returned by the last iteration of the reducing function.</returns>
            <seealso cref="T:NModel.Reducer`2" />
            <example>
            This example uses Reduce to calculate the sum of all elements in a set of integers. 
            <code>
            void SetReduceExample()
            {
               Set&lt;int&gt; set1 = new Set&lt;string&gt;(1, 2, 3, 4, 5);
               int expected = 15;
               int actual = set1.Reduce(delegate(int i, int sum) { return i + sum; }, 0);
               
               Assert.AreEqual(expected, actual);
            }
            </code>
            </example>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.FieldValues">
            <summary>
            Returns an enumeration of the field values of collection
            </summary>
            <returns>An enumeration of the field values of this compound value</returns>
            <remarks>
            This is a pure function and has the further requirement that
            its value must always be the same regardless of the context in which it is invoked. 
            In other words, no state update may change the values returned by this
            enumeration.
            
            This is provided to make equality testing and hashing efficient. The values returned
            may be encodings of the internal data structures used to implement the collection
            value; other accessors such as <see cref="M:NModel.Internals.CollectionValue`1.GetEnumerator" /> provide enumeration
            capabilities for general use.
            </remarks>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.GetEnumerator">
            <summary>
            Enumerates each value of the collection.
            </summary>
            <returns>An enumerator of values in the collection. </returns>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerates each value of the collection.
            </summary>
            <returns>An enumerator of values in the collection. </returns>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.CompareTo(System.Object)">
            <summary>
            Term order. Comparision is based on type and recursively on fields.
            </summary>
            <param name="obj">The object to be compared with this collection</param>
            <returns>-1 if less than, 0 if equal, 1 if greater than</returns>
            <remarks>Collections are ordered by size. If equal size, then they are 
            ordered by pairwise comparison.</remarks>
        </member>
        <member name="M:NModel.Internals.CollectionValue`1.AsArray">
            <summary>
            Represents this collection as a .NET array
            </summary>
        </member>
        <member name="T:NModel.Internals.ICollectionValue`1">
            <summary>
            Collection of elements with no update operations provided. Similiar to ICollection,
            but without the update operations.
            </summary>
            <typeparam name="T">The type of the element contained</typeparam>
        </member>
        <member name="P:NModel.Internals.ICollectionValue`1.Count">
            <summary>
            Returns the number of elements in the collection value.
            </summary>
        </member>
        <member name="P:NModel.Internals.ICollectionValue`1.IsEmpty">
            <summary>
            Returns true if the collection value has no elements. False otherwise.
            </summary>
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.Contains(`0)">
            <summary>
            Tests whether the given element is found in the collection value.
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the <paramref name="item"/> is in this collection value, 
            false otherwise.</returns>
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.Choose">
            <summary>
            Selects an arbitrary value from the collection using internal choice.        
            </summary>
            <returns>An element of the collection.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the collection is empty.</exception>
            <remarks>
            This method may return different values whenever it is invoked. (This is not 
            a pure function.)  
            The method makes changes to the state of an internal chooser. The state of the
            internal chooser is available via the property <see cref="P:NModel.Internals.HashAlgorithms.GlobalChoiceController" />.
            </remarks>
            <seealso cref="P:NModel.Internals.HashAlgorithms.GlobalChoiceController"/>
            <overloads>
            <summary>Selects an arbitrary value from the collection.</summary>
            </overloads>
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.Choose(System.Int32)">
            <summary>
            Select an arbitrary value from the collection, with external choice.
            </summary>
            <param name="i">An arbitrary integer in the interval [0, this.Count).</param>
            <returns>An element of the collection.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="i"/> is outside 
            the interval [0, this.Count).</exception>
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all the items in the collection into an array.
            </summary>
            <param name="array">Array to copy to.</param>
            <param name="arrayIndex">Starting index in <paramref name="array"/> to copy to.</param>
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.Forall(System.Predicate{`0})">
            <summary>
            Universal quantification. Returns true if the predicate is true for all elements of the 
            collection value and 
            false otherwise.
            </summary>
            <param name="predicate">Boolean-valued delegate to be applied to each value</param>
            <returns>True, if the predicate is true for all elements of the collection value, 
            false otherwise </returns>
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.Exists(System.Predicate{`0})">
            <summary>
            Existential quantification. Returns true if the predicate is true for at least one 
            element of the collection value.
            </summary>
            <param name="predicate">Boolean-valued delegate to be applied to each value</param>
            <returns>True, if the predicate is true for at least one of elements of the collection 
            value, false otherwise</returns>
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.ExistsOne(System.Predicate{`0})">
            <summary>
            Unique quantification. Returns true if the predicate is true for exactly one element 
            of the collection, false otherwise.
            </summary>
            <param name="predicate">Boolean-valued delegate to be applied to each value</param>
            <returns>True, if the predicate is true for at exactly one of elements 
            of the collection value, false otherwise</returns>
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.Minimum">
            <summary>
            Returns the least value in the collection under the term ordering 
            defined by <see cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />.
            </summary>
            <returns>The minimal element</returns>
            <exception cref="T:System.ArgumentException">Thrown if the collection is empty.</exception>
            <seealso cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.Maximum">
            <summary>
            Returns the least value in the collection under the term ordering 
            defined by <see cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />.
            </summary>
            <returns>The minimal element</returns>
            <exception cref="T:System.ArgumentException">Thrown if the collection is empty.</exception>
            <seealso cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.Reduce``1(NModel.Reducer{`0,``0},``0)">
            <summary>
            Iteratively applies a reducing function to map a collection value to a single summarized value.
            </summary>
            <typeparam name="S">The type of the result; also, the return type of the reducer function.</typeparam>
            <param name="r">The reducer function to be iteratively applied</param>
            <param name="initialValue">The value passed on the first iteration of the reducing function</param>
            <returns>The value returned by the last iteration of the reducing function.</returns>
            <seealso cref="T:NModel.Reducer`2" />
        </member>
        <member name="M:NModel.Internals.ICollectionValue`1.AsArray">
            <summary>
            Returns this collection as a .NET array
            </summary>
        </member>
        <member name="T:NModel.Internals.ObjectId">
            <summary>
            An objectId is a compound value in the form ObjectId(sort, i) where sort is 
            a symbol giving the abstract type and i is an integer index that 
            identifies distinct values in the sort.
            </summary>
        </member>
        <member name="M:NModel.Internals.ObjectId.FieldValues">
            <summary>
            The fields of this compound value
            </summary>
            <returns>The fields</returns>
        </member>
        <member name="M:NModel.Internals.ObjectId.#ctor(NModel.Terms.Symbol,System.Int32)">
            <summary>
            Constructs an object Id
            </summary>
            <param name="sort">A symbol denoting an abstract type</param>
            <param name="id">An integer index that 
            identifies distinct values in the sort</param>
        </member>
        <member name="P:NModel.Internals.ObjectId.ObjectSort">
            <summary>
            Returns a symbol denoting an abstract type
            </summary>
        </member>
        <member name="P:NModel.Internals.ObjectId.Id">
            <summary>
            An integer index that identifies distinct values in the sort
            </summary>
        </member>
        <member name="T:NModel.Internals.LabeledInstance">
            <summary>
            Base class of model instances. Supports labeling using user-provided object ids.
            Users should not inherit this class directly; instead, when defining class T,
            inherit from LabeledInstance&lt;T&gt;.
            </summary>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.#ctor(NModel.Internals.ObjectId)">
            <summary>
            Creates a labeled instance with a given object id
            </summary>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.Initialize">
            <summary>
            Initialize the labeled instance.
            The base behavior is empty.
            </summary>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.ContainsObjectIds">
            <summary>
            Determines if this value has an object id (that is, is of type <see cref="T:NModel.Internals.LabeledInstance"/>),
            or has a subvalue that has an object id (for example, a set of instances).
            </summary>
            <returns>True if this value has an object id or contains a value with an object id.</returns>
        </member>
        <member name="P:NModel.Internals.LabeledInstance.AsTerm">
            <summary>
            Returns the term representation of this value.
            </summary>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.GetNextId(NModel.Terms.Symbol)">
            <summary>
            Increment the instance counter for this sort.
            </summary>
            <returns>The incremented count</returns>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.PeekNextId(NModel.Terms.Symbol)">
            <summary>
            Return the next available instance counter for this type and sort (without changing state).
            </summary>
            <note>This is used by parameter generation when a new instance may appear as an action argument.</note>
            <returns>The incremented count</returns>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.PeekNextLabelTerm(NModel.Terms.Symbol)">
            <summary>
            Peek at what the next term is for the given sort
            </summary>
        </member>
        <member name="P:NModel.Internals.LabeledInstance.Label">
            <summary>
            Gets the object id
            </summary>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.FinalizeImport">
            <summary>
            Called internally to distinguish between reserve elements that are part of state and 
            those in the background set of values. Not used directly in models.
            </summary>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.Equals(System.Object)">
            <summary>
            Equality of labeled instances by object id
            </summary>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.GetHashCode">
            <summary>
            Get the hashcode of the labeled instance
            </summary>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.ToString">
            <summary>
            Return the string representation of the labeled instance.
            </summary>
        </member>
        <member name="M:NModel.Internals.LabeledInstance.CompareTo(System.Object)">
            <summary>
            Compares this labeled instance to a given object (null ius the minimal element)
            Throws an ArgumentException if the argument is not null and not a labaled instance 
            </summary>
        </member>
        <member name="T:NModel.Internals.LobTree`1">
            <summary>
            Low-order bit tree (LobTree) is a binary tree with self-balancing properties for hash code keys.
            
            This implementation has a unique representation whenever the contents are equal. It uses 
            element ordering (from IComparable) to do this when hash codes coincide.
            
            Trees are immutable; insertion and deletion operations return a new tree.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:NModel.Internals.LobTree`1.EmptyTree">
            <summary>
            The empty tree
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.FieldValues">
            <summary>
            Enumerates the field values
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Base.NewFork(NModel.Internals.LobTree{`0}.Base,NModel.Internals.LobTree{`0}.Base)">
            <summary>
            Helper method used in insertion and removal.
            
            Creates the canonical branch form (despite the name, it isn't necessarily a fork).
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Empty.InsertHelper(`0,System.Int32,System.Boolean,System.Boolean@,System.Int32)">
            <summary>
            Case 1: Insert into empty tree.
            
            Return single node containing element to be added.
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Empty.TryGetValue(`0,System.Int32,System.Int32,`0@)">
            <summary>
            Case 1: Empty tree
            
            No op, returns false;
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Empty.Remove(`0,System.Int32,System.Int32,System.Boolean@)">
            Case 1: Empty tree
            
            No op, returns false;
        </member>
        <member name="M:NModel.Internals.LobTree`1.Fork.InsertHelper(`0,System.Int32,System.Boolean,System.Boolean@,System.Int32)">
            <summary>
            Case 2: Insert into branch point
            
            Insert left or right depending on the hash bit at offset "depth".
            If no change, return this branch. Otherwise, construct a new tree with the results.
            Note: the NewFork method creates the canonical form (despite the name, it isn't necessarily a fork).
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Fork.TryGetValue(`0,System.Int32,System.Int32,`0@)">
            <summary>
            Case 2: Branch point
            
            Search left or right depending on the hash bit at offset "depth".
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Fork.Remove(`0,System.Int32,System.Int32,System.Boolean@)">
            <summary>
            Case 2: Remove from branch point
            
            Remove left or right depending on the hash bit at offset "depth".
            If no change, return this branch. Otherwise, construct a new tree with the results.
            Note: the NewFork method creates the canonical form (despite the name, it isn't necessarily a fork).
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.SingleNode.InsertHelper(`0,System.Int32,System.Boolean,System.Boolean@,System.Int32)">
            <summary>
            Case 3: Insert into a tree containing a single element.
            
            Several subcases: 
                a) insert with same hash code but unequal object (returns a list node sorted in IComparable order)
                b) override existing object when "replace" is specified (returns a new single node tree)
                c) don't override existing (returns this tree)
                d) insert with different hash code (returns a new fork)
                
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.SingleNode.TryGetValue(`0,System.Int32,System.Int32,`0@)">
            <summary>
            Case 3: Tree consisting of single node
            
            If the object being looked for is contained, return true. Otherwise false.
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.SingleNode.Remove(`0,System.Int32,System.Int32,System.Boolean@)">
            <summary>
            Case 3: single node tree
            
            Returns empty tree if element to be removed matches contained element, this tree otherwise.
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.ListNode.InsertHelper(`0,System.Int32,System.Boolean,System.Boolean@,System.Int32)">
            <summary>
            Case 4: insert into list of nodes sharing the same hash code
            
            Several subcases: 
                a) insert with same hash code but unequal object (returns a list node sorted in IComparable order)
                b) override existing object when "replace" is specified (returns list node of same length as this)
                c) don't override existing (returns this tree)
                d) insert with different hash code (returns a new fork)
            </summary>
            <remarks>
            This code shares the tail memory (when insertion occurs early in the list, this saves space).
            This is probably overkill, since lists only occur on hash collisions and will tend to happen rarely
            and only contain a few elements. Consider reworking to copy lists entirely before in-place insertion
            to make testing easier.
            </remarks>
        </member>
        <member name="M:NModel.Internals.LobTree`1.ListNode.TryGetValue(`0,System.Int32,System.Int32,`0@)">
            Case 3: Tree consisting of list of nodes containing distinct elements with the same hash code
            
            If the object being looked for is contained in the list, return true. Otherwise false.
        </member>
        <member name="M:NModel.Internals.LobTree`1.ListNode.Remove(`0,System.Int32,System.Int32,System.Boolean@)">
            Case 3: list of nodes containing distinct elements sharing the same hash code
            
            Returns a copy of the list without the element to removed
        </member>
        <member name="M:NModel.Internals.LobTree`1.InvariantHolds">
            <summary>
            The invariant is a Boolean condition that is guaranteed by the implementation to hold.
            
            May be used for debugging and testing.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Insert(NModel.Internals.LobTree{`0},`0,System.Boolean,System.Boolean@)">
            <summary>
            Insert an element o 
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.TryGetValue(`0,`0@)">
            <summary>
            Looks up a value associated with a given key
            </summary>
            <param name="o">The key</param>
            <param name="valueFound">The value associated with this key (out parameter), or the default value of type T if not found</param>
            <returns>True if there a value associated with the key was found, false otherwise.</returns>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Remove(NModel.Internals.LobTree{`0},`0,System.Boolean@)">
            <summary>
            Removes an element from the tree
            </summary>
            <param name="t">The tree</param>
            <param name="o">The element</param>
            <param name="deleted">Output parameter, set to true if the element was removed by the operation, false otherwise</param>
            <returns>New tree with element removed</returns>
        </member>
        <member name="M:NModel.Internals.LobTree`1.GetEnumerator">
            <summary>
            Note: elements returned in a fixed order, since tree is ordered by hash code and IComparable comparision.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NModel.Internals.LobTree`1.Count">
            <summary>
            Returns the number of elements in the collection value.
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Contains(`0)">
            <summary>
            Tests whether the given element is found in the collection value.
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the <paramref name="item"/> is in this collection value, false otherwise.</returns>
            <remarks>
            Complexity: O(log(this.Count))
            </remarks>
        </member>
        <member name="M:NModel.Internals.LobTree`1.Convert``1(System.Converter{`0,``0})">
            <summary>
            Convert the elements to type S using the given converter
            </summary>
        </member>
        <member name="M:NModel.Internals.LobTree`1.GetOrderedHashCodes(System.Converter{`0,System.Int32})">
            <summary>
            Returns an enumeration of hash codes for each key in the tree, where each element is
            a commutative mixing (xor) of hash codes from a user-provided hash
            function applied to each node with the same key. 
            </summary>
            <param name="hashProvider">The alternative hash function to be applied to nodes with the same key</param>
            <returns></returns>
        </member>
        <member name="T:NModel.Internals.RedBlackTree`1">
            <summary>
            <para>Symmetric binary B-tree. This is a  nearly-balanced tree that uses 
            an extra bit per node to maintain balance. No leaf is more than twice as far from the 
            root as any other. An r-b tree with n internal nodes has height at most 2 * log2(n+1). 
            This implementation provides the tree as an immutable value type, in the style of functional programming.
            </para>
            <para>Insertion and lookup are O(log2(n)). The IComparable interface is used for ordering.
            </para>
            </summary>
            <typeparam name="T">The datatype of each node in the tree.</typeparam> 
        </member>
        <member name="M:NModel.Internals.RedBlackTree`1.TryGetValue(`0,`0@)">
            <summary>
            Looks up a value associated with a given key
            </summary>
            <param name="o">The key</param>
            <param name="result">The value associated with this key (out parameter), or the default value if not found</param>
            <returns>True if there a value associated with the key was found, false otherwise.</returns>
        </member>
        <member name="M:NModel.Internals.RedBlackTree`1.GetOrderedHashCodes(System.Converter{`0,System.Int32})">
            <summary>
            Returns an enumeration of hash codes for each key in the tree, where each element is
            a commutative mixing (xor) of hash codes from a user-provided hash
            function applied to each node with the same key. 
            </summary>
            <param name="hashProvider">The alternative hash function to be applied to nodes with the same key</param>
            <returns></returns>
        </member>
        <member name="M:NModel.Internals.RedBlackTree`1.GetHashCodeKeys">
            <summary>
            Returns a stream of hash codes for each element in the tree. Used for hashing. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:NModel.Internals.RedBlackTree`1.Count">
            <summary>
            Returns the number of elements in the collection value.
            </summary>
        </member>
        <member name="M:NModel.Internals.RedBlackTree`1.Contains(`0)">
            <summary>
            Tests whether the given element is found in the collection value.
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the <paramref name="item"/> is in this collection value, false otherwise.</returns>
            <remarks>
            Complexity: O(log(this.Count))
            </remarks>
        </member>
        <member name="T:NModel.Internals.TypedHash`1">
            <summary>
            <para>Produces hash values with static (type-based) and dynamic (via arguments) information encoded in the hash.
            Calculates per-type (static) hash only once per type instantiation.</para>
            
            <para>USAGE: Use this class to implement GetHashCode in new types.</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NModel.Internals.TypedHash`1.StaticTypeHash">
            <summary>
            Provides the static hash code of type parameter T
            </summary>
        </member>
        <member name="M:NModel.Internals.TypedHash`1.ComputeHash(System.Object[])">
            <summary>
            <para>Calculates the hash code of every value in the params array and combines it
            with the static hash of type parameter <c>T</c>.</para>
            </summary>
            <param name="array">The values to be hashed.</param>
            <returns>The hash value calculated.</returns>
            <example>
            In this example, the resulting hash will combine the type name <c>Foo</c> with
            the instantiated type <c>T</c> and the hash codes of <c>field1</c> and <c>field2</c>. This is 
            what is typically needed for structural equality.
            <code>
            class Foo&lt;T&gt; {                                                      
              string field1;                                                  
              T      field2;                                                 
              public override int GetHashCode()
              { 
                 return TypedHash&lt;Foo&lt;T&gt;&gt;.ComputeHash(field1, field2);
              }         
            }    
            </code>
            </example>
        </member>
        <member name="M:NModel.Internals.TypedHash`1.ComputeEnumeratedHash(System.Collections.IEnumerator)">
            <summary>
            Calculates a hash code for each element in the given collection and combines it
            with the static hash of type parameter T.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:NModel.Internals.HashAlgorithms">
            <summary>
            Contains a set of hash algorithms.
            </summary>
        </member>
        <member name="M:NModel.Internals.HashAlgorithms.GetHashCode(System.Object)">
            <summary>
            Calculates the hash code of an object, or a default hash if obj is null
            </summary>
            <param name="obj">The object, or null</param>
            <returns>Hash code of object, or a default hash if null</returns>
        </member>
        <member name="P:NModel.Internals.HashAlgorithms.GlobalChoiceController">
            <summary>
            The global choice controller used by the <see cref="M:NModel.Internals.ICollectionValue`1.Choose" /> method.
            </summary>
            <seealso cref="M:NModel.Internals.ICollectionValue`1.Choose" />
        </member>
        <member name="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)">
            <summary>
            Calculates a total ordering of terms. There are eight cases:
            <list>
                <item>The items are (pointer) equal</item>
                <item>One of the values is null; null is treated as the minimal element</item>
                <item>Both of the values are of type <see cref="T:NModel.Internals.LabeledInstance" />; comparison of labels is used</item>
                <!--<item>Both of the values are of type <see cref="EnumeratedInstance" />; comparison of labels is used</item>-->
                <item>For values of unequal types, we use dictionary order of type names</item>
                <item>For equal types, the <see cref="T:System.IComparable" /> interface is used if available.</item>
                <item>For equal types, where <c>IComparable</c>cannot be used, we check for <c>Object.Equals</c></item>
                <item>As a default, in the case where none of the preceding can be used to order values, we 
            intern the values in a global table using <see cref="M:NModel.Internals.HashAlgorithms.InternObject(System.Object)" /> and do
            comparision on the integer tokens returned from the intern operation.</item>
            </list>
            </summary>
            <param name="value1">The first value</param>
            <param name="value2">The second value</param>
            <returns>-1 if <paramref name="value1"/> is less than <paramref name="value2"/>, 0 if equal, 1 otherwise.</returns>
            <remarks>
            One of the uses of term ordering is to disambiguate distinct items with the same hash code
            within the representation of unordered data types like sets.
            </remarks>
        </member>
        <member name="M:NModel.Internals.HashAlgorithms.InternObject(System.Object)">
            <summary>
            Establishes a total ordering on objects by interning them in a global table. 
            Used for hashing and term ordering. 
            </summary>
            <param name="o">The object to intern</param>
            <returns>An integer representing the value id.</returns>
            <seealso cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)"/>
        </member>
        <member name="M:NModel.Internals.HashAlgorithms.UninternObject(System.Object)">
            <summary>
            Frees memory used to order objects interned via the 
            <seeref cref="M:NModel.Internals.HashAlgorithms.InternObject(System.Object)"/> method. May only be called when
            <paramref name="o"/> is no longer referenced by any data structure
            such a set or a map that might have previously used the interning
            for term ordering.
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:NModel.Internals.HashAlgorithms.ComputeEnumeratedHash(System.Int32,System.Collections.IEnumerator)">
            <summary>
            Calculates an order-dependent hash code of an enumeration of values.
            </summary>
            <remarks>
            Lookup2c hash algorithm (public domain).
            Ref. http://burtleburtle.net/bob/hash/index.html
            This is the algorithm used by the SPIN model checker for state hashing. It has the
            property that every output bit is dependent on every input bit and is considered
            to be a fast good hash.
            </remarks>
            <param name="initialValue"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Internals.HashAlgorithms.CombineHashCodes(System.Int32,System.Collections.Generic.IEnumerator{System.Int32})">
            <summary>
            Calculates an order-dependent combination from an enumeration of hash codes.
            </summary>
            <param name="initialValue">The starting value of the hash</param>
            <param name="hashCodes">The enumerator of hash codes to be combined</param>
            <returns>The order-dependent combination of values</returns>
        </member>
        <member name="T:NModel.Internals.IAbstractValue">
            <summary>
            An abstract value can be represented by a term.
            </summary>
            <note>This interface is implemented by all classes and structures that are part of model state or
            are used as parameters to model actions. Built-in value types provided by .NET (such as <c>int</c>,
            <c>bool</c>, etc. and the .NET <c>string</c> type may also be used in model state and as arguments 
            to model action.</note>
        </member>
        <member name="P:NModel.Internals.IAbstractValue.AsTerm">
            <summary>
            Returns the term representation of this value.
            </summary>
        </member>
        <member name="M:NModel.Internals.IAbstractValue.ContainsObjectIds">
            <summary>
            Determines if this value has an object id (that is, is of type <see cref="T:NModel.Internals.LabeledInstance"/>),
            or has a subvalue that has an object id (for example, a set of instances).
            </summary>
            <returns>True if this value has an object id or contains a value with an object id.</returns>
        </member>
        <member name="M:NModel.Internals.IAbstractValue.FinalizeImport">
            <summary>
            Called internally to distinguish between reserve elements that are part of state and 
            those in the background set of values. Not used directly in models.
            </summary>
        </member>
        <member name="T:NModel.Internals.AbstractValue">
            <summary>
            Base class for functionality shared by <see cref="T:NModel.CompoundValue"/> and <see cref="T:NModel.Internals.LabeledInstance"/>.
            This class also contains static methods for converting from .NET values to terms.
            Terms may be converted back to .NET values using <see cref="M:NModel.Internals.InterpretationContext.InterpretTerm(NModel.Terms.Term)"/>.
            </summary>
        </member>
        <member name="F:NModel.Internals.AbstractValue.typeSorts">
            <summary>
            Cache of type -> sort mapping. Sorts are the abstract types used to connect model programs.
            </summary>
        </member>
        <member name="M:NModel.Internals.AbstractValue.IsAbstractValue(System.Object)">
            <summary>
            Predicate that can be used to test whether a value can be used
            as part of model state or as a parameter value in a model action. 
            </summary>
            <param name="value">The value to be tested.</param>
            <returns>True if the value is one of the .NET built-in value types (int, bool), 
            a string, an enum value or is a value of a type that provides the <c>IAbstractValue</c>
            interface. False otherwise.</returns>
        </member>
        <member name="M:NModel.Internals.AbstractValue.IsAbstractValueType(System.Type)">
            <summary>
            Predicate that can be used to test whether a value of type <paramref name="t"/> can be used
            as part of model state or as a parameter value in a model action. 
            </summary>
            <param name="t">The type to be tested</param>
            <returns>True if <paramref name="t"/> is one of the .NET built-in value types (int, bool, etc.), 
            the string type, an enum or a type that provides the <c>IAbstractValue</c>
            interface. False otherwise.</returns>
        </member>
        <member name="M:NModel.Internals.AbstractValue.IsTypeAbstractSort(System.Type)">
            <summary>
            Checks whether a type represents abstract objects in the model program.
            There are currently two ways to make a type to represent abstract objects:
            <list type="">
            <item>Make a type derive from <see cref="T:NModel.Internals.LabeledInstance"/>;</item>
            <item>Attribute a <see cref="T:NModel.CompoundValue"/> or an enumeration with [Abstract] attribute.</item>
            </list>
            </summary>
            <param name="t">The type</param>
            <returns>true if the type represents abstract objects in the model program.</returns>
        </member>
        <member name="P:NModel.Internals.AbstractValue.Sort">
            <summary>
            Returns the sort (abstract type) of this value
            </summary>
        </member>
        <member name="M:NModel.Internals.AbstractValue.GetTerm(System.IComparable)">
            <summary>
            Produces the term representation for <paramref name="value"/>. See <see cref="T:NModel.Terms.Term"/>.
            </summary>
            <param name="value">The value to be represented as a term, either a .NET built-in structure type
            or a type that implements <see cref="T:NModel.Internals.IAbstractValue"/>.</param>
            <returns>The term that represents <paramref name="value"/></returns>
        </member>
        <member name="M:NModel.Internals.AbstractValue.InterpretTerm(NModel.Terms.Term)">
            <summary>
            Returns the interpretation of the term <paramref name="t"/> in the current context.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Internals.AbstractValue.TypeSort(System.Type)">
            <summary>
            For a given type, returns the associated sort (abstract type). This is calculated 
            by using the value of the "Sort" attribute, or by constructing a symbol from
            the type name if the attribute is not present. See <see cref="T:NModel.Attributes.SortAttribute"/>.
            </summary>
            <param name="t">The type</param>
            <returns>The associated sort</returns>
        </member>
        <member name="M:NModel.Internals.AbstractValue.GetLiteralTypes">
            <summary>
            Returns a dictionary of .NET types that can be converted into literal terms (see <see cref="T:NModel.Terms.Literal"/>).
            The key of the dictionary is the type, the values are the names of the associated sorts.
            </summary>
            <returns>The dictionary of sorts</returns>
        </member>
        <member name="M:NModel.Internals.AbstractValue.IsLiteralSort(NModel.Terms.Symbol)">
            <summary>
            Does the sort denote a literal type? See <see cref="M:NModel.Internals.AbstractValue.GetLiteralTypes"/>.
            </summary>
            <param name="sort">The sort</param>
            <returns>True if the sort denotes a literal type. False otherwise.</returns>
        </member>
        <member name="M:NModel.Internals.AbstractValue.GetLiteralSortType(NModel.Terms.Symbol)">
            <summary>
            Returns the .NET type for <paramref name="sort"/>. 
            </summary>
            <param name="sort">The sort. </param>
            <returns>The associated type.</returns>
        </member>
        <member name="M:NModel.Internals.AbstractValue.FinalizeImport(System.IComparable)">
            <summary>
            Called internally to bring a background element into the current state
            </summary>
            <param name="obj">The element in import</param>
        </member>
        <member name="M:NModel.Internals.AbstractValue.ContainsObjectIds(System.IComparable)">
            <summary>
            Determines if this value has an object id (that is, is of type <see cref="T:NModel.Internals.LabeledInstance"/>),
            or has a subvalue that has an object id (for example, a set of instances).
            </summary>
            <returns>True if this value has an object id or contains a value with an object id.</returns>
            <remarks> This method is invoked by the modeling library when determining whether two states are isomorphic.
            </remarks>
        </member>
        <member name="P:NModel.Internals.AbstractValue.AsTerm">
            <summary>
            Returns the term representation of this value.
            </summary>
        </member>
        <member name="M:NModel.Internals.AbstractValue.ContainsObjectIds">
            <summary>
            Determines if this value has an object id (that is, is of type <see cref="T:NModel.Internals.LabeledInstance"/>),
            or has a subvalue that has an object id (for example, a set of instances).
            </summary>
            <returns>True if this value has an object id or contains a value with an object id.</returns>
        </member>
        <member name="M:NModel.Internals.AbstractValue.FinalizeImport">
            <summary>
            Called internally to distinguish between reserve elements that are part of state and 
            those in the background set of values. Not used directly in models.
            </summary>
        </member>
        <member name="M:NModel.Internals.AbstractValue.CompareTo(System.Object)">
            <exclude />
        </member>
        <member name="M:NModel.Internals.AbstractValue.Equals(System.Object)">
            <exclude />
        </member>
        <member name="M:NModel.Internals.AbstractValue.GetHashCode">
            <exclude />
        </member>
        <member name="M:NModel.Internals.AbstractValue.op_Equality(NModel.Internals.AbstractValue,NModel.Internals.AbstractValue)">
            <summary>
            The operator == for abstract values is the same as Object.Equals
            </summary>
        </member>
        <member name="M:NModel.Internals.AbstractValue.op_Inequality(NModel.Internals.AbstractValue,NModel.Internals.AbstractValue)">
            <summary>
            The operator != for abstract values is the same as !Object.Equals
            </summary>
        </member>
        <member name="M:NModel.Internals.AbstractValue.op_LessThan(NModel.Internals.AbstractValue,NModel.Internals.AbstractValue)">
            <summary>
            o1 is less than o2 iff either o1 is null and o2 is not null or else o1.CompareTo(o2) == -1
            </summary>
        </member>
        <member name="M:NModel.Internals.AbstractValue.op_GreaterThan(NModel.Internals.AbstractValue,NModel.Internals.AbstractValue)">
            <summary>
            o1 is greater than o2 iff o2 is less than o1 
            </summary>
        </member>
        <member name="M:NModel.Internals.AbstractValue.op_LessThanOrEqual(NModel.Internals.AbstractValue,NModel.Internals.AbstractValue)">
            <summary>
            o1 is less than or equal to o2 if o1.CompareTo(o2) is less than 1
            </summary>
        </member>
        <member name="M:NModel.Internals.AbstractValue.op_GreaterThanOrEqual(NModel.Internals.AbstractValue,NModel.Internals.AbstractValue)">
            <summary>
            o1 is greater than or equal to o2 if o2 is less than or equal to o1
            </summary>
        </member>
        <member name="T:NModel.Internals.RootedLabeledDirectedGraph">
            <summary>
            Rooted labeled directed graph is a data structure that is used
            as an alternative representation of state.
            </summary>
        </member>
        <member name="F:NModel.Internals.RootedLabeledDirectedGraph.root">
            <summary>
            Root vertex.
            </summary>
        </member>
        <member name="F:NModel.Internals.RootedLabeledDirectedGraph.vertexRecords">
            <summary>
            Vertex records that contain data the label and structures of functional and relational
            outgoing edges and incoming edges.
            </summary>
        </member>
        <member name="F:NModel.Internals.RootedLabeledDirectedGraph.nextId">
            <summary>
            Next ID.
            </summary>
        </member>
        <member name="F:NModel.Internals.RootedLabeledDirectedGraph.hashCode">
            <summary>
            Hash code of the graph
            </summary>
        </member>
        <member name="M:NModel.Internals.RootedLabeledDirectedGraph.#ctor(System.Int32,System.Collections.Generic.Dictionary{System.Int32,NModel.Internals.VertexData})">
            <summary>
            Constructor of the rooted labeled directed graph.
            </summary>
            <param name="root">Root vertex</param>
            <param name="vertexRecords">Dictionary of vertex records</param>
        </member>
        <member name="M:NModel.Internals.RootedLabeledDirectedGraph.EnsureVertex(System.Int32)">
            <summary>
            Make sure that a vertexData record has been initialized for the vertex.
            </summary>
            <param name="vertex"></param>
            <returns>VertexData record corresponding to the argument.</returns>
        </member>
        <member name="M:NModel.Internals.RootedLabeledDirectedGraph.LabelOf(System.Int32)">
            <summary>
            Returns the label of the vertex v.
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Internals.RootedLabeledDirectedGraph.CompareTo(System.Object)">
            <summary>
            This method throws a NotImplementedException.
            (This method is never called in NModel and should not be called.
            Graphs are stored in sets, thus the method is needed for IComparable.)
            </summary>
        </member>
        <member name="T:NModel.Internals.VertexData">
            <summary>
            Vertex data records containing vertex label, functional outgoing edges, relational outgoing edges and incoming
            edges of the vertex.
            </summary>
        </member>
        <member name="F:NModel.Internals.VertexData.vertex">
            <summary>
            The vertex.
            </summary>
        </member>
        <member name="F:NModel.Internals.VertexData.label">
            <summary>
            Vertex label. 
            </summary>
        </member>
        <member name="F:NModel.Internals.VertexData.orderedOutgoingEdges">
            <summary>
            Functional outgoing edges.
            </summary>
        </member>
        <member name="F:NModel.Internals.VertexData.unorderedOutgoingEdges">
            <summary>
            Relational outgoing edges.
            </summary>
        </member>
        <member name="F:NModel.Internals.VertexData.incomingEdges">
            <summary>
            Incoming edges.
            </summary>
        </member>
        <member name="M:NModel.Internals.VertexData.#ctor">
            <summary>
            Constructor that initialises the data structure.
            </summary>
        </member>
        <member name="M:NModel.Internals.VertexData.#ctor(System.Int32,NModel.Set{NModel.Pair{NModel.Terms.CompoundTerm,System.IComparable}},NModel.Map{NModel.Terms.CompoundTerm,System.Int32},NModel.Map{NModel.Terms.CompoundTerm,NModel.Set{System.Int32}})">
            <summary>
            Constructor that initializes the record with previously initialized data structures.
            </summary>
            <param name="vertex"></param>
            <param name="label"></param>
            <param name="orderedOutgoingEdges"></param>
            <param name="unorderedOutgoingEdges"></param>
        </member>
        <member name="T:NModel.Internals.InterpretationContext">
            <summary>
            Runtime context needed to interpret Terms as .NET objects and to pretty print .NET objects as Terms.
            See <see cref="M:NModel.Internals.InterpretationContext.SetAsActive"/>.
            </summary>
        </member>
        <member name="F:NModel.Internals.InterpretationContext.features">
            <summary>
            Set of feature keywords that apply in this context.
            </summary>
        </member>
        <member name="F:NModel.Internals.InterpretationContext.idPool">
            <summary>
            Per-sort dictionary of instance counters. The range denotes
            the highest id value used so far for a given sort.
            The idPool is considered part of model state. It is an 
            error if any location of model state contains a value with
            object id <i>x</i> such that idPool[<i>x</i>.Sort] &lt; <i>x</i>.Id
            </summary>
        </member>
        <member name="F:NModel.Internals.InterpretationContext.pool">
            <summary>
            Object pool for a model program. This is a cache for optimization. It allows
            model program implementations to reuse instances across states. This means that 
            structures may be cached from state to state.
            </summary>
        </member>
        <member name="F:NModel.Internals.InterpretationContext.sortType">
            <summary>
            A mapping of sorts (abstract types used to connect model programs) and the .NET types 
            that implement them in the current context. This is part of runtime context because 
            two model programs may choose different .NET types for the same sort. This dictionary is 
            used when interpreting a term representation as a runtime value.
            </summary>
        </member>
        <member name="F:NModel.Internals.InterpretationContext.termValues">
            <summary>
            Cache of terms and their interpretations in this context. Note that interpretations are fixed.
            </summary>
        </member>
        <member name="F:NModel.Internals.InterpretationContext.choiceOracle">
            <summary>
            Sequence of recorded choices used when reexecuting to a given state.
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.#ctor">
            <summary>
            Runtime context needed to interpret Terms as .NET objects and to pretty print .NET objects as Terms.
            Model programs will typically contain one instance of this class.
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.#ctor(NModel.Set{System.String})">
            <summary>
            Runtime context needed to interpret Terms as .NET objects and to pretty print .NET objects as Terms.
            Model programs will typically contain one instance of this class.
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.Clear">
            <summary>
            Cleanup function to free memory prior to disposal of context object.
            </summary>
        </member>
        <member name="P:NModel.Internals.InterpretationContext.Features">
            <summary>
            Set of feature keywords that apply in this context.
            </summary>
        </member>
        <member name="P:NModel.Internals.InterpretationContext.IdPool">
            <summary>
            Object pool for a model program. This is a cache for optimization. It allows
            model program implementations to reuse instances across states. This means that 
            structures may be cached from state to state.
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.EnsureId(NModel.Internals.ObjectId)">
            <summary>
            Modifies the current context to ensure that the next object id for <paramref name="label.ObjectSort.ObjectSort"/> 
            will be greater than <paramref name="label.Id.Id"/>. This method modifies the current
            model state. Unlike <see cref="M:NModel.Internals.InterpretationContext.ResetId(NModel.Terms.Symbol,System.Int32)"/>, this method is incapable of reducing the
            value of the next object id. It can only increase it or leave it unchanged.
            </summary>
            <param name="label">The an object of type <see cref="T:NModel.Internals.ObjectId"/> containing the sort (abstract type) and the id of the element to be included</param>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.ResetId(NModel.Terms.Symbol,System.Int32)">
            <summary>
            Modifies the current context so that the next object id for <paramref name="sort"/>
            is equal <paramref name="maxIdValue"/> plus 1. This method modifies the current
            model state.
            </summary>
            <param name="sort">The sort (abstract type) to modify</param>
            <param name="maxIdValue">The id of the maximum element</param>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.SortTypeTryGetValue(NModel.Terms.Symbol,System.Type@)">
            <summary>
            Accesses the mapping of sorts (abstract types used to connect model programs) and the .NET types 
            that implement them in the current context. This is part of runtime context because 
            two model programs may choose different .NET types for the same sort. This mapping is 
            used when interpreting a term representation as a runtime value.
            </summary> 
            <param name="sort">The sort to lookup</param>
            <param name="t">The associated type, if found</param>
            <returns>True if the an association of sort-to-type was found. See also <see cref="M:NModel.Internals.InterpretationContext.RegisterSortType(NModel.Terms.Symbol,System.Type)"/>.</returns>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.DefaultSortType(NModel.Terms.Symbol)">
            <summary>
            Get the default type of the sort
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.getSortTypeFromAppDomainAssemblies(System.String[],System.String)">
            <summary>
            Check for the type in the AppDomain assemblies - 
            Is it a type of another model program that is being composed with this one
            Exclude from checking all the namespaces that have been checked already
            </summary>
            <param name="excludeNameSpaces"></param>
            <param name="sortTypeName"></param>
            <returns>Type - the type of the given sort, or null if a matching type was not found</returns>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.RegisterSortType(NModel.Terms.Symbol,System.Type)">
            <summary>
            Initializes this context with a (sort, type) pair.
            </summary>
            <param name="sort">The sort associated with <paramref name="t"/></param>
            <param name="t">The .NET type associated with <paramref name="sort"/></param>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.InstancePoolTryGetValue(NModel.Internals.ObjectId,NModel.Internals.LabeledInstance@)">
            <summary>
            Accesses this context's object pool. The object pool is a cache for optimization. It allows
            model program implementations to reuse instances across states. This means that 
            structures may be cached from state to state.
            </summary>
            <param name="label">The object id to look up</param>
            <param name="value">The associated instance, if found</param>
            <returns>True if the object id has a value in the pool; false otherwise</returns>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.InstancePoolValues(NModel.Terms.Symbol)">
            <summary>
            Returns all of the objects of this instance pool that are relevant in the current context
            </summary>
            <param name="sort"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.RegisterValue(NModel.Internals.LabeledInstance)">
            <summary>
            Inserts a new value in this context's object pool. See <see cref="M:NModel.Internals.InterpretationContext.InstancePoolTryGetValue(NModel.Internals.ObjectId,NModel.Internals.LabeledInstance@)"/>.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.ResetPoolFields">
            <summary>
            Reset the pool fields
            </summary>
        </member>
        <member name="F:NModel.Internals.InterpretationContext.currentContext">
            <summary>
            The current context. This is used when creating LabeledInstance objects to assign labels.
            </summary>
        </member>
        <member name="F:NModel.Internals.InterpretationContext.contextStack">
            <summary>
            Previous contexts, as a stack. Contexts are pushed and popped.
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.SetAsActive">
            <summary>
            Pushes this context as the active context for LabeledInstance creation. Must be paired with a 
            <see cref="M:NModel.Internals.InterpretationContext.ClearAsActive"/> call.
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.AddCoveragePoint(NModel.Terms.Term)">
            <summary>
            Adds a new coverage point to the current context. 
            </summary>
            <param name="coveragePoint">Term denoting a coverage point.</param>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.GetCoveragePoints">
            <summary>
            Returns the coverage points encountered in the current context since the last
            set or clear context operation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.ClearAsActive">
            <summary>
            Pops this context. Must have been preceded by a <see cref="M:NModel.Internals.InterpretationContext.SetAsActive"/> call.
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.GetCurrentContext">
            <summary>
            Returns the last interpretation context pushed by a <see cref="M:NModel.Internals.InterpretationContext.SetAsActive"/> call.
            </summary>
            <returns>The current context</returns>
        </member>
        <member name="T:NModel.Internals.InterpretationContext.ValueConstructor">
            <summary>
            Delegate for a value contructor
            </summary>
        </member>
        <member name="F:NModel.Internals.InterpretationContext.valueConstructors">
            <summary>
            Cached constructor functions (to avoid metadata lookup overhead on a per-call basis)
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.AddValueConstructor(NModel.Terms.Symbol,NModel.Internals.InterpretationContext.ValueConstructor)">
            <summary>
            Add a value constructor for the given sort
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.InterpretTerm(NModel.Terms.Term)">
            <summary>
            Interpret the term as a .NET value in this context
            </summary>
        </member>
        <member name="M:NModel.Internals.InterpretationContext.Choose(NModel.Set{NModel.Terms.CompoundTerm})">
            <summary>
            Choose a term from the given set
            </summary>
        </member>
        <member name="T:NModel.Internals.ChoiceException">
            <summary>
            Exception that is thrown when no choice is possible
            </summary>
        </member>
        <member name="M:NModel.Internals.ChoiceException.#ctor(NModel.Set{NModel.Terms.CompoundTerm})">
            <summary>
            Constructs a ChoiceException for a given set of choices
            </summary>
        </member>
        <member name="M:NModel.Internals.ChoiceException.#ctor(System.String)">
            <summary>
            Constructs a ChoiceException for a given message
            </summary>
        </member>
        <member name="M:NModel.Internals.ChoiceException.#ctor(System.String,System.Exception)">
            <summary>
            Constructs a ChoiceException for a given message and inner exception
            </summary>
        </member>
        <member name="M:NModel.Internals.ChoiceException.#ctor">
            <summary>
            Constructs a ChoiceException
            </summary>
        </member>
        <member name="M:NModel.Internals.ChoiceException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructs a ChoiceException
            </summary>
        </member>
        <member name="M:NModel.Internals.ChoiceException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Get object data for the choice exception
            </summary>
        </member>
        <member name="T:NModel.Internals.StateContainer`1">
            <summary>
            A type for containing IStates during exploration. Has support for
            state isomorphism checking.
            </summary>    
            <typeparam name="T">The sort of element that implements <see cref="T:NModel.Execution.IState"/>.</typeparam>    
        </member>
        <member name="M:NModel.Internals.StateContainer`1.#ctor(NModel.Execution.ModelProgram,`0[])">
            <summary>
            A constructor that creates and initializes a state container. ModelProgram is used for extracting
            abstractObjectIds and storing them internally.
            </summary>
            <param name="mp">The relevant model program. Currently a <see cref="T:NModel.Execution.LibraryModelProgram"/> is assumed.</param>
            <param name="elements">States to be added to the container upon creation</param>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.Remove(`0)">
            <summary>
            Removes an element from the container. Note that this member is mutable.
            </summary>
            <param name="value">The value to be deleted.</param>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.Add(`0)">
            <summary>
            Adds an element to the container.
            </summary>
            <param name="value">The value to add</param>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.Contains(`0)">
            <summary>
            Check if an element is contained in the container.
            </summary>
            <param name="value">A state</param>
            <returns>True if the state is in the container</returns>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.getAbstractOidIdentifier(NModel.Terms.Symbol,NModel.Terms.Literal,System.Collections.Generic.Dictionary{NModel.Terms.Symbol,System.Collections.Generic.Dictionary{NModel.Terms.Literal,System.Int32}}@)">
            <summary>
            Returns an integer that corresponds to previously seen object ID or returns a fresh id and stores the object ID.
            Has the side effect of increasing objectIdCounter when a fresh ID is generated.
            </summary>
            <param name="sym">Symbol of the sort</param>
            <param name="absLiteral">The ID or item, in case of enums</param>
            <param name="absOids">reference to the data structure mapping abstract oids to graph nodes</param>
            <returns></returns>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.ExtractGraph(`0)">
            <summary>
            Extracts graph from the state. Currently supports only <see cref="T:NModel.Execution.SimpleState"/>, but adding
            <see cref="T:NModel.Execution.PairState"/> support is easy.
            </summary>
            <param name="state"></param>
            <returns>The graph corresponding to the state</returns>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.ExtractFSM(`0)">
            <summary>
            Extract a rooted labeled directed graph representation from the state
            and covert it to dot representation.
            </summary>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.computeHash(NModel.Internals.RootedLabeledDirectedGraph)">
            <summary>
            Computes hash of the graph.
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.HasIsomorphic(`0,`0@)">
            <summary>
            Method that checks whether the container already contains a state that is isomorphic to 
            value. If such a state is found it is returned in isoState.
            </summary>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.GetEnumerator">
            <summary>
            Enumerator of each element of this set. If two sets are equal, then their enumerations are in the same order.
            (This is a fixed order with no external significance.)
            </summary>
            <returns>The enumerator of this set</returns>
        </member>
        <member name="P:NModel.Internals.StateContainer`1.Count">
            <summary>
            Returns the number of states contained.
            </summary>
        </member>
        <member name="M:NModel.Internals.StateContainer`1.ToString">
            <summary>
            Pretty printer
            </summary>
            <returns>A human-readable representation of the this set.</returns>
        </member>
        <member name="T:NModel.Internals.MessageStrings">
            <summary>
            A container class for common error message strings.
            </summary>
        </member>
        <member name="F:NModel.Internals.MessageStrings.ArgMustNotBeNegative">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.ArrayTooSmall">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.ChooseInvalidArgument">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.MaximumInvalidArgument">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.MinimumInvalidArgument">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.MapAddInvalidArgument">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.MapKeyNotFound">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.MergeInvalidArgument">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.MapIntersectInvalidArgument">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.MapRemoveInvalidArgument">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.MapDifferenceInvalidArgument">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.CantTakeHeadOfEmptySequence">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.CantTakeTailOfEmptySequence">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.MapDomainErrorOnConvert">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.ComparableTypeRequired">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.LabeledInstanceRequired">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.EnumeratedInstanceRequired">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.CompoundValueRequired">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.RuntimeTypeError">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.ComparableResultRequired">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.NonEmptySequenceRequired">
            <exclude />
        </member>
        <member name="F:NModel.Internals.MessageStrings.SequenceIndexOutOfRange">
            <exclude />
        </member>
        <member name="M:NModel.Internals.MessageStrings.LocalizedFormat(System.String,System.String[])">
            <summary>
            Invokes <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">String.Format</see> using <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> as the formatting "culture."
            </summary>
            <param name="s">The format string</param>
            <param name="args">The format arguments</param>
            <returns>The formatted string</returns>
        </member>
        <member name="T:NModel.Internals.PrettyPrinter">
            <summary>
            Provides functions for formatting values in human-readable form.
            </summary>
        </member>
        <member name="M:NModel.Internals.PrettyPrinter.Format(System.Text.StringBuilder,System.Object)">
            <summary>
            Formats values in human-readble form as strings.
            </summary>
            <param name="sb">The string builder instance that contains the context for pretty printing.</param>
            <param name="obj">The object to be pretty printed.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="sb"/> is null.</exception>
        </member>
        <member name="M:NModel.Internals.PrettyPrinter.FormatTypeName(System.Text.StringBuilder,System.Type)">
            <summary>
            Formats type names in human-readable form. This removes special characters in generic type names
            and converts System.String to string, etc.
            </summary>
            <param name="sb">The string builder instance that contains the context for pretty printing.</param>
            <param name="t">The type to be pretty printed.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="sb"/> is null.</exception>
        </member>
        <member name="M:NModel.Internals.PrettyPrinter.FormatType(System.Text.StringBuilder,System.Type)">
            <summary>
            Formats type in human-readable form. Includes instantiated generic type arguments if present.
            </summary>
            <param name="sb">The string builder instance that contains the context for pretty printing.</param>
            <param name="t">The object to be pretty printed.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="sb"/> is null.</exception>
        </member>
        <member name="T:NModel.Internals.WeakCache`1">
            <summary>
            Generic object cache that weakly caches the result of a variable list of arguments.
            </summary>
            <typeparam name="T">Type of object to cache.</typeparam>
        </member>
        <member name="T:NModel.Internals.WeakCache`2">
            <summary>
            Generic object cache that caches the result of a single argument.
            </summary>
            <typeparam name="T">Type of object to cache.</typeparam>
            <typeparam name="A">Type of argument.</typeparam>
        </member>
        <member name="T:NModel.Internals.WeakCache`3">
            <summary>
            Generic object cache that caches the result of several arguments.
            </summary>
            <typeparam name="T">Type of object to cache.</typeparam>
            <typeparam name="A1">Type of first argument.</typeparam>
            <typeparam name="A2">Type of second argument.</typeparam>
        </member>
        <member name="T:NModel.Combinatorics">
            <summary>
            Static class providing functions from mathematical combinatorics.
            </summary>
        </member>
        <member name="M:NModel.Combinatorics.Factorial(System.Int32)">
            <summary>
            The factorial of <paramref name="i"/>, <paramref name="i"/>!. This is equal to the number
            of permutations without repetition of a sequence of <paramref name="i"/> elements.
            </summary>
            <param name="i">The number of elements</param>
            <returns>The number of nonrepeating permutations</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="i"/> is less than zero or greater than 12. </exception>
        </member>
        <member name="M:NModel.Combinatorics.ChoosePermutation(System.Int32,System.Int32)">
            <summary>
            Chooses an arbitrary ordering of the sequence [0, 1, ... <paramref name="n"/> - 1] using <paramref name="i"/> to choose.
            </summary>
            <param name="n">The number of elements to permute</param>
            <param name="i">The index of the permutation. If this is a nonnegative number less than 
            Factorial(<paramref name="n"/>) and <paramref name="n"/> &lt;= 12, then the permutations are enumerated. In other words,
            each of the possible permutations will correspond to exactly one integer in [0..Factorial(n)). Outside
            of that range, the permutation will be chosen using the given integer as a random seed.</param>
            <returns>An array of indices between 0 and <paramref name="n"/> in a chosen order.</returns>
        </member>
        <member name="M:NModel.Combinatorics.ChoosePermutation_1(System.Int32,System.Int32)">
            <summary>        /// Chooses an arbitrary ordering of the sequence [0, 1, ... <paramref name="n"/> - 1] using <paramref name="i"/> to choose.
            </summary>
            <param name="n">The number of elements to permute</param>
            <param name="i">The index of the permutation. This should be a nonnegative number less than 
            Factorial(<paramref name="n"/>).</param>
            <returns>An array of indices between 0 and <paramref name="n"/> in an arbitrary order.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="n"/>is out of range. The current 
            implementation allows 
            permutation of up to 16 elements.</exception>
            <exception cref="T:System.ArgumentException">Thorwn if <paramref name="i"/>is not a nonnegative integer 
            less than Factorial(<paramref name="n"/>).</exception>
        </member>
        <member name="T:NModel.Bag`1">
            <summary>
            Immutable type for an unordered collection of possibly repeating elements. This is 
            also known as a multiset.
            </summary>
            <typeparam name="T">The sort of element contained in the bag. Must be a subtype of <see cref="T:System.IComparable" />.</typeparam>
            <remarks>
            <para>For any value x, the multiplicity of x is the number of times x occurs 
            in the bag, or zero if x is not in the bag.</para>
            <para>The data type is immutable; add/remove operations return a new bag.</para>
            <para>Equality is structural. Two bags are equal if they contain the same elements with
            the same multiplicities. Order does not affect equality.</para>
            </remarks>
            <example>
            <code>
            static void BagExample()
            {
                Bag&lt;int&gt; b1 = Bag&lt;int&gt;.EmptyBag;
                Bag&lt;int&gt; b2 = new Bag&lt;int&gt;(1, 2, 1, 2, 2);
                Bag&lt;int&gt; b3 = new Bag&lt;int&gt;(3, 2, 2, 2);
                Bag&lt;int&gt; b4 = b2.Union(b3);
                Assert.IsTrue(b2.Contains(2));
                Assert.IsTrue(b2.CountItem(2) == 3);
                Assert.IsTrue(b4.CountItem(3) == 6);
            }
            </code></example>
        </member>
        <member name="M:NModel.Bag`1.#ctor">
            <summary>
            Empty bag, provided as a convenience. The static field <see cref="F:NModel.Bag`1.EmptyBag" /> is preferred
            instead of using this form of the constructor.
            </summary>
        </member>
        <member name="F:NModel.Bag`1.EmptyBag">
            <summary>
            The bag of type T that contains no elements.
            </summary>
        </member>
        <member name="M:NModel.Bag`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A bag with elements taken from a collection. The size of the bag
            is the same as the number of values in the collection.
            </summary>
            <param name="col">The values to add to the bag.</param>
        </member>
        <member name="M:NModel.Bag`1.#ctor(`0[])">
            <summary>
            A bag with elements given as a "params" argument. The size of the bag
            is the same as the number of values given as parameters.
            </summary>
            <param name="contents">The values to add to the bag.</param>
        </member>
        <member name="M:NModel.Bag`1.#ctor(System.Collections.Generic.IEnumerable{NModel.Pair{`0,System.Int32}})">
            <summary>
            A bag with elements and their corresponding multiplicities given as a pair enumeration.
            </summary>
            <param name="contents">Enumeration of key/value pairs representing elements and their corresponding multiplicities.</param>
        </member>
        <member name="M:NModel.Bag`1.#ctor(NModel.Pair{`0,System.Int32}[])">
            <summary>
            A bag with elements and their corresponding multiplicities given as a pair enumeration.
            </summary>
            <param name="contents">Params array of key/value pairs representing elements and their corresponding multiplicities.</param>       
        </member>
        <member name="M:NModel.Bag`1.#ctor(System.Int32,NModel.Map{`0,System.Int32})">
            <summary>
            Private constructor with explicit field initializations
            </summary>
        </member>
        <member name="M:NModel.Bag`1.Contains(`0)">
            <summary>
            Tests whether the given element is found in this bag.
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the <paramref name="item"/> is in this bag, false otherwise.</returns>
            <remarks>
            Complexity: O(log(this.CountUnique))
            </remarks>
        </member>
        <member name="P:NModel.Bag`1.Count">
            <summary>
            Returns the number of elements in the bag. This is sum of all multiplicities 
            of the unique elements in this bag..
            </summary>
        </member>
        <member name="M:NModel.Bag`1.Convert``1(System.Converter{`0,``0})">
             <summary>
             Converts a bag of one sort to another using a user-provided conversion function.
             </summary>
             <typeparam name="S">The sort of the resulting bag.</typeparam>
             <param name="converter">A <see cref="T:System.Converter`2" /> function that maps values of type T to values of type S.</param>
             <returns>A new bag with the number of elements as this bag.</returns>
             <example>
             This example converts a bag of strings into a bag of integers that contains the length of each string. 
             Note that order does not matter within a bag.
             <code>
             public void BagConvertExample()
             {
                Bag&lt;string&gt; bag1 = new Bag&lt;string&gt;("abc", "def", "hello", "def");
            
                Converter&lt;string, int&gt; converter = delegate(string s) { return s == null ? 0 : s.Length; };
             
                Bag&lt;int&gt; expected = new Bag&lt;int&gt;(3, 5, 3, 3);
                Bag&lt;int&gt; actual = bag1.Convert(converter);
             
                Assert.AreEqual(expected, actual);
             }
             </code>
             </example>
        </member>
        <member name="M:NModel.Bag`1.Select(System.Predicate{`0})">
            <summary>
            Applies <paramref name="selector"/> to each element of this bag and collects all values where 
            the selector function returns true.
            </summary>
            <param name="selector">A Boolean-valued delegate that acts as the inclusion test. True means
            include; false means exclude.</param>
            <returns>The bag of all elements of this bag that satisfy the <paramref name="selector"/>. Multiplicity
            of selected elements is preserved.</returns>
        </member>
        <member name="M:NModel.Bag`1.Choose(System.Int32)">
            <summary>
            Select an arbitrary value from the bag, with external choice.
            </summary>
            <param name="i">An externally chosen integer in the interval [0, this.Count).</param>
            <returns>An element of the bag.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="i"/> is outside 
            the interval [0, this.Count).</exception>
            <remarks>As a pure function, this method will always return the same value 
            for each pair of arguments (<paramref name="this"/> and <paramref name="i"/>).</remarks>
        </member>
        <member name="M:NModel.Bag`1.CountItem(`0)">
            <summary>
            Returns the number of times <paramref name="x"/> appears in this bag.
            </summary>
            <param name="x">The element to find</param>
            <returns>The number of occurrences of <paramref name="x"/>, or <c>0</c> 
            if <paramref name="x"/> is not in this bag.</returns>
        </member>
        <member name="P:NModel.Bag`1.CountUnique">
            <summary>
            Returns the number of unique elements in this bag. (Note: This is less than
            the number of elements given by Count if some elements appear more than once 
            in the bag.)
            </summary>
        </member>
        <member name="P:NModel.Bag`1.Keys">
            <summary>
            Returns a set of all elements with multiplicity greater than zero
            </summary>
        </member>
        <member name="M:NModel.Bag`1.Add(`0)">
            <summary>
            Creates a new bag that is the same as this bag except that the multiplicity of x is one larger
            </summary>
            <param name="x">The item to add</param>
            <returns>A new bag with all the elements of this bag plus the item given as an argument.</returns>
            <remarks>Note that the Add operation returns a new bag. Bag is an immutable type.</remarks>
        </member>
        <member name="M:NModel.Bag`1.AddMultiple(`0,System.Int32)">
            <summary>
            Creates a new bag that is the same as this bag, except that
            the multiplicity of x is n larger (or smaller if n is less than zero).
            </summary>
            <param name="x"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Bag`1.Remove(`0)">
            <summary>
            Creates a new bag with the same elements as this bag, except that the multiplicity of x
            is decremented by one if nonzero
            </summary>
            <param name="x">The value to be removed</param>
            <returns></returns>
        </member>
        <member name="M:NModel.Bag`1.RemoveAll(`0)">
            <summary>
            Creates a new bag with the same elements as this bag, except that all occurrences of x are omitted.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Bag`1.AddInternal(System.Int32,NModel.Map{`0,System.Int32},`0,System.Int32,System.Int32@,NModel.Map{`0,System.Int32}@)">
            <summary>
            Calculates a new representations with where multiplicity of x is incremented by n
            (n can be negative to remove elements or lower the multiplicity.)
            </summary>
            <param name="oldTotalCount">Initial sum of all multiplicities</param>
            <param name="oldRepresentation"></param>
            <param name="x">Element being added</param>
            <param name="n">Number of times to add (or remove if negative)</param>
            <param name="newTotalCount">Resulting sum of all multiplicities</param>
            <param name="newRepresentation">Resulting mapping of elements to multiplicities</param>
        </member>
        <member name="M:NModel.Bag`1.op_Subtraction(NModel.Bag{`0},NModel.Bag{`0})">
            <summary>
            Difference: Returns the bag containing all the elements from s that are not in t 
            </summary>
        </member>
        <member name="M:NModel.Bag`1.Difference(NModel.Bag{`0})">
            <summary>
            Creates a new bag where the multiplicity of each element is the difference
            of the multiplicities in this and s. That is, it returns a new bag where all
            the elements of s have been removed from this bag.
            </summary>
            <param name="s">Elements to be removed</param>
            <returns>A new bag that is the difference of this bag and the bag given as a paramter.</returns>
        </member>
        <member name="M:NModel.Bag`1.op_Multiply(NModel.Bag{`0},NModel.Bag{`0})">
            <summary>
            Intersection: Returns the set containing the elements thar are both in s and t [Time: max(s.Count,t.Count)*log(s.Count,t.Count)]
            </summary>
        </member>
        <member name="M:NModel.Bag`1.Intersect(NModel.Bag{`0})">
            <summary>
            Creates a new bag where the multiplicity of each element is the minimum
            of the multiplicities in this and s.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Bag`1.op_Addition(NModel.Bag{`0},NModel.Bag{`0})">
            <summary>
            Bag union. Returns a bag where the multiplicities of each element are the
            sum of the multiplicities of the elements of this bag and s.
            ensures result.Count == this.Count + s.Count;
            </summary>
            <param name="s"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Bag`1.Union(NModel.Bag{`0})">
            <summary>
            Creates a new bag where the multiplicities of each element are the
            sum of the multiplicities of the elements of this bag and s.
            Ensures result.Count == this.Count + s.Count;
            </summary>
            <param name="s">The other bag</param>
            <returns>A bag containing all of the elements of this and <paramref name="s"/>. For shared elements,
            the multiplicities will the sum.</returns>
        </member>
        <member name="M:NModel.Bag`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection 
            </summary>
            <returns>An enumerator that iterates through the collection</returns>
        </member>
        <member name="M:NModel.Bag`1.FieldValues">
            <summary>
            Returns an enumeration of all (readonly) field values of this compound value in a fixed order.
            </summary>
            <returns>An enumeration of the field values of this compound value.</returns>
            <remarks>See <see cref="M:NModel.CompoundValue.FieldValues"/> for more information.</remarks>
        </member>
        <member name="M:NModel.Bag`1.Equals(System.Object)">
            <exclude />
        </member>
        <member name="M:NModel.Bag`1.GetHashCode">
            <exclude />
        </member>
        <member name="M:NModel.Bag`1.ToString">
            <exclude />
        </member>
        <member name="T:NModel.CompoundValue">
            <summary>
            Data record with structural equality. 
            </summary>
            <remarks><para>A <c>CompoundValue</c> is similar to a .NET <c>struct</c>,
            but unlike a <c>struct</c> subtypes of <c>CompoundValue</c> may implement tree structures. By construction, such 
            values may be recursive but must have no cycles. (From the point of view of mathematical logic,
            values of this type can be thought of as a <i>term</i> whose <i>function symbol</i> is 
            the type and whose <i>arguments</i> are the field values.)</para>
            <para><c>CompoundValues</c> are commonly used in modeling abstract state. They should be used instead of
            mutable classes whenever practical because they can greatly reduce the amount of analysis required
            when comparing if two program states are equal. They also tend to promote a clear style, since
            they are read-only data structures. Aliased updates can thus be avoided.</para>
            <para>
            Invariant: All field values must have a fixed order and contain elements of type <see cref="T:System.IComparable"/>
            that satisfy the predicate <see cref="M:NModel.Internals.AbstractValue.IsAbstractValue(System.Object)"/>. All fields of subtypes of this 
            class must be readonly.</para>
            </remarks>
            <example>
            <para>Here is an example of how to define a data record with structural equality using <c>Compoundvalue</c>:</para>
            <code>
            public class MyPoint : CompoundValue
            {
               public readonly int x;
               public readonly int y;
            
               public MyPoint(int x, int y) { this.x = x; this.y = y; }
            }
            </code>
            <para>You can improve the runtime performance of a user-defined subtype of <c>CompoundValue</c> by overriding
            the default <see cref="M:NModel.CompoundValue.FieldValues"/> method. This is optional.</para>
            <code>
            public class MyPoint : CompoundValue
            {
               public readonly int x;
               public readonly int y;
            
               public MyPoint(int x, int y) { this.x = x; this.y = y; }
            
               public override IEnumerable&lt;IComparable&gt; FieldValues()
               {
                    yield return this.x;
                    yield return this.y;
               }
            }
            </code>
            </example>
        </member>
        <member name="M:NModel.CompoundValue.Equals(System.Object)">
            <summary>
            Structural equality testing. Objects are equal if they are of the same type
            and if each field (given by the enumeration <see cref="M:NModel.CompoundValue.FieldValues" />) is equal
            for the two values.
            </summary>
            <param name="obj">The value to compare to this value</param>
            <returns>True if the values are equal, false otherwise.</returns>
        </member>
        <member name="M:NModel.CompoundValue.op_Equality(NModel.CompoundValue,NModel.CompoundValue)">
            <summary>
            Term equality
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> equals <paramref name="o2"/> under
            term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.CompoundValue.op_Inequality(NModel.CompoundValue,NModel.CompoundValue)">
            <summary>
            Inequality of terms
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>False if <paramref name="o1"/> equals <paramref name="o2"/> under
            term ordering and true otherwise.</returns>
        </member>
        <member name="M:NModel.CompoundValue.op_LessThan(NModel.CompoundValue,NModel.CompoundValue)">
            <summary>
            Term less than
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is less than <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.CompoundValue.op_LessThanOrEqual(NModel.CompoundValue,NModel.CompoundValue)">
            <summary>
            Term less than or equal
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is less than or equal <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.CompoundValue.op_GreaterThan(NModel.CompoundValue,NModel.CompoundValue)">
            <summary>
            Term greater than
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is greater than <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.CompoundValue.op_GreaterThanOrEqual(NModel.CompoundValue,NModel.CompoundValue)">
            <summary>
            Term greater than or equal
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is greater than or equal <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.CompoundValue.GetHashCode">
            <summary>
            Hash code (computed structurally) by combining the hash codes of each field value
            given by <see cref="M:NModel.CompoundValue.FieldValues" />.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:NModel.CompoundValue.ToString">
            <summary>
            Pretty printing
            </summary>
            <returns>A formatted string showing the type and fields of this value</returns>
        </member>
        <member name="M:NModel.CompoundValue.FieldValues">
            <summary>
            Returns an enumeration of all (readonly) field values of this compound value in a fixed order.
            </summary>
            <returns>An enumeration of the field values of this compound value.</returns>
            <remarks>
            This method is not normally called directly within a model. Instead, it is invoked internally by the 
            modeling library as part of <see cref="M:NModel.CompoundValue.Equals(System.Object)"/> and <see cref="M:NModel.CompoundValue.GetHashCode"/>.
            <para>If you define your own data record types using the <c>CompoundValue</c> class you may
            want to consider overriding <see cref="M:NModel.CompoundValue.FieldValues"/> to improve performance.</para>
            <note>Invariants: This is a pure function and has the further requirement that
            the values of any two invocations must always be pairwise equal, regardless of the context in 
            which the methods is invoked. In other words, no state update may change the values returned by this
            enumeration, and the order of enumeration must be fixed.</note>
            </remarks>
            <example>
            <para>Here is an example of how to override <c>FieldValues</c> from within a derived class.</para>
            <code>
            public class MyPoint : CompoundValue
            {
               public readonly int x;
               public readonly int y;
            
               public MyPoint(int x, int y) { this.x = x; this.y = y; }
            
               public override IEnumerable&lt;IComparable&gt; FieldValues()
               {
                    yield return this.x;
                    yield return this.y;
               }
            }
            </code>
            </example>
        </member>
        <member name="P:NModel.CompoundValue.AsTerm">
            <summary>
            Returns the term representation of this value.
            </summary>
        </member>
        <member name="M:NModel.CompoundValue.FinalizeImport">
            <summary>
            Called internally to distinguish between reserve elements that are part of state and 
            those in the background set of values. Not used directly in models.
            </summary>
        </member>
        <member name="M:NModel.CompoundValue.ContainsObjectIds">
            <summary>
            Determines if this value has an object id (that is, is of type <see cref="T:NModel.Internals.LabeledInstance"/>),
            or has a subvalue that has an object id (for example, a set of instances).
            </summary>
            <returns>True if this value has an object id or contains a value with an object id.</returns>
        </member>
        <member name="M:NModel.CompoundValue.CompareTo(System.Object)">
            <summary>
            Term order. Comparision is based on type and recursively on fields.
            </summary>
            <param name="obj"></param>
            <returns>-1 if less than, 0 if equal, 1 if greater than</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="obj"/> is nonnull but is not an <c>CompoundValue</c>.</exception>
        </member>
        <member name="T:NModel.FSM">
            <summary>
            Data type that denotes a (possibly nondeterministic) finite automaton.
            </summary>
        </member>
        <member name="M:NModel.FSM.FromString(System.String)">
            <summary>
            Create an FSM from a string representation of a compound term fsm of the form 
            FSM(initialState, acceptingStates, transitions [, vocabulary])
            where:  
             - initialState is a term, 
             - acceptingStates is a compound term of the form AcceptingStates(p1,...,pk) 
             - transitions is a compound term of the form Transitions(t1,...,tl)
               where each ti is compound term of the form t(q,a,q') where 
               q and q' are states and a is a compound term 
             - vocabulary is optional, if present it must be 
               a compound term of the form Vocabulary(s1,...,sn) where 
               each si is a string literal
            </summary>
            <param name="fsm">string representation of an FSM</param>
            <returns>FSM corresponding to fsm</returns>
        </member>
        <member name="M:NModel.FSM.FromTerm(NModel.Terms.CompoundTerm)">
            <summary>
            Create an FSM from a compound term fsm of the form 
            FSM(initialState, acceptingStates, transitions [, vocabulary])
            where:  
             - initialState is a term, 
             - acceptingStates is a compound term of the form AcceptingStates(p1,...,pk) 
             - transitions is a compound term of the form Transitions(t1,...,tl)
               where each ti is compound term of the form t(q,a,q') where 
               q and q' are states and a is a compound term 
             - vocabulary is optional, if present it must be 
               a compound term of the form Vocabulary(s1,...,sn) where 
               each si is a string literal
            </summary>
            <param name="fsm">term representation of an FSM</param>
            <returns>FSM corresponding to fsm</returns>
        </member>
        <member name="M:NModel.FSM.ToTerm">
            <summary>
            Create a term representation of this FSM of the form
            FSM(initialState, acceptingStates, transitions, vocabulary)
            where:  
             - initialState is a term, 
             - acceptingStates is a compound term of the form AcceptingStates(p1,...,pk) 
             - transitions is a compound term of the form Transitions(t1,...,tl)
               where each ti is compound term of the form t(q,a,q') where 
               q and q' are states and a is a compound term 
             - vocabulary is a compound term of the form Vocabulary(s1,...,sn) where 
               each si is a string literal
            </summary>
            <returns>the term representation of this FSM</returns>
        </member>
        <member name="M:NModel.FSM.ToString">
            <summary>
            String representation of this FSM is ToTerm().ToString()
            </summary>
            <returns>ToTerm().ToString()</returns>
        </member>
        <member name="P:NModel.FSM.InitialState">
            <summary>
            The initial state
            </summary>
        </member>
        <member name="P:NModel.FSM.IsDeterministic">
            <summary>
            Returns true if the finite automaton is deterministic
            </summary>
        </member>
        <member name="P:NModel.FSM.States">
            <summary>
            The set of all states of this automaton
            </summary>
        </member>
        <member name="P:NModel.FSM.Transitions">
            <summary>
            The set of all transitions of this automaton. A transition is a triple
            (<i>start-state</i>, <i>transition-label</i>, <i>end-state</i>).
            </summary>
        </member>
        <member name="P:NModel.FSM.AcceptingStates">
            <summary>
            The set of accepting states of this automaton. A valid trace is a sequence of 
            transitions that ends in an accepting state. In other words, an accepting state
            is a valid termination state.
            </summary>
        </member>
        <member name="P:NModel.FSM.Vocabulary">
            <summary>
            The set of symbols that are included in the vocabulary of this automaton.
            </summary>
            <remarks>The function symbols of the transitions of this automaton may a subset of the action symbols. 
            This occurs when some of the actions in the vocabulary are never enabled.</remarks>
        </member>
        <member name="M:NModel.FSM.#ctor(NModel.Terms.Term,NModel.Set{NModel.Terms.Term},NModel.Set{NModel.Triple{NModel.Terms.Term,NModel.Terms.CompoundTerm,NModel.Terms.Term}},NModel.Set{NModel.Terms.Term})">
            <summary>
            Constructs a finite automaton value.
            </summary>
            <param name="initialState">The initial state</param>
            <param name="states">The set of all states of this automaton</param>
            <param name="transitions">The set of all transitions of this automaton. A transition is a triple
            (<i>start-state</i>, <i>transition-label</i>, <i>end-state</i>).</param>
            <param name="acceptingStates">The set of accepting states of this automaton.</param>
            <note> All arguments must be nonnull. The states that appear in <paramref name="transitions"/> and 
            <paramref name="acceptingStates"/> must also be elements of <paramref name="states"/>. 
            </note>
        </member>
        <member name="M:NModel.FSM.CreateFromTransitions(System.String[])">
            <summary>
            Constructs a finite automaton from given transitions.
            Each transition must be a string representation of a compound term with 
            three arguments, argument 0 is the source state, argument 1 is a compound term 
            representing an action, and argument 2 is the target state.
            The source state of the first transition is the initial state.
            The set of action symbols is derived from all the actions.
            All states are accepting.
            </summary>
            <param name="transitions">String representations of transitions</param>
            <returns>The resulting finite automaton</returns>
        </member>
        <member name="M:NModel.FSM.Create(System.String[])">
            <summary>
            Constructs a finite automaton from given transitions.
            Each transition must be a string representation of a compound term with 
            three arguments, argument 0 is the source state, argument 1 is a compound term 
            representing an action, and argument 2 is the target state.
            The source state of the first transition is the initial state.
            The set of action symbols is derived from all the actions.
            There are no accepting states.
            </summary>
            <param name="transitions">String representations of transitions</param>
            <returns>The resulting finite automaton</returns>
        </member>
        <member name="M:NModel.FSM.Extend(System.String[])">
            <summary>
            Extend this FSM with new transitions.
            Each transition must be a string representation of a compound term with 
            three arguments, argument 0 is the source state, argument 1 is a compound term 
            representing an action, and argument 2 is the target state.
            </summary>
            <param name="trans">string representations of transitions</param>
            <returns>the fsm extended with the given transitions</returns>
        </member>
        <member name="M:NModel.FSM.Accept(System.String[])">
            <summary>
            Mark the given states as accepting states.
            The existing accepting states also remain as accepting states.
            All states must exist in this fsm.
            </summary>
            <param name="newAccStates">string representations of new accepting states</param>
            <returns>fsm where the given states are marked as accepting states</returns>
        </member>
        <member name="M:NModel.FSM.#ctor(NModel.Terms.Term,NModel.Set{NModel.Terms.Term},NModel.Set{NModel.Triple{NModel.Terms.Term,NModel.Terms.CompoundTerm,NModel.Terms.Term}},NModel.Set{NModel.Terms.Term},NModel.Set{NModel.Terms.Symbol})">
            <summary>
            Constructs a finite automaton value.
            </summary>
            <param name="initialState">The initial state</param>
            <param name="states">The set of all states of this automaton</param>
            <param name="transitions">The set of all transitions of this automaton. A transition is a triple
            (<i>start-state</i>, <i>transition-label</i>, <i>end-state</i>).</param>
            <param name="acceptingStates">The set of accepting states of this automaton.</param>
            <param name="actionSymbols">The set of symbols that are included in the vocabulary of this automaton.</param>
            <note> All arguments must be nonnull. The states that appear in <paramref name="transitions"/> and 
            <paramref name="acceptingStates"/> must also be elements of <paramref name="states"/>. The function
            symbol of each transition label must be an element of <paramref name="actionSymbols"/>.
            </note>
        </member>
        <member name="M:NModel.FSM.OutgoingTransitions(NModel.Terms.Term)">
            <summary>
            The set of transitions that begin in <paramref name="startState"/>
            </summary>
            <param name="startState">A state of this automaton</param>
            <returns>The set of transitions that begin in <paramref name="startState"/></returns>
        </member>
        <member name="M:NModel.FSM.Expand(System.String[])">
            <summary>
            Create a new finite automaton from the given one by expanding the 
            signature with the new symbols.
            </summary>
            <param name="symbs">the new symbols</param>
            <returns>the expanded finite automaton</returns>
        </member>
        <member name="T:NModel.Reducer`2">
            <summary>
            Delegate type for functions that summarize a value of type T in terms another type S. Used 
            as an argument to <see cref="M:NModel.Internals.ICollectionValue`1.Reduce``1(NModel.Reducer{`0,``0},``0)" />.
            </summary>
            <typeparam name="T">Type of the object being summarized</typeparam>
            <typeparam name="S">Type of the reduction</typeparam>
            <param name="obj">The value being summarized</param>
            <param name="sum">The initial value of the reduction</param>
            <returns>The reduction calculated from the initial value <paramref name="sum"/>
            and the value being summarized, <paramref name="obj"/>.</returns>
            <seealso cref="M:NModel.Internals.ICollectionValue`1.Reduce``1(NModel.Reducer{`0,``0},``0)" />
        </member>
        <member name="T:NModel.LabeledInstance`1">
            <summary>
            Base class whose derived classes have abstract object ids.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NModel.LabeledInstance`1.GetSort">
            <summary>
            The sort (abstract type) of T. Sorts are used to match types across model programs.
            </summary>
            <returns>The sort associated with type T</returns>
        </member>
        <member name="M:NModel.LabeledInstance`1.Create">
            <summary>
            Static constructor (to replace creation by operator "new") of labeled instances.
            Allocates a new object (or reuses an existing element from a per-sort pool if available).
            </summary>
            <returns>A new labeled instance of type T</returns>
        </member>
        <member name="M:NModel.LabeledInstance`1.PeekNext">
            <summary>
            Object creation "lookahead". Returns the next object that will be
            returned by the <see cref="M:NModel.LabeledInstance`1.Create"/> method in the current state.
            This method does not change the current state of the model program.
            </summary>
            <note>
            Used by parameter generation when a action parameter takes a new instance</note>
            <returns>The next instance of type T</returns>
        </member>
        <member name="M:NModel.LabeledInstance`1.ImportElement(System.Int32)">
            <summary>
            Imports the ith value of this type but does not update the domain map for this type.
            </summary>
            <param name="i">The index</param>
            <returns>The <c>LabeledInstance</c> that represents the ith value of the type</returns>
        </member>
        <member name="M:NModel.LabeledInstance`1.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:NModel.Filter`1">
            <summary>
            A <c>Filter</c> is a function that replaces a value of type <typeparamref name="T"/>. 
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="value">The value</param>
            <returns>A replacement value of type <typeparamref name="T"/></returns>
            <remarks>The function should not make any updates to state. Filters are used in 
            the <seealso cref="M:NModel.Map`2.Override(`0,NModel.Filter{`1})"/> method.</remarks>
        </member>
        <member name="T:NModel.Map`2">
            <summary>
            Immutable type that represents a finite mapping of keys to values.
            </summary> 
            <remarks>
            Maps associate keys with values. Maps are similar to <see>Dictionary</see>
            but are immutable and use structural equality. Add and Remove operations return new maps.
            </remarks>
            <example>
            <code>
            public void MapExample()
            {
                Map&lt;string, int&gt; m1 = Map&lt;string, int&gt;.EmptyMap;
                Map&lt;string, int&gt; m2 = new Map&lt;string, int&gt;("abc", 1, "def", 2);
                Map&lt;string, int&gt; m3 = new Map&lt;string, int&gt;("efg", 3, "def", 2);
                Map&lt;string, int&gt; m4 = m2.Merge(m3);
                Map&lt;string, int&gt; m5 = m4.Add("hij", 4);
                Map&lt;string, int&gt; m6 = m5.RemoveKey("efg");
                Map&lt;string, int&gt; m7 = m6.Override("abc", -1);
                Map&lt;string, int&gt; m8 = new Map&lt;string, int&gt;("abc", -1, "def", 2, "hij", 4);
                Assert.AreEqual(m8, m7); 
            }
            </code>
            </example>
        </member>
        <member name="T:NModel.Map`2.Maplet">
            <summary>
            <para>Auxiliary type needed for overriding Equals method.</para>
            <para>NOTE: This type has an equality defined only to make the LobTree 
            used in its implementation work. Do not use the Maplet type for anything else,
            instead, extract the Pair out of it. </para>
            </summary>
        </member>
        <member name="M:NModel.Map`2.#ctor">
            <summary>
            Default constructor, provided for convenience only. The static property <see cref="P:NModel.Map`2.EmptyMap" /> is 
            preferred.
            </summary>
        </member>
        <member name="P:NModel.Map`2.EmptyMap">
            <summary>
            The empty map of sort &lt;T, S&gt;
            </summary>
        </member>
        <member name="M:NModel.Map`2.#ctor(`0,`1)">
            <summary>
            Creates a map from the key and value given as arguments.
            </summary>
            <param name="key1">The key</param>
            <param name="value1">The value corresponding to <paramref name="key1"/></param>
        </member>
        <member name="M:NModel.Map`2.#ctor(`0,`1,`0,`1)">
            <summary>
            Creates a map from the keys and values given as arguments.
            </summary>
            <param name="key1">The first key</param>
            <param name="value1">The value corresponding to <paramref name="key1"/></param>
            <param name="key2">The second key</param>
            <param name="value2">The value corresponding to <paramref name="key2"/></param>
        </member>
        <member name="M:NModel.Map`2.#ctor(`0,`1,`0,`1,`0,`1)">
            <summary>
            Creates a map from the keys and values given as arguments.
            </summary>
            <param name="key1">The first key</param>
            <param name="value1">The value corresponding to <paramref name="key1"/></param>
            <param name="key2">The second key</param>
            <param name="value2">The value corresponding to <paramref name="key2"/></param>
            <param name="key3">The third key</param>
            <param name="value3">The value corresponding to <paramref name="key3"/></param>
        </member>
        <member name="M:NModel.Map`2.#ctor(`0,`1,`0,`1,`0,`1,`0,`1)">
            <summary>
            Creates a map from the keys and values given as arguments.
            </summary>
            <param name="key1">The first key</param>
            <param name="value1">The value corresponding to <paramref name="key1"/></param>
            <param name="key2">The second key</param>
            <param name="value2">The value corresponding to <paramref name="key2"/></param>
            <param name="key3">The third key</param>
            <param name="value3">The value corresponding to <paramref name="key3"/></param>
            <param name="key4">The fourth key</param>
            <param name="value4">The value corresponding to <paramref name="key4"/></param>
        </member>
        <member name="M:NModel.Map`2.#ctor(`0,`1,`0,`1,`0,`1,`0,`1,`0,`1)">
            <summary>
            Creates a map from the keys and values given as arguments.
            </summary>
            <param name="key1">The first key</param>
            <param name="value1">The value corresponding to <paramref name="key1"/></param>
            <param name="key2">The second key</param>
            <param name="value2">The value corresponding to <paramref name="key2"/></param>
            <param name="key3">The third key</param>
            <param name="value3">The value corresponding to <paramref name="key3"/></param>
            <param name="key4">The fourth key</param>
            <param name="value4">The value corresponding to <paramref name="key4"/></param>
            <param name="key5">The fifth key</param>
            <param name="value5">The value corresponding to <paramref name="key5"/></param>
        </member>
        <member name="M:NModel.Map`2.#ctor(System.Collections.Generic.IEnumerable{NModel.Pair{`0,`1}})">
            <summary>
            Creates a map from pairs of keys and values
            </summary>
            <param name="keyValuePairs">An enumeration of key/value pairs</param>
            <remarks>
            Construct map with each key value pairs. If duplicates exist,
            the last key-value pair is used.
            <para>Note: this constructor is intended to allow the creation of map from 
            Dictionary, Map or other enumerator of key value pairs. Typical use would 
            be to use a Dictionary as a "map builder" and then create
            the map from the dictionary.</para>
            </remarks>
        </member>
        <member name="M:NModel.Map`2.#ctor(NModel.Pair{`0,`1}[])">
            <summary>
            Create a map with a <c>params</c> array of key/value pairs
            </summary>
            <param name="keyValuePairs"></param>
            <remarks>
            Construct map with each key value pair. If duplicates exist,
            the last key-value pair is used.
            </remarks>
        </member>
        <member name="P:NModel.Map`2.Count">
            <summary>
            Returns the Gets the number of key-and-value pairs contained in the map
            </summary>
        </member>
        <member name="M:NModel.Map`2.Contains(NModel.Pair{`0,`1})">
            <summary>
            Tests whether the given key-value pair is found in the map.
            <note>See <see cref="M:NModel.Map`2.ContainsKey(`0)" /> instead if you want to check if a given key is in the map.</note>
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the <paramref name="item"/> is in this collection value, false otherwise.</returns>
            <remarks>
            Complexity: O(log(this.Count))
            </remarks>
        </member>
        <member name="M:NModel.Map`2.Convert``2(System.Converter{NModel.Pair{`0,`1},NModel.Pair{``0,``1}})">
            <summary>
            Returns a collection value of the same type (set, map, etc.) as this collection value. The result contains
            the result of applying the given converter function to each value of this collection.
            </summary>
            <param name="converter">The converter function to be applied</param>
            <returns></returns>
        </member>
        <member name="M:NModel.Map`2.Select(System.Predicate{NModel.Pair{`0,`1}})">
            <summary>
            Applies <paramref name="selector"/> to each key-value pair of this map and collects all values where 
            the selector function returns true.
            </summary>
            <param name="selector">A Boolean-valued delegate that acts as the inclusion test. True means
            include; false means exclude.</param>
            <returns>The map of all key-value pairs of this map that satisfy the <paramref name="selector"/></returns>
        </member>
        <member name="M:NModel.Map`2.GetEnumerator">
            <summary>
            Enumerates the key-value pairs in this map
            </summary>
            <returns>The enumerator of key-value pairs</returns>
        </member>
        <member name="P:NModel.Map`2.Keys">
            <summary>
            The set of keys in the map (i.e., the domain of the map)
            </summary>
        </member>
        <member name="P:NModel.Map`2.Values">
            <summary>
            The set of values in the map (i.e., the range of the map). 
            </summary>
            <remarks>The number of elements enumerated is the number of unique values. This may be 
            less than the number of key/value pairs found in the map if some values appear more than once.
            </remarks>
        </member>
        <member name="M:NModel.Map`2.IsSubmapOf(NModel.Map{`0,`1})">
            <summary>
            Is this a submap of t? That is, is every key-value pair of s also found in t?
            </summary>
            <param name="t">The map to be tested with respect to this map</param>
            <returns></returns>
        </member>
        <member name="M:NModel.Map`2.TryGetValue(`0,`1@)">
            <summary>
            Looks up a value associated with a given key
            </summary>
            <param name="key">The key</param>
            <param name="value">The value associated with this key (out parameter), or the default value if not found</param>
            <returns>True if there a value associated with the key was found, false otherwise.</returns>
        </member>
        <member name="P:NModel.Map`2.Item(`0)">
            <summary>
            Get returns the value of the provided key stored in the map, provided it exists, otherwise it abrupts; 
            Set includes/overrides the key-value pair in the map [Time: log(this.Count)]
            </summary>
        </member>
        <member name="M:NModel.Map`2.Add(`0,`1)">
            <summary>
            Produces a map that contains all the key/value pairs of this map, plus the given key/value pair.
            </summary>
            <param name="key">The key to be added. An exception will be thrown if this map has this key.</param>
            <param name="value">The value to be associated with the key in the result map</param>
            <returns>A map containing the key/value pairs of this map, plus the given key/value pair</returns>
        </member>
        <member name="M:NModel.Map`2.Add(NModel.Pair{`0,`1})">
            <summary>
            Produces a map that contains all the key/value pairs of this map, plus the given key/value pair.
            </summary>
            <param name="d">The key-value pair to be added</param>
            <returns>A map containing the key/value pairs of this map, plus the given key/value pair</returns>
            <exception cref="T:System.ArgumentException">Thrown if the key already has a value in the map.</exception>
        </member>
        <member name="M:NModel.Map`2.Override(`0,`1)">
            <summary>
            Adds an element with the specified key and value into the map
            </summary>
        </member>
        <member name="M:NModel.Map`2.Override(NModel.Map{`0,`1})">
            <summary>
            Map override. Returns the map that contains all key-value pairs of <paramref name="s"/>
            and those key-value pairs of <paramref name="this"/> for which there is no corresponding
            key in <paramref name="s"/>. In other words, this operation combines <paramref name="this"/>
            and <paramref name="s"/> in a way that gives priority to <paramref name="s"/>.
            </summary>
            <param name="s">The map containing the override values.</param>
            <returns>A new map with overridden values.</returns>
        </member>
        <member name="M:NModel.Map`2.Override(NModel.Pair{`0,`1})">
            <summary>
            Map override. Returns the map that contains all key-value pairs of <paramref name="this"/>
            along with key-value pair <paramref name="d"/>, except that if the key of <paramref name="d"/>
            is in <paramref name="this"/>, the value of <paramref name="d"/> will replace (i.e., override)
            the corresponding value of <paramref name="this"/>.
            </summary>
            <param name="d">The key-value pair to add.</param>
            <returns>A new map with overridden values.</returns>
        </member>
        <member name="M:NModel.Map`2.Override(`0,NModel.Filter{`1})">
            <summary>
            Map override. Returns the mapt that contains all key-value pairs of <paramref name="this"/>,
            except that the value for key <paramref name="key"/> will be substituted by the value of
            <paramref name="updateFunction"/> applied to the old value associated with <paramref name="key"/>.
            </summary>
            <param name="key"></param>
            <param name="updateFunction"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException">Thrown if this map does not contain key <paramref name="key"/>.</exception>
        </member>
        <member name="M:NModel.Map`2.RemoveKey(`0)">
            <summary>
            Removes the element with the specified key from the map
            </summary>
        </member>
        <member name="M:NModel.Map`2.Remove(NModel.Pair{`0,`1})">
            <summary>
            Removes the key-value pair from the map. If the key is present but is
            associated with a different value, then an exception is thrown.
            </summary>
        </member>
        <member name="M:NModel.Map`2.InPlaceAdd(`0,`1)">
            <summary>
            Adds an element with the specified key and value into the map [Time: log(this.Count)]
            </summary>
        </member>
        <member name="M:NModel.Map`2.InPlaceOverride(NModel.Pair{`0,`1})">
            <summary>
            Adds an element with the specified key and value into the map [Time: log(this.Count)]
            </summary>
        </member>
        <member name="M:NModel.Map`2.InPlaceRemoveKey(`0)">
            <summary>
            Removes the element with the specified key from the map
            </summary>
        </member>
        <member name="M:NModel.Map`2.InPlaceRemove(NModel.Pair{`0,`1})">
            <summary>
            Removes the key-value pair from the map
            </summary>
        </member>
        <member name="M:NModel.Map`2.ToString">
            <summary>
            Returns the map formatted in the form "Map(key_1 -> value_1, ..., key_n -> value_n)" 
            </summary>
        </member>
        <member name="M:NModel.Map`2.ContainsKey(`0)">
            <summary>
            True, if the map contains a specific key, false otherwise [Time: log(this.Count)]
            </summary>
        </member>
        <member name="M:NModel.Map`2.op_Addition(NModel.Map{`0,`1},NModel.Map{`0,`1})">
            <summary>
            Map merge. Returns a map that contains every key-value pair 
            of map <paramref name="s"/> and map <paramref name="t"/>, 
            provided that for all shared keys the values agree.
            </summary>
            <param name="s">The first map</param>
            <param name="t">The second map</param>
            <returns>A map containing the merged key-value pairs</returns>
            <exception cref="T:System.ArgumentException">Thrown if map <paramref name="s"/> and map <paramref name="t"/> 
            have shared keys with inconsistent values.</exception>
        </member>
        <member name="M:NModel.Map`2.Merge(NModel.Map{`0,`1})">
            <summary>
            Map merge. Returns a map that contains every key-value pair 
            of <paramref name="this"/> and map <paramref name="t"/>, 
            provided that for all shared keys the values agree.
            </summary>
            <param name="t">The second map</param>
            <returns>A map containing the merged key-value pairs</returns>
            <exception cref="T:System.ArgumentException">Thrown if this map and map <paramref name="t"/> have 
            shared keys with inconsistent values.</exception>
        </member>
        <member name="M:NModel.Map`2.Intersect(NModel.Map{`0,`1})">
            <summary>
            Map intersection
            </summary>
            <param name="t">The second map</param>
            <returns>A map containing only those key/value pairs that occur in this map and <paramref name="t"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if this map and map <paramref name="t"/> have 
            shared keys with inconsistent values.</exception>
        </member>
        <member name="M:NModel.Map`2.Difference(NModel.Map{`0,`1})">
            <summary>
            Map difference
            </summary>
            <param name="t">The map whose elements will be not present in the result</param>
            <returns>The map containing all the key/value pairs of this map, except the key/value 
            pairs given in the map provided as an argument.</returns>
            <exception cref="T:System.ArgumentException">Thrown if this map and map <paramref name="t"/> have 
            shared keys with inconsistent values.</exception>
        </member>
        <member name="M:NModel.Map`2.RestrictKeys(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns a map consisting of the elements in map whose key is not in keys
            </summary>
        </member>
        <member name="M:NModel.Map`2.RestrictValues(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Returns a map consisting of the elements in map whose value is not in values
            </summary>
        </member>
        <member name="M:NModel.Map`2.op_Subtraction(NModel.Map{`0,`1},NModel.Map{`0,`1})">
            <summary>
            Map difference
            </summary>
            <param name="s">The map whose elements will be present in the result</param>
            <param name="t">The map whose elements will be not present in the result</param>
            <returns>The map containing all the key/value pairs of this map, except the key/value pairs given in the map provided as an argument.</returns>
            <exception cref="T:System.ArgumentException">Thrown if map <paramref name="s"/> and map <paramref name="t"/> 
            have shared keys with inconsistent values.</exception>
        </member>
        <member name="M:NModel.Map`2.op_Multiply(NModel.Map{`0,`1},NModel.Map{`0,`1})">
            <summary>
            Map intersection
            </summary>
            <param name="s">The first map</param>
            <param name="t">The second map</param>
            <returns>A map containing only those key/value pairs that occur in map <paramref name="s"/> and map <paramref name="t"/>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if map <paramref name="s"/> and map <paramref name="t"/> 
            have shared keys with inconsistent values.</exception>
        </member>
        <member name="M:NModel.Map`2.BigMerge(System.Collections.Generic.IEnumerable{NModel.Map{`0,`1}})">
            <summary>
            Distributed Merge: Returns the mapping that is constructed by merging all the mappings in s.
            </summary>
        </member>
        <member name="M:NModel.Map`2.BigOverride(System.Collections.Generic.IEnumerable{NModel.Map{`0,`1}})">
            <summary>
            Distributed Override: Returns the mapping that is constructed by overriding all the mappings in s.
            </summary>
        </member>
        <member name="M:NModel.Map`2.FieldValues">
            <summary>
            Returns an enumeration of the field values of map. This
            is the count of the collection followed by the keys and values
            of the map in alternating order.
            <note>This is a pure function and has the further requirement that
            its value must always be the same regardless of the context in which it is invoked. 
            In other words, no state update may change the values returned by this
            enumeration.</note>
            <note>This is provided to make equality testing and hashing efficient. The values returned
            may be encodings of the internal data structures used to implement the collection
            value; other accessors such as <see cref="M:NModel.Map`2.GetEnumerator" /> provide enumeration
            capabilities for general use.</note>
            </summary>
            <returns>An enumeration of the field values of this map.</returns>
        </member>
        <member name="M:NModel.Map`2.Equals(System.Object)">
            <exclude />
        </member>
        <member name="M:NModel.Map`2.GetHashCode">
            <summary>
            The hash code as calculated in the base class.
            </summary>
            <returns>The hash code (either from the cache or calculated)</returns>
        </member>
        <member name="T:NModel.OrderedSet`1">
            <summary>
            A collection of distinct values, maintained in order according to the <see cref="T:System.IComparable"/> interface
            </summary>
            <typeparam name="T">The sort of element</typeparam>
            <remarks>
            <para>Enumeration occurs in IComparable order.</para>
            
            <para>OrderedSet is an immutable type; Add/remove operations return a new set. Comparison
            for equality uses Object.Equals.</para>
            
            <para>Formally, this data type denotes a pair (elementType, untyped sequence of distinct values),
            where the element type is given by the type parameter T. As a consequence, ordered sets are only
            equal if they are of the same sort (element type) and contain the same elements. 
            For example, the empty OrderedSet&lt;int&gt; != OrderedSet&lt;string&gt;</para>
            </remarks>
        </member>
        <member name="M:NModel.OrderedSet`1.#ctor">
            <summary>
            Constructs an empty ordered set
            </summary>
        </member>
        <member name="F:NModel.OrderedSet`1.EmptySet">
            <summary>
            The empty set of sort T. Note: If S and T are different types,
            Object.Equals(OrderedSet&lt;T&gt;.EmptyOrderedSet, OrderedSet&lt;S&gt;.EmptySet) == false.
            </summary>
        </member>
        <member name="M:NModel.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Construct a set containing all enumerated elements
            </summary>
            <param name="os">The enumerable object containing the elements that will be members of the set</param>
        </member>
        <member name="M:NModel.OrderedSet`1.#ctor(`0[])">
            <summary>
            Construct a set from the elements given in the argument list
            </summary>
            <param name="contents">The argument list</param>
        </member>
        <member name="P:NModel.OrderedSet`1.Count">
            <summary>
            Returns the number of elements in the set (also known as the cardinality of the set). 
            </summary>
            <remarks>
            Complexity: O(1)
            </remarks>
        </member>
        <member name="M:NModel.OrderedSet`1.Contains(`0)">
            <summary>
            Tests whether the given element is found in the collection value.
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the <paramref name="item"/> is in this collection value, false otherwise.</returns>
            <remarks>
            Complexity: log(this.count)
            </remarks>
        </member>
        <member name="M:NModel.OrderedSet`1.IsSubsetOf(NModel.OrderedSet{`0})">
            <summary>
            Subset relation
            </summary>
            <param name="t"></param>
            <returns>True if this every element of this set is also found in set <paramref name="t"/>; false otherwise.</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.IsProperSubsetOf(NModel.OrderedSet{`0})">
            <summary>
            Proper subset relation
            </summary>
            <param name="t"></param>
            <returns>True if this every element of this set is found in set <paramref name="t"/>
            and there exists at least one element in <paramref name="t"/> that is not found in this set; 
            false otherwise.</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.IsSupersetOf(NModel.OrderedSet{`0})">
            <summary>
            Superset relation
            </summary>
            <param name="t"></param>
            <returns>True if this every element of set <paramref name="t"/> is also found in this set; false otherwise.</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.IsProperSupersetOf(NModel.OrderedSet{`0})">
            <summary>
            Proper superset relation
            </summary>
            <param name="t"></param>
            <returns>True if this every element of set <paramref name="t"/> is also found in this set
            and there exists at least one element in this set that is not found in <paramref name="t"/>; 
            false otherwise.</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.Remove(`0)">
            <summary>
            Returns a new set containing every element of this set except the value given as a parameter.
            If value is not in this set, then returns this set. [Time: log(this.Count)]
            </summary>
            <param name="value">The value to be deleted.</param>
            <returns>The new set</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.Add(`0)">
            <summary>
            Returns a new set with all of the elements of this set, plus the value given as an argument [Time: log(this.Count)]
            </summary>
            <param name="value">The value to add</param>
            <returns>The new set containing value.</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.ToString">
            <summary>
            String representation of an ordered set
            </summary>
        </member>
        <member name="M:NModel.OrderedSet`1.op_Addition(NModel.OrderedSet{`0},NModel.OrderedSet{`0})">
            <summary>
            OrderedSet union [Time: max(s.Count,t.Count)*log(max(s.Count, t.Count))]
            </summary>
            <param name="s">A set</param>
            <param name="t">A set</param>
            <returns>The set containing all the elements from both s and t</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.Union(NModel.OrderedSet{`0})">
            <summary>
            Same as operator + (set union). 
            </summary>
            <param name="t">A set to be unioned with this set</param>
            <returns>The set containing all the elements from both this and t</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.op_Subtraction(NModel.OrderedSet{`0},NModel.OrderedSet{`0})">
            <summary>
            OrderedSet difference [Time: t.Count * log(s.Count)] 
            </summary>
            <param name="s">The set containing potentially unwanted elements</param>
            <param name="t">The set of unwanted elements</param>
            <returns>The set containing all the elements from s that are not in t</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.Difference(NModel.OrderedSet{`0})">
            <summary>
            OrderedSet difference. Same as operator -
            </summary>
            <param name="t">The set of unwanted elements to be removed from this set</param>
            <returns>The set containing all the elements from this that are not in t</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.op_Multiply(NModel.OrderedSet{`0},NModel.OrderedSet{`0})">
            <summary>
            OrderedSet intersection  [Time: max(s.Count,t.Count)*log(max(s.Count, t.Count))]
            </summary>
            <param name="s">A set</param>
            <param name="t">A set</param>
            <returns>The set of all elements that are shared by s and t</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.Intersect(NModel.OrderedSet{`0})">
            <summary>
            OrderedSet intersection. Same as operator *.  [Time: max(s.Count,t.Count)*log(max(s.Count, t.Count))]
            </summary>
            <param name="t">A set to be intersected with this.</param>
            <returns>The set of all elements that shared by this and t</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.BigUnion(NModel.OrderedSet{NModel.OrderedSet{`0}})">
            <summary>
            Distributed set union. [Time: s1.Count * s2.Count * ... * sn.Count where n is the number of sets in s]
            </summary>
            <param name="s">A set of sets to be combined by set union</param>
            <returns>The union of all the sets in s. That is, the set containing all the elements 
            of all the elements of s </returns>
        </member>
        <member name="M:NModel.OrderedSet`1.BigIntersect(NModel.OrderedSet{NModel.OrderedSet{`0}})">
            <summary>
            Distributed Intersection: The resulting set is the intersection of all the elements of s, 
            i.e. it contains the elements that are in all elements [Time: max(s.Count,t.Count)*log(s.Count,t.Count)]
            </summary>
            <summary>
            Distributed set intersection. [Time: max(s1.Count,  s2.Count, ..., sn.Count) * log(max(s1.Count, s2.Count, ..., sn.Coung))
            where n is the number of sets in s]
            </summary>
            <param name="s">A set of sets to be combined by set intersection</param>
            <returns>The intersection of all the sets in s. That is, the set containing only those elements 
            that are shared by all of the elements of s</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.GetEnumerator">
            <summary>
            Enumerator of each element of this set. If two sets are equal, then their enumerations are in the same order.
            (This is a fixed order with no external significance.)
            </summary>
            <returns>The enumerator of this set</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.Convert``1(System.Converter{`0,``0})">
            <summary>
            Transforms a set of one sort to a set of another sort by invoking a given delegate on each element. 
            If the mapping is injective, then the number of elements in the result will be the same as the number
            of elements in this. Otherwise, (if not injective) the number of elements will be fewer.
            </summary>
            <typeparam name="S">The sort of the result</typeparam>
            <param name="converter">A pure (side-effect free) function that maps an element of T to an element of S</param>
            <returns>The set</returns>
        </member>
        <member name="M:NModel.OrderedSet`1.InvariantHolds">
            <summary>
            Checks that internal assumptions in the implementation of sets hold for this set. 
            Used for debugging and verification only.
            </summary>
            <returns>true</returns>
        </member>
        <member name="T:NModel.Pair`2">
            <summary>
            Binary tuples with structural equality.
            </summary>
        </member>
        <member name="P:NModel.Pair`2.First">
            <summary>
            The first value
            </summary>
        </member>
        <member name="P:NModel.Pair`2.Second">
            <summary>
            The second value
            </summary>
        </member>
        <member name="M:NModel.Pair`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of a pair with the given arguments
            </summary>
        </member>
        <member name="M:NModel.Pair`2.Equals(System.Object)">
            <summary>
            True, if value is a pair and is structurally equal to this, false otherwise [Time: see ==]
            </summary>
        </member>
        <member name="M:NModel.Pair`2.GetHashCode">
            <exclude />
        </member>
        <member name="M:NModel.Pair`2.op_Equality(NModel.Pair{`0,`1},NModel.Pair{`0,`1})">
            <summary>
            Deep structural equality on Pairs
            </summary>
        </member>
        <member name="M:NModel.Pair`2.op_Inequality(NModel.Pair{`0,`1},NModel.Pair{`0,`1})">
            <summary>
            Deep structural inequality on Pairs
            </summary>
        </member>
        <member name="M:NModel.Pair`2.op_LessThan(NModel.Pair{`0,`1},NModel.Pair{`0,`1})">
            <summary>
            Term inequality (less than)
            </summary>
            <param name="o1">The first term</param>
            <param name="o2">The second term</param>
            <returns>True, if under term ordering, <paramref name="o1"/> is less than <paramref name="o2" />; false otherwise.</returns>
        </member>
        <member name="M:NModel.Pair`2.op_LessThanOrEqual(NModel.Pair{`0,`1},NModel.Pair{`0,`1})">
            <summary>
            Term inequality (less than or equals)
            </summary>
            <param name="o1">The first term</param>
            <param name="o2">The second term</param>
            <returns>True, if under term ordering, <paramref name="o1"/> is less than <paramref name="o2"/>; false otherwise.</returns>
        </member>
        <member name="M:NModel.Pair`2.op_GreaterThan(NModel.Pair{`0,`1},NModel.Pair{`0,`1})">
            <summary>
            Term greater than
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is greater than <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.Pair`2.op_GreaterThanOrEqual(NModel.Pair{`0,`1},NModel.Pair{`0,`1})">
            <summary>
            Term greater than or equal
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is greater than or equal <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.Pair`2.ToString">
            <summary>
            Formats this triple as "Triple&lt;T1,T2&gt;(first, second)"
            </summary>
            <returns>The formatted string</returns>
        </member>
        <member name="M:NModel.Pair`2.CompareTo(System.Object)">
            <summary>
            Term order. Comparision is pairwise using the term ordering of <see cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />.
            </summary>
            <param name="obj"></param>
            <returns>-1 if less than, 0 if equal, 1 if greater than</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="obj"/> is not of the same type as this triple.</exception>
            <seealso cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />
        </member>
        <member name="P:NModel.Pair`2.AsTerm">
            <summary>
            Returns the term representation of this value.
            </summary>
        </member>
        <member name="M:NModel.Pair`2.FinalizeImport">
            <summary>
            Called internally to distinguish between reserve elements that are part of state and 
            those in the background set of values. Not used directly in models.
            </summary>
        </member>
        <member name="M:NModel.Pair`2.ContainsObjectIds">
            <summary>
            Determines if this value has an object id (that is, is of type <see cref="T:NModel.Internals.LabeledInstance"/>),
            or has a subvalue that has an object id (for example, a set of instances).
            </summary>
            <returns>True if this value has an object id or contains a value with an object id.</returns>
        </member>
        <member name="T:NModel.Sequence`1">
            <summary>
            Immutable type representing an ordered collection of (possibly repeating) values
            </summary>
            <remarks>
            Sequences contain indexable elements. Sequences are similar to ArrayLists, but unlike ArrayLists, they are immutable.
            Sequences are implmented as double linked list (concatenation to the beginning or end is constant time)
            Lookup is linear time; if possible, callers should use foreach(T val in sequence) ... instead of 
            for(int i = 0; i &lt; sequence.Count; i += 1) { ... sequence[i] ... }
            </remarks>
        </member>
        <member name="M:NModel.Sequence`1.#ctor">
            <summary>
            Constructs an empty sequence
            </summary>
        </member>
        <member name="F:NModel.Sequence`1.EmptySequence">
            <summary>
            The empty set of sort T. Note: If S and T are different types,
            Object.Equals(Sequence&lt;T&gt;.EmptySequence, Sequence&lt;S&gt;.EmptySequence) == false.
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Constructs a sequence with given elements
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.#ctor(`0[])">
            <summary>
            Constructs a sequence with given elements
            </summary>
            <param name="elems"></param>
        </member>
        <member name="M:NModel.Sequence`1.AddFirst(`0)">
            <summary>
            Appends element to front of a sequence
            </summary>
            <param name="value">The element to append</param>
            <returns>A new sequence with element appended at the front</returns>
        </member>
        <member name="M:NModel.Sequence`1.AddLast(`0)">
            <summary>
            Appends element to end of a sequence
            </summary>
            <param name="value">The element to append</param>
            <returns>A new sequence with element appended at the end</returns>
        </member>
        <member name="P:NModel.Sequence`1.Count">
            <summary>
            Gets the number of elements actually contained in the sequence.
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Choose(System.Int32)">
            <summary>
            Select an arbitrary value from the sequence, with external choice.
            </summary>
            <param name="i">An externally chosen integer in the interval [0, this.Count).</param>
            <returns>An element of the sequence.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="i"/> is outside 
            the interval [0, this.Count).</exception>
            <remarks>As a pure function, this method will always return the same value 
            for each pair of arguments (<paramref name="this"/> and <paramref name="i"/>).</remarks>
        </member>
        <member name="P:NModel.Sequence`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index [Time: this.Count/2]
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Contains(`0)">
            <summary>
            Tests whether the given element is found in the sequence.
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the <paramref name="item"/> is in this sequence, false otherwise.</returns>
            <remarks>
            Complexity: O(this.Count)
            </remarks>
        </member>
        <member name="M:NModel.Sequence`1.IndexOf(`0)">
            <summary>
            Returns the zero-based index of the first occurrence of the given object in the sequence, -1 if it doesn't occur.
            </summary>
            <param name="o">The item to be bound</param>
            <returns>The zero-based index of the first occurrence of <paramref name="o"/></returns>
            <remarks>[Complexity: O(this.Count)]</remarks>
        </member>
        <member name="M:NModel.Sequence`1.LastIndexOf(`0)">
            <summary>
            Returns the zero-based index of the last occurrence of the given object in the Vector, -1 if it doesn't occur (linear time).
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.ToString">
            <summary>
            String representation of a sequence
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Sequence`1.IsPrefixOf(NModel.Sequence{`0})">
            <summary>
            Returns true if the given sequence is a prefix of this sequence
            </summary>
        </member>
        <member name="P:NModel.Sequence`1.Head">
            <summary>
            Return the first element of the seq
            </summary>
        </member>
        <member name="P:NModel.Sequence`1.Last">
            <summary>
            Return the last element of the seq
            </summary>
        </member>
        <member name="P:NModel.Sequence`1.Tail">
            <summary>
            Return the subsequence of the seq where the first element is removed
            </summary>
        </member>
        <member name="P:NModel.Sequence`1.Front">
            <summary>
            Return the subsequence of the seq where the last element is removed
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.BigConcatenate(System.Collections.Generic.IEnumerable{NModel.Sequence{`0}})">
            <summary>
            Distributed Concatenation: Returns the sequence where the elements of s 
            (these are sequences themselves) are appended, the first, the second and so on
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Reverse">
            <summary>
            Returns the sequence where the elements of s are in reverse order, 
            i.e. the last becomes the first, the second last becomes the second, ans so on
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Concatentate(NModel.Sequence{`0})">
            <summary>
            Concatenates the given sequence t at the end of this sequence
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Sequence`1.op_Addition(NModel.Sequence{`0},NModel.Sequence{`0})">
            <summary>
            Append: Returns the sequence consistsing of the eleents of s followed by those of t in order.
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.InplaceAdd(`0)">
            <summary>
            Adds the object to the sequence [Time: constant]
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the sequence [Time this.Count]
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Difference(NModel.Sequence{`0})">
            <summary>
            Returns this - t
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.op_Subtraction(NModel.Sequence{`0},NModel.Sequence{`0})">
            <summary>
            Returns a subsequence of s, by removing t's elements from s in order.  [Time this.Count]
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Zip``1(NModel.Sequence{`0},NModel.Sequence{``0})">
            <summary>
            Returns the sequence of pairs of elements from s1 and s2
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Unzip``1(NModel.Sequence{NModel.Pair{`0,``0}})">
            <summary>
            Returns a pair of sequences which elements are drawn from a sequqnce of pairs 
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.GetEnumerator">
            <summary>
            Enumerates the elements in the sequence in the order they appear in the sequence
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Convert``1(System.Converter{`0,``0})">
            <summary>
            Converts this sequence to a sequence of elements of type S using the given converter
            </summary>
        </member>
        <member name="M:NModel.Sequence`1.Select(System.Predicate{`0})">
            <summary>
            Applies <paramref name="selector"/> to each element of this sequence and collects all values,
            preserving sequence order, where the selector function returns true.
            </summary>
            <param name="selector">A Boolean-valued delegate that acts as the inclusion test. True means
            include; false means exclude.</param>
            <returns>The sequence of all elements from this sequence that satisfy the <paramref name="selector"/></returns>
        </member>
        <member name="M:NModel.Sequence`1.ChoosePermutation(System.Int32)">
            <summary>
            Chooses an arbitrary reordering of this sequence, using <paramref name="i"/> to provide choice, based 
            on the ordering given by <see cref="M:NModel.Combinatorics.ChoosePermutation(System.Int32,System.Int32)"/>.
            </summary>
            <param name="i">An arbitrary integer that will be used as a seed to select the permutation.</param>
            <returns>A sequence with the same elements as this sequence but in a potentially different order.</returns>
        </member>
        <member name="T:NModel.Set`1">
            <summary>
            Immutable type representing an unordered collection of distinct values
            </summary>    
            <typeparam name="T">The sort of element</typeparam>    
            <remarks>
            <para>Set is an immutable type; Add/remove operations return a new set. Comparison
            for equality uses Object.Equals.</para>
            
            <para>Formally, this data type denotes a pair (elementType, untyped set of values),
            where the element type is given by the type parameter T. As a consequence, sets are only
            equal if they are of the same sort (element type) and contain the same elements. 
            For example, the empty Set&lt;int&gt; != Set&lt;string&gt;</para>
            </remarks>
        </member>
        <member name="M:NModel.Set`1.#ctor">
            <summary>
            Constructs an empty set of type T
            </summary>
        </member>
        <member name="F:NModel.Set`1.EmptySet">
            <summary>
            The empty set of sort T. Note: If S and T are different types,
            Object.Equals(Set&lt;T&gt;.EmptySet, Set&lt;S&gt;.EmptySet) == false.
            </summary>
        </member>
        <member name="M:NModel.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Construct a set containing all enumerated elements
            </summary>
            <param name="elements">The enumerable object containing the elements that will be members of the set</param>
        </member>
        <member name="M:NModel.Set`1.#ctor(`0[])">
            <summary>
            Construct a set from the elements given in the argument list
            </summary>
            <param name="elements">The argument list</param>
        </member>
        <member name="P:NModel.Set`1.Count">
            <summary>
            Returns the number of elements in the set (also known as the cardinality of the set). [Time: 1]
            </summary>
        </member>
        <member name="M:NModel.Set`1.Contains(`0)">
            <summary>
            Tests whether the given element is found in the set.
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the <paramref name="item"/> is in this set, false otherwise.</returns>
            <remarks>
            Complexity: O(log(this.Count))
            </remarks>
        </member>
        <member name="M:NModel.Set`1.IsSubsetOf(NModel.Set{`0})">
            <summary>
            Subset relation
            </summary>
            <param name="t">The superset</param>
            <returns>True if this every element of this set is also found in set <paramref name="t"/>; false otherwise.</returns>
        </member>
        <member name="M:NModel.Set`1.IsProperSubsetOf(NModel.Set{`0})">
            <summary>
            Proper subset relation
            </summary>
            <param name="t">The superset</param>
            <returns>True if this every element of this set is found in set <paramref name="t"/>
            and there exists at least one element in <paramref name="t"/> that is not found in this set; 
            false otherwise.</returns>
        </member>
        <member name="M:NModel.Set`1.IsSupersetOf(NModel.Set{`0})">
            <summary>
            Superset relation
            </summary>
            <param name="t"></param>
            <returns>True if this every element of set <paramref name="t"/> is also found in this set; false otherwise.</returns>
        </member>
        <member name="M:NModel.Set`1.IsProperSupersetOf(NModel.Set{`0})">
            <summary>
            Proper superset relation
            </summary>
            <param name="t">The subset</param>
            <returns>True if this every element of set <paramref name="t"/> is also found in this set
            and there exists at least one element in this set that is not found in <paramref name="t"/>; 
            false otherwise.</returns>
        </member>
        <member name="M:NModel.Set`1.Remove(`0)">
            <summary>
            Returns a new set containing every element of this set except the value given as a parameter.
            If value is not in this set, then returns this set. [Time: log(this.Count)]
            </summary>
            <param name="value">The value to be deleted.</param>
            <returns>The new set that does not contain <paramref name="value"/>.</returns>
        </member>
        <member name="M:NModel.Set`1.Add(`0)">
            <summary>
            Returns a new set with all of the elements of this set, plus the value given as an argument [Time: log(this.Count)]
            </summary>
            <param name="value">The value to add</param>
            <returns>The new set containing <paramref name="value"/>.</returns>
        </member>
        <member name="M:NModel.Set`1.ToString">
            <summary>
            Pretty printer
            </summary>
            <returns>A human-readable representation of the this set.</returns>
        </member>
        <member name="M:NModel.Set`1.op_Addition(NModel.Set{`0},NModel.Set{`0})">
            <summary>
            Set union [Time: max(s.Count,t.Count)*log(max(s.Count, t.Count))]
            </summary>
            <param name="s">A set</param>
            <param name="t">A set</param>
            <returns>The set containing all the elements from both <paramref name="s"/> and <paramref name="t"/></returns>
        </member>
        <member name="M:NModel.Set`1.Union(NModel.Set{`0})">
            <summary>
            Same as operator + (set union). 
            </summary>
            <param name="t">A set to be unioned with this set</param>
            <returns>The set containing all the elements from both <paramref name="this"/> and <paramref name="t"/></returns>
        </member>
        <member name="M:NModel.Set`1.op_Subtraction(NModel.Set{`0},NModel.Set{`0})">
            <summary>
            Set difference [Time: t.Count * log(s.Count)] 
            </summary>
            <param name="s">The set containing potentially unwanted elements</param>
            <param name="t">The set of unwanted elements</param>
            <returns>The set containing all the elements from <paramref name="s"/> that are not in <paramref name="t"/></returns>
        </member>
        <member name="M:NModel.Set`1.Difference(NModel.Set{`0})">
            <summary>
            Set difference. Same as operator -
            </summary>
            <param name="t">The set of unwanted elements to be removed from this set</param>
            <returns>The set containing all the elements from this that are not in <paramref name="t"/></returns>
        </member>
        <member name="M:NModel.Set`1.op_Multiply(NModel.Set{`0},NModel.Set{`0})">
            <summary>
            Set intersection  [Time: max(s.Count,t.Count)*log(max(s.Count, t.Count))]
            </summary>
            <param name="s">A set</param>
            <param name="t">A set</param>
            <returns>The set of all elements that are shared in common by <paramref name="s"/> and <paramref name="t"/></returns>
        </member>
        <member name="M:NModel.Set`1.Intersect(NModel.Set{`0})">
            <summary>
            Set intersection. Same as operator *.  [Time: max(s.Count,t.Count)*log(max(s.Count, t.Count))]
            </summary>
            <param name="t">A set to be intersected with this set.</param>
            <returns>The set of all elements shared by this and t</returns>
        </member>
        <member name="M:NModel.Set`1.BigUnion(NModel.Set{NModel.Set{`0}})">
            <summary>
            Distributed set union. [Time: s1.Count * s2.Count * ... * sn.Count where n is the number of sets in s]
            </summary>
            <param name="s">A set of sets to be combined by set union</param>
            <returns>The union of all the sets in <paramref name="s"/>. That is, the set containing all the elements 
            of all the elements of <paramref name="s"/>. </returns>
        </member>
        <member name="M:NModel.Set`1.BigIntersect(NModel.Set{NModel.Set{`0}})">
            <summary>
            Distributed Intersection: The resulting set is the intersection of all the elements of s, 
            i.e. it contains the elements that are in all elements [Time: max(s.Count,t.Count)*log(s.Count,t.Count)]
            </summary>
            <param name="s">A set of sets to be combined by set intersection</param>
            <returns>The intersection of all the sets in s. That is, the set containing only those elements 
            that are shared by all of the elements of s</returns>
        </member>
        <member name="M:NModel.Set`1.GetEnumerator">
            <summary>
            Enumerator of each element of this set. If two sets are equal, then their enumerations are in the same order.
            (This is a fixed order with no external significance.)
            </summary>
            <returns>The enumerator of this set</returns>
        </member>
        <member name="M:NModel.Set`1.Convert``1(System.Converter{`0,``0})">
            <summary>
            Transforms a set of one sort to a set of another sort by invoking a given delegate on each element. 
            If the mapping is injective, then the number of elements in the result will be the same as the number
            of elements in this. Otherwise, (if not injective) the number of elements will be fewer.
            </summary>
            <typeparam name="S">The sort of the result</typeparam>
            <param name="converter">A pure (side-effect free) function that maps an element of T to an element of S</param>
            <returns>The set</returns>
            <example>
            This example projects a set of strings into a set of integers by taking the length of each string. 
            Note that the number of elements in the result is smaller than the original set because some of 
            the strings are of the same length.
            <code>
            void SetConvertExample()
            {
               Set&lt;string&gt; set1 = new Set&lt;string&gt;("abc", "def", "g", "h", "i", "j", "klm");
               Set&lt;int&gt; expected = new Set&lt;int&gt;(1, 3);
               Set&lt;int&gt; actual = set1.Convert(delegate(string s) { return (s != null ? s.Length : 0); });
               
               Assert.AreEqual(expected, actual);
            }
            </code>
            </example>
        </member>
        <member name="M:NModel.Set`1.Select(System.Predicate{`0})">
            <summary>
            Applies <paramref name="selector"/> to each element of this set and collects all values where 
            the selector function returns true.
            </summary>
            <param name="selector">A Boolean-valued delegate that acts as the inclusion test. True means
            include; false means exclude.</param>
            <returns>The set of all elements of this set that satisfy the <paramref name="selector"/></returns>
        </member>
        <member name="M:NModel.Set`1.InvariantHolds">
            <summary>
            Checks that internal assumptions in the implementation of sets hold for this set. 
            Used for debugging and verification only.
            </summary>
            <returns>true</returns>
        </member>
        <member name="P:NModel.Set`1.CountSubsets">
            <summary>
            Returns the number of subsets of this set or System.Int32.MaxValue if the number of
            subsets exceeds the representation of System.Int32.
            </summary>
        </member>
        <member name="M:NModel.Set`1.ChooseSubset(System.Int32)">
            <summary>
            Returns a chosen subset of this set, with externally provided choice given by <paramref name="i"/>. 
            </summary>
            <param name="i">An nonnegative integer that is less than <c>this.CountSubsets</c>, or an arbitrary integer. Integers
            within the range of [0, this.CountSubsets) will enumerate subsets; outside this range will choose an arbitrary 
            subset.</param>
            <returns>The chosen subset</returns>
        </member>
        <member name="M:NModel.Set`1.ChooseSubset">
            <summary>
            Returns an arbitrarily chosen subset of this set. This is not a pure function; successive calls
            will produce differing values and update the internal state of <seealso cref="P:NModel.Internals.HashAlgorithms.GlobalChoiceController"/>.
            </summary>
            <returns>A subset of this set</returns>
        </member>
        <member name="M:NModel.Set`1.ChooseNonemptySubset(System.Int32)">
            <summary>
            Returns a chosen nonempty subset of this set, with externally provided choice given by <paramref name="i"/>. 
            </summary>
            <param name="i">An nonnegative integer that is less than <c>this.CountSubsets - 1</c>, or an arbitrary integer. Integers
            within the range of [0, this.CountSubsets - 1) will enumerate nonempty subsets; outside this range will choose an arbitrary 
            subset.</param>
            <returns>The chosen subset</returns>
        </member>
        <member name="M:NModel.Set`1.ChooseNonemptySubset">
            <summary>
            Returns an arbitrarily chosen nonempty subset of this set. This is not a pure function; successive calls
            will produce differing values and update the internal state of <seealso cref="P:NModel.Internals.HashAlgorithms.GlobalChoiceController"/>.
            This set must nonempty.
            </summary>
            <returns>A subset of this set</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the number of elements in this set is not in the interval [1, 30].</exception>
        </member>
        <member name="M:NModel.Set`1.AllSubsets">
            <summary>
            Enumerates the subsets of this set.
            </summary>
            <returns>An IEnumerable that will return each possible subset of this set</returns>
            <remarks>The enumeration created by method has exponential complexity, O(2 ^ this.Count). </remarks>
            <exception cref="T:System.InvalidOperationException">Thrown if the number of elements in this set is not in the interval [0, 30].</exception>
        </member>
        <member name="T:NModel.Triple`3">
            <summary>
            Triples with structural equality.
            </summary>
        </member>
        <member name="P:NModel.Triple`3.First">
            <summary>
            The first element
            </summary>
        </member>
        <member name="P:NModel.Triple`3.Second">
            <summary>
            The second element
            </summary>
        </member>
        <member name="P:NModel.Triple`3.Third">
            <summary>
            The third element
            </summary>
        </member>
        <member name="M:NModel.Triple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of a triple with the given arguments
            </summary>
        </member>
        <member name="M:NModel.Triple`3.Equals(System.Object)">
            <summary>
            True, if value is a triple and is structurally equal to this, false otherwise 
            </summary>
        </member>
        <member name="M:NModel.Triple`3.GetHashCode">
            <summary>
            Hash code (computed structurally)
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:NModel.Triple`3.op_Equality(NModel.Triple{`0,`1,`2},NModel.Triple{`0,`1,`2})">
            <summary>
            Structural equality
            </summary>
            <param name="x">The first value</param>
            <param name="y">The second value</param>
            <returns>True if <paramref name="x"/> is structurally equivalent to <paramref name="y"/>, false otherwise.</returns>
        </member>
        <member name="M:NModel.Triple`3.op_Inequality(NModel.Triple{`0,`1,`2},NModel.Triple{`0,`1,`2})">
            <summary>
            Structural inequality
            </summary>
            <param name="x">The first value</param>
            <param name="y">The second value</param>
            <returns>False if <paramref name="x"/> is structurally equivalent to <paramref name="y"/>, true otherwise.</returns>
        </member>
        <member name="M:NModel.Triple`3.op_LessThan(NModel.Triple{`0,`1,`2},NModel.Triple{`0,`1,`2})">
            <summary>
            Term less than
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is less than <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.Triple`3.op_LessThanOrEqual(NModel.Triple{`0,`1,`2},NModel.Triple{`0,`1,`2})">
            <summary>
            Term less than or equal
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is less than or equal <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.Triple`3.op_GreaterThan(NModel.Triple{`0,`1,`2},NModel.Triple{`0,`1,`2})">
            <summary>
            Term greater than
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is greater than <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.Triple`3.op_GreaterThanOrEqual(NModel.Triple{`0,`1,`2},NModel.Triple{`0,`1,`2})">
            <summary>
            Term greater than or equal
            </summary>
            <param name="o1">The first value</param>
            <param name="o2">The second value</param>
            <returns>True if <paramref name="o1"/> is greater than or equal <paramref name="o2"/> 
            under term ordering and false otherwise.</returns>
        </member>
        <member name="M:NModel.Triple`3.ToString">
            <summary>
            Formats this triple as "Triple&lt;T1,T2,T2&gt;(first, second, third)"
            </summary>
            <returns>The formatted string</returns>
        </member>
        <member name="M:NModel.Triple`3.CompareTo(System.Object)">
            <summary>
            Term order. Comparision is pairwise using the term ordering of <see cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />.
            </summary>
            <param name="obj"></param>
            <returns>-1 if less than, 0 if equal, 1 if greater than</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="obj"/> is not of the same type as this triple.</exception>
            <seealso cref="M:NModel.Internals.HashAlgorithms.CompareValues(System.Object,System.Object)" />
        </member>
        <member name="P:NModel.Triple`3.AsTerm">
            <summary>
            Returns the term representation of this value.
            </summary>
        </member>
        <member name="M:NModel.Triple`3.FinalizeImport">
            <summary>
            Called internally to distinguish between reserve elements that are part of state and 
            those in the background set of values. Not used directly in models.
            </summary>
        </member>
        <member name="M:NModel.Triple`3.ContainsObjectIds">
            <summary>
            Determines if this value has an object id (that is, is of type <see cref="T:NModel.Internals.LabeledInstance"/>),
            or has a subvalue that has an object id (for example, a set of instances).
            </summary>
            <returns>True if this value has an object id or contains a value with an object id.</returns>
        </member>
        <member name="T:NModel.Execute">
            <summary>
            Static class with callbacks into the execution framework. Used for recording coverage points.
            </summary>
        </member>
        <member name="M:NModel.Execute.AddCoveragePoint(NModel.Terms.Term)">
            <summary>
            Signals execution framework that a user-defined coverage point has been passed. Coverage points
            may be used to guide execution so that relevant aspects of the model are represented in
            analysis and testing. For example, coverage points may include user-level requirements, projections
            of the current state or execution paths of the model program source.
            </summary>
            <param name="coveragePoint">A term representing a user-defined coverage point.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="coveragePoint"/> is null</exception>
        </member>
        <member name="M:NModel.Execute.AddCoveragePoint(System.IComparable)">
            <summary>
            Signals execution framework that a user-defined coverage point has been passed. Coverage points
            may be used to guide execution so that relevant aspects of the model are represented in
            analysis and testing. For example, coverage points may include user-level requirements, projections
            of the current state or execution paths of the model program source.
            </summary>
            <param name="coveragePointValue">A value whose corresponding term is a user-defined coverage point.</param>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="coveragePointValue"/> does not satisfy the 
            <see cref="M:NModel.Internals.AbstractValue.IsAbstractValue(System.Object)"/> condition</exception>
            <seealso cref="M:NModel.Internals.AbstractValue.GetTerm(System.IComparable)"/>
        </member>
        <member name="P:NModel.Execute.Features">
            <summary>
            The set of feature keywords that apply in the current execution context.
            </summary>
        </member>
        <member name="T:NModel.Attributes.AbstractAttribute">
            <summary>
            The [Abstract] attribute may be applied to definitions of enums and classes. It indicates
            that the objects of the attributed enum or class will be considered abstract, i.e. they will not have an ordering.
            It is useful when using the state isomorphism based state space reduction.
            </summary>
        </member>
        <member name="M:NModel.Attributes.AbstractAttribute.#ctor">
            <summary>
            Constructor of the [Abstract] attribute.        
            </summary>
        </member>
        <member name="T:NModel.Attributes.AcceptingStateConditionAttribute">
            <summary>
            The [AcceptingStateCondition] attribute can be applied to a method or a property. 
            The method or property to which the attribute is applied must be Boolean and static.
            The conjunction of all the accepting state conditions, when evaluated in a given state,
            determines if the state is an accepting state or not.
            </summary>
        </member>
        <member name="M:NModel.Attributes.AcceptingStateConditionAttribute.#ctor">
            <summary>
            Constructor of the accepting state condition attribute. 
            </summary>
        </member>
        <member name="T:NModel.Attributes.ActionAttribute">
            <summary>
            The [Action] attribute may be applied to methods. It indicates that the method is a model action.
            The containing class must have a [Model] attribute.
            </summary>
        </member>
        <member name="M:NModel.Attributes.ActionAttribute.#ctor">
            <summary>
            Constructor of the [Action] attribute. The action name will be the name of the attributed method.        
            </summary>
        </member>
        <member name="M:NModel.Attributes.ActionAttribute.#ctor(System.String)">
            <summary>
            Constructor of the [Action] attribute.
            </summary>
            <param name="name">The name of the action. This does not have to be the same as the
            name of the method being attributed by this attribute.</param>
        </member>
        <member name="P:NModel.Attributes.ActionAttribute.Name">
            <summary>
            The name of the action.
            </summary>
        </member>
        <member name="P:NModel.Attributes.ActionAttribute.Start">
            <summary>
            The name of the Start action
            </summary>
        </member>
        <member name="P:NModel.Attributes.ActionAttribute.Finish">
            <summary>
            The name of the Finish action
            </summary>
        </member>
        <member name="P:NModel.Attributes.ActionAttribute.Weight">
            <summary>
            
            </summary>
        </member>
        <member name="T:NModel.Attributes.DomainAttribute">
            <summary>
            <para>The [Domain] attribute may be applied to a parameter of an action method to indicate the possible
            values that may appear as arguments. The attribute gives the name of a Set-valued method or get-property 
            defined in the current class. The method may be instance-based or static.</para> 
            <para>The method that contains the attributed parameter must have the [Action] attribute, or an
            error will occur.</para>
            <para>Only one [Domain] or [New] attribute may be used for a parameter.</para>
            </summary>
        </member>
        <member name="M:NModel.Attributes.DomainAttribute.#ctor(System.String)">
            <summary>
            Constructor of the [Domain] attribute.
            </summary>
            <param name="name">The name of a method or property defined by the current class.</param>
        </member>
        <member name="P:NModel.Attributes.DomainAttribute.Name">
            <summary>
            Name of the domain
            </summary>
        </member>
        <member name="T:NModel.Attributes.ExcludeFromStateAttribute">
            <summary>
            Indicates that a field is not a model variable.
            </summary>
        </member>
        <member name="T:NModel.Attributes.FeatureAttribute">
            <summary>
            The [Feature] attribute may be applied to a class to group related state variables and actions. The [Feature] attribute
            includes the name of the Feature. A [Feature] attribute (with the same Feature name) may appear on multiple classes.
            This is a way to group related classes. When loading a LibraryModelProgram, the features to be included
            may be configured.
            </summary>
        </member>
        <member name="M:NModel.Attributes.FeatureAttribute.#ctor">
            <summary>
            Constructor of the [Feature] attribute. The Feature name defaults to the name of the target class.
            </summary>
        </member>
        <member name="M:NModel.Attributes.FeatureAttribute.#ctor(System.String)">
            <summary>
            Constructor of the [Feature] attribute.
            </summary>
            <param name="name">The Feature name.</param>
        </member>
        <member name="P:NModel.Attributes.FeatureAttribute.Name">
            <summary>
            The name of the Feature.
            </summary>
        </member>
        <member name="T:NModel.Attributes.HideFromViewerAttribute">
            <summary>
            Don't show this field in the FSM viewer.
            </summary>
        </member>
        <member name="T:NModel.Attributes.RequirementAttribute">
            <summary>
            The [Requirement] attribute may be applied to any .NET attributable element. It includes
            a reference to the informal requirement upon which the model element is based. Requirement 
            strings provide traceability back to the informal requirement documents. They are printed in
            error contexts such as conformance failures and state invariant violations. They can also be 
            used to check for coverage of requirements. More than one [Requirement] attribute may be
            provided for any entity.
            
            In order to use the Requirements metrics,
            the requirements attributed should only be added to action and guard(enabled) methods!
            </summary>
        </member>
        <member name="P:NModel.Attributes.RequirementAttribute.AllRequirementsInModels">
            <summary>
            Returns a Set of all the requirements in the models
            </summary>
        </member>
        <member name="M:NModel.Attributes.RequirementAttribute.#ctor(System.String,System.String)">
            <summary>
            Constructor of the [Requirement] attribute that gets 2 strings.
            First: ID, Second: Description
            </summary>        
            <param name="id">The requirement id.</param>  
            <param name="documentation">The requirement description.</param>
        </member>
        <member name="M:NModel.Attributes.RequirementAttribute.#ctor(System.String)">
            <summary>
            Constructor of the [Requirement] attribute that gets 1 string.
            String: Description
            </summary>        
            <param name="documentation">The requirement description.</param>
        </member>
        <member name="P:NModel.Attributes.RequirementAttribute.Id">
            <summary>
            The id string for this requirement.
            </summary>
        </member>
        <member name="P:NModel.Attributes.RequirementAttribute.Documentation">
            <summary>
            The documentation string for this requirement.
            </summary>
        </member>
        <member name="T:NModel.Attributes.ScenarioAttribute">
            <summary>
            Indicates that an action method is never enabled for top-level execution. Instead, it may only 
            be invoked as a subaction using the <seealso cref="T:NModel.Execute"/> class.
            </summary>
        </member>
        <member name="T:NModel.Attributes.SplitAttribute">
            <summary>
            <para>The [Split] attribute indicates that an action method will be split into "start" and "finish"
            transitions. In this case the start transition contains the method's input parameters (including byref
            parameters) as arguments. The finish transition contains the method's outputs (return value, 
            byref arguments and output arguments) as parameters.</para>
            <para>If the [Split] attribute is not provided, then methods with no outputs (void return value and 
            no byref or out parameters) will not be split. Methods with outputs are always split.
            </para>
            <para>An error occurs if the [Split] attribute is used for an action method that has a non-void return
            value or has byref or out arguments.</para>
            <para>An error occurs if the [Action] attribute is not present whenever the [Split] attribute is used.</para>
            </summary>
            <note>The typical use case for this attribute is to mark actions that have no outputs (for example, in 
            scenario model programs) as split so that they will combine with actions of another model program 
            that may contain output parameters.</note>
        </member>
        <member name="T:NModel.Attributes.StateFilterAttribute">
            <summary>
            The [StateFilter] attribute can be applied to a method or a property. 
            It indicates that its target method or property is a state filter.
            The value true indicates that the state will be included during exploration;
            the value false means that the state will be excluded from exploration.
            State filters can be used in conjunction with a [Feature] attribute 
            so that they can be selectively applied.
            </summary>
        </member>
        <member name="M:NModel.Attributes.StateFilterAttribute.#ctor">
            <summary>
            Constructor of the state filter attribute. 
            </summary>
        </member>
        <member name="T:NModel.Attributes.StateInvariantAttribute">
            <summary>
            The [StateInvariant] attribute can be applied to a method or a property. 
            It specifies a property that must hold in every model state.
            </summary>
        </member>
        <member name="M:NModel.Attributes.StateInvariantAttribute.#ctor">
            <summary>
            Constructor of the accepting state condition attribute. 
            </summary>
        </member>
        <member name="T:NModel.Attributes.TransitionPropertyAttribute">
            <summary>
            The [TransitionProperty] attribute may be applied to methods, properties or fields. It indicates that the
            method, property or field should be evaluated at the end of a model step and reported as a named
            property. 
            </summary>
            <seealso cref="M:NModel.Execution.ModelProgram.GetTargetState(NModel.Execution.IState,NModel.Terms.CompoundTerm,NModel.Set{System.String},NModel.Execution.TransitionProperties@)"/>
        </member>
        <member name="M:NModel.Attributes.TransitionPropertyAttribute.#ctor">
            <summary>
            Constructor of the [TransitionProperty] attribute. The transition property name will be the 
            name of the attributed method, property or field.        
            </summary>
        </member>
        <member name="M:NModel.Attributes.TransitionPropertyAttribute.#ctor(System.String)">
            <summary>
            Constructor of the [TransitionProperty] attribute.
            </summary>
            <param name="name">The name of the transition property.</param>
        </member>
        <member name="P:NModel.Attributes.TransitionPropertyAttribute.Name">
            <summary>
            The name of the transition property.
            </summary>
        </member>
        <member name="T:NModel.Attributes.SortAttribute">
            <summary>
            The [Sort] attribute indicates the "sort" (abstract type) of a type. It may be applied
            to a class or an enum declaration.
            </summary>
        </member>
        <member name="M:NModel.Attributes.SortAttribute.#ctor(System.String)">
            <summary>
            Constructor of the [Sort] attribute.
            </summary>
            <param name="name">The name of the sort.</param>
        </member>
        <member name="P:NModel.Attributes.SortAttribute.Name">
            <summary>
            The name of the sort.
            </summary>
        </member>
        <member name="T:NModel.ValueArray`1">
            <summary>
            Immutable type that provides structural equality for arrays.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NModel.ValueArray`1.#ctor(`0[])">
            <summary>
            Constructs a value array with given contents
            </summary>
        </member>
        <member name="M:NModel.ValueArray`1.Contents">
            <summary>
            The contents of the value array. Note: the caller must never modfiy this array.
            </summary>
        </member>
        <member name="P:NModel.ValueArray`1.Count">
            <summary>
            Returns the number of elements in the collection value.
            </summary>
        </member>
        <member name="P:NModel.ValueArray`1.Length">
            <summary>
            Number of elements in the value array
            </summary>
        </member>
        <member name="M:NModel.ValueArray`1.Contains(`0)">
            <summary>
            Tests whether the given element is found in the value array.
            </summary>
            <param name="item">The item to find</param>
            <returns>True, if the <paramref name="item"/> is in this value array, false otherwise.</returns>
            <remarks>
            Complexity: O(this.Count)
            </remarks>
        </member>
        <member name="P:NModel.ValueArray`1.Item(System.Int32)">
            <summary>
            Returns the i'th element
            </summary>
        </member>
        <member name="M:NModel.ValueArray`1.GetEnumerator">
            <summary>
            Enumerate the values
            </summary>
        </member>
        <member name="M:NModel.ValueArray`1.Convert``1(System.Converter{`0,``0})">
            <summary>
            Convert the value array to values of type T using the given converter
            </summary>
        </member>
        <member name="M:NModel.ValueArray`1.Select(System.Predicate{`0})">
            <summary>
            Applies <paramref name="selector"/> to each element of this array and collects all values where 
            the selector function returns true.
            </summary>
            <param name="selector">A Boolean-valued delegate that acts as the inclusion test. True means
            include; false means exclude.</param>
            <returns>The array of all elements of this array that satisfy the <paramref name="selector"/>. Order of
            selected elements is preserved.</returns>
        </member>
        <member name="M:NModel.ValueArray`1.Choose(System.Int32)">
            <summary>
            Select an arbitrary value from the collection, with external choice.
            </summary>
            <param name="i">An externally chosen integer in the interval [0, this.Count).</param>
            <returns>An element of the collection.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <paramref name="i"/> is outside 
            the interval [0, this.Count).</exception>
            <remarks>As a pure function, this method will always return the same value 
            for each pair of arguments (<paramref name="this"/> and <paramref name="i"/>).</remarks>
        </member>
        <member name="T:NModel.Terms.Action">
            <summary>
            Instances of this class are actions.
            Actions are compound terms.
            </summary>
        </member>
        <member name="M:NModel.Terms.Action.#ctor(NModel.Terms.Symbol,NModel.Sequence{NModel.Terms.Term})">
            <summary>
            Constructs an action for a  given action symbol and sequence of arguments.
            </summary>
            <param name="f">action symbol</param>
            <param name="args">arguments of the action</param>
        </member>
        <member name="M:NModel.Terms.Action.#ctor(NModel.Terms.Symbol,NModel.Terms.Term[])">
            <summary>
            Constructs an action for a  given action symbol and a params array of arguments.
            </summary>
            <param name="f">action symbol</param>
            <param name="args">arguments of the action</param>
        </member>
        <member name="M:NModel.Terms.Action.Create(System.String,System.IComparable[])">
            <summary>
            Utility function to create an action from a string name
            and a params array of values. 
            Values that are not terms are converted to terms.
            </summary>
            <param name="name">The name of the action symbol</param>
            <param name="args">The .NET values to be converted to terms.</param>
            <returns>The created action</returns>
        </member>
        <member name="M:NModel.Terms.Action.Parse(System.String)">
            <summary>
            Parse the string into an action.
            </summary>
            <param name="s">given string representing of an action</param>
            <returns>action represented by the string</returns>
        </member>
        <member name="T:NModel.Terms.Any">
            <summary>
            A term that denotes a fresh logic variable in every context where it occurs.
            
            The Any term is denoted by "_"
            </summary>
        </member>
        <member name="F:NModel.Terms.Any.v">
            <summary>
            A term that denotes a distinct logic variable in each context where it occurs 
            </summary>
        </member>
        <member name="P:NModel.Terms.Any.Value">
            <summary>
            Constructor for the "Any" term. This term denotes a distinct logic variable 
            in each context where it occurs.
            </summary>
        </member>
        <member name="P:NModel.Terms.Any.IsGround">
            <summary>
            True if term consists only of concrete terms, false otherwise (that is, when the
            term contains one or more logic variables)
            </summary>
        </member>
        <member name="P:NModel.Terms.Any.FunctionSymbol">
            <summary>
            The function symbol. For term f(1, 2), f is the function symbol.
            </summary>
        </member>
        <member name="P:NModel.Terms.Any.Arguments">
            <summary>
            Returns an empty sequence of arguments.
            </summary>
        </member>
        <member name="M:NModel.Terms.Any.ToString">
            <summary>
            Pretty printing
            </summary>
            <returns>The string "_"</returns>
        </member>
        <member name="M:NModel.Terms.Any.ToCompactString">
            <summary>
            Same as ToString()
            </summary>
        </member>
        <member name="T:NModel.Terms.CompoundTerm">
            <summary>
            A compound term is a syntactic structure composed of a function symbol applied to zero or term arguments.
            
                  f(t1, t2, t3, ...)
            
            </summary>
        </member>
        <member name="M:NModel.Terms.CompoundTerm.#ctor(NModel.Terms.Symbol,NModel.Terms.Term[])">
            <summary>
            Constructs a compound term, a syntactic structure composed of a function symbol applied
            to zero or term arguments.
            
                  f(t1, t2, t3, ...)
            
            </summary>
            <param name="functionSymbol">The function symbol</param>
            <param name="arguments">The arguments</param>
        </member>
        <member name="M:NModel.Terms.CompoundTerm.Create(System.String,System.IComparable[])">
            <summary>
            Utility function to create an compound term from a string <paramref name="name"/>
            and arguments. The arguments will be converted to term representations.
            An argument that is alredy a term is not coverted but left as is.
            </summary>
            <param name="name">The name of the function symbol.</param>
            <param name="args">The .NET values to be converted to terms.</param>
            <returns>The created compound term</returns>
        </member>
        <member name="M:NModel.Terms.CompoundTerm.#ctor(NModel.Terms.Symbol,NModel.Sequence{NModel.Terms.Term})">
            <summary>
            Constructs a compound term, a syntactic structure composed of a function symbol applied
            to zero or term arguments.
            
                  f(t1, t2, t3, ...)
            
            </summary>
            <param name="functionSymbol">The function symbol</param>
            <param name="arguments">The arguments</param>
        </member>
        <member name="P:NModel.Terms.CompoundTerm.IsGround">
            <summary>
            True if term consists only of concrete terms, false otherwise (that is, when the
            term contains one or more logic variables)
            </summary>
        </member>
        <member name="P:NModel.Terms.CompoundTerm.FunctionSymbol">
            <summary>
            The function symbol as an IComparable. For term f(1, 2), f is the function symbol.
            </summary>
        </member>
        <member name="P:NModel.Terms.CompoundTerm.Symbol">
            <summary>
            The function symbol. For term f(1, 2), f is the function symbol.
            Gets the symbol as a <see cref="P:NModel.Terms.CompoundTerm.Symbol"/> rather than 
            upcasting it to <see cref="T:System.IComparable"/>.
            </summary>
        </member>
        <member name="P:NModel.Terms.CompoundTerm.Arguments">
            <summary>
            Gets the sequence of arguments of this compound term
            </summary>
        </member>
        <member name="M:NModel.Terms.CompoundTerm.ToString">
            <summary>
            Pretty printing of terms
            </summary>
            <returns>A string in the form f(t1, t2, ...)</returns>
        </member>
        <member name="M:NModel.Terms.CompoundTerm.ToCompactString">
            <summary>
            Pretty printing of terms with function symbols that do not indidate underlying .Net type
            </summary>
            <returns>A string in the form f(t1, t2, ...)</returns>
        </member>
        <member name="M:NModel.Terms.CompoundTerm.Parse(System.String)">
            <summary>
            Parse the string into a compound term.
            </summary>
            <param name="s">given string representing a compound term</param>
            <returns>compound term represented by the string</returns>
        </member>
        <member name="M:NModel.Terms.CompoundTerm.Substitute(NModel.Map{NModel.Terms.Variable,NModel.Terms.Term})">
            <summary>
            Apply the given substitution to this term.
            All the variables in this term that appear in the 
            substitution are replaced by the terms the variables 
            are mapped to by the substitution.
            </summary>
        </member>
        <member name="M:NModel.Terms.CompoundTerm.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization (implementation of <see cref="T:System.Runtime.Serialization.ISerializable"/>).
            </summary>
            <param name="info">Serialization data record</param>
            <param name="context">Serialization context</param>
        </member>
        <member name="P:NModel.Terms.CompoundTerm.Name">
            <summary>
            The string name of the function symbol
            </summary>
        </member>
        <member name="P:NModel.Terms.CompoundTerm.Item(System.Int32)">
            <summary>
            Gets the interpretation of the k'th argument
            </summary>
        </member>
        <member name="T:NModel.Terms.Term">
            <summary>
            A syntactic entity
            </summary>
        </member>
        <member name="P:NModel.Terms.Term.IsGround">
            <summary>
            True if term consists only of concrete terms, false otherwise (that is, when the
            term contains one or more logic variables)
            </summary>
        </member>
        <member name="P:NModel.Terms.Term.FunctionSymbol">
            <summary>
            The function symbol. For term f(1, 2), f is the function symbol.
            </summary>
        </member>
        <member name="P:NModel.Terms.Term.Arguments">
            <summary>
            A sequence of the arguments of this term. For term f(1, 2), 1 and 2 are the arguments.
            </summary>
        </member>
        <member name="M:NModel.Terms.Term.ToCompactString">
            <summary>
            Pretty printing of terms with function symbols that do not indidate underlying .Net type
            Used for viewing in State Viewer.
            </summary>
        </member>
        <member name="M:NModel.Terms.Term.Parse(System.String)">
            <summary>
            Reads a string like "f(1, "abc", File(1))" and returns the corresponding abstract syntax tree. 
            </summary>
            <param name="representation">The text representation of the term</param>
            <returns>The abstract syntax tree representation of the term</returns>
        </member>
        <member name="M:NModel.Terms.Term.Substitute(NModel.Map{NModel.Terms.Variable,NModel.Terms.Term})">
            <summary>
            Replace all the variables in this term with terms given by the substitution
            </summary>
        </member>
        <member name="T:NModel.Terms.Literal">
            <summary>
            A syntactic unit that denotes a .NET literal (string, int, double, bool, etc.)
            </summary>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.Boolean)">
            <summary>
            Constructs a Literal term from a bool
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.Byte)">
            <summary>
            Constructs a Literal term from a byte
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.Char)">
            <summary>
            Constructs a Literal term from a char
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.Double)">
            <summary>
            Constructs a Literal term from a double
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.Single)">
            <summary>
            Constructs a Literal term from a float
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.Int32)">
            <summary>
            Constructs a Literal term from an int
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.Int64)">
            <summary>
            Constructs a Literal term from a long
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.Int16)">
            <summary>
            Constructs a Literal term from a short
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.String)">
            <summary>
            Constructs a Literal term from a string
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.Enum)">
            <summary>
            Constructs a Literal term from a ushort
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="M:NModel.Terms.Literal.#ctor(System.IComparable)">
            <summary>
            Constructs a Literal term from a built-in type.
            </summary>
            <param name="value">The .NET literal</param>
        </member>
        <member name="P:NModel.Terms.Literal.Value">
            <summary>
            The literal value (in terms of a .NET type).
            </summary>
        </member>
        <member name="P:NModel.Terms.Literal.FunctionSymbol">
            <summary>
            The function symbol. For term f(1, 2), f is the function symbol.
            </summary>
        </member>
        <member name="P:NModel.Terms.Literal.Arguments">
            <summary>
            
            </summary>
        </member>
        <member name="P:NModel.Terms.Literal.IsGround">
            <summary>
            True if term consists only of concrete terms, false otherwise (that is, when the
            term contains one or more logic variables)
            </summary>
        </member>
        <member name="M:NModel.Terms.Literal.ToString">
            <summary>
            The print representation of the Literal
            </summary>
            <returns>The literal value</returns>
        </member>
        <member name="M:NModel.Terms.Literal.ToCompactString">
            <summary>
            The compact print representation of a literal is the same as ToString() of the literal
            </summary>
        </member>
        <member name="T:NModel.Terms.Symbol">
            <summary>
            Function symbol. This syntactic element is the first entry of a <see cref="T:NModel.Terms.CompoundTerm"/>. 
            A symbol is not itself a term.
            </summary>
        </member>
        <member name="F:NModel.Terms.Symbol.domainParameters">
            <summary>
            If null, indicates a nongeneric type.
            If the empty sequence, indicates a generic type definition
            If nonempty, indicates an instantiated generic type
            </summary>
        </member>
        <member name="M:NModel.Terms.Symbol.FieldValues">
            <summary>
            Returns the name and then the domain parameters
            </summary>
        </member>
        <member name="M:NModel.Terms.Symbol.#ctor(System.String)">
            <summary>
            Constructs a symbol
            </summary>
            <param name="name">The symbol name</param>
        </member>
        <member name="M:NModel.Terms.Symbol.#ctor(System.String,NModel.Terms.Symbol[])">
            <summary>
            Constructs a symbol with given name and domain parameters
            </summary>
        </member>
        <member name="M:NModel.Terms.Symbol.#ctor(System.String,NModel.Sequence{NModel.Terms.Symbol})">
            <summary>
            Constructs a symbol with given name and domain parameters
            </summary>
        </member>
        <member name="M:NModel.Terms.Symbol.Parse(System.String)">
            <summary>
            Parses a symbol from the given string
            </summary>
        </member>
        <member name="P:NModel.Terms.Symbol.Name">
            <summary>
            The string name of the "name" component of the symbol
            </summary>
        </member>
        <member name="P:NModel.Terms.Symbol.ShortName">
            <summary>
            The string name of the "name" component of the symbol.
            </summary>
        </member>
        <member name="P:NModel.Terms.Symbol.DomainParameters">
            <summary>
            The domain parameters component of the symbol. These are used to give generic sorts.
            </summary>
        </member>
        <member name="P:NModel.Terms.Symbol.FullName">
            <summary>
            The string name of the symbol. This is includes both the "name" component and the "suffix"
            </summary>
        </member>
        <member name="M:NModel.Terms.Symbol.ToString">
            <summary>
            Pretty printing
            </summary>
            <returns>Prints the symbol name</returns>
        </member>
        <member name="T:NModel.Terms.TermReader">
            <summary>
            Reads a string like "f(1, "abc", File(1))" and returns the corresponding term. 
            </summary>
        </member>
        <member name="M:NModel.Terms.TermReader.Read(System.String)">
            <summary>
            Reads a string like "f(1, "abc", File(1))" and returns the corresponding abstract syntax tree. 
            </summary>
            <param name="str">The text representation of the term</param>
            <returns>The abstract syntax tree representation of the term</returns>
        </member>
        <member name="M:NModel.Terms.TermReader.Write(NModel.Terms.Term)">
            <summary>
            Prints a string "f(1, "abc", File(1))" given the abstract syntax representation of a term.
            </summary>
            <param name="term">The abstract syntax tree representation of the term</param>
            <returns>The text representation of the term</returns>
        </member>
        <member name="T:NModel.Terms.TermReader.ReadException">
            <summary>
            Internal class for signalling syntax errors
            </summary>
        </member>
        <member name="T:NModel.Terms.TermReader.Buffer">
            <summary>
            Represents a string stream
            </summary>
        </member>
        <member name="M:NModel.Terms.TermReader.Buffer.IsDelimited">
            <summary>
            Is next char EOF, whitespace or a separator char?
            </summary>
            <returns></returns>
        </member>
        <member name="T:NModel.Terms.TermReader.Token">
            <summary>
            Token produced by the scanner. Consists of (kind, stringValue, source position)
            </summary>
        </member>
        <member name="M:NModel.Terms.TermReader.Tokenize(System.String)">
            <summary>
            Lexical analysis on the input string
            </summary>
            <param name="str">The text representation of the term</param>
            <returns>List of tokens contained</returns>
            <exception cref="T:NModel.Terms.TermReader.ReadException">Thrown if lexical error found</exception>
        </member>
        <member name="M:NModel.Terms.TermReader.Scan(NModel.Terms.TermReader.Buffer,System.Boolean@)">
            <summary>
            Produces the next token from the stream
            </summary>
            <param name="b">The string stream</param>
            <param name="error">Set to true if a lexical error occurs</param>
            <returns>The next token in the stream</returns>
        </member>
        <member name="T:NModel.Terms.TermReader.Parser">
            <summary>
            Parser for terms
            </summary>
        </member>
        <member name="T:NModel.Terms.TermReader.Parser.SyntaxErrorException">
            <summary>
            Indicates a syntax error
            </summary>
        </member>
        <member name="T:NModel.Terms.Variable">
            <summary>
            A term that denotes a named logic variable
            </summary>
        </member>
        <member name="M:NModel.Terms.Variable.#ctor(System.String)">
            <summary>
            Construct a logical variable as a nonground term
            </summary>
        </member>
        <member name="P:NModel.Terms.Variable.Name">
            <summary>
            Gets the name of the variable.
            </summary>
        </member>
        <member name="P:NModel.Terms.Variable.IsGround">
            <summary>
            True if term consists only of concrete terms, false otherwise (that is, when the
            term contains one or more logic variables)
            </summary>
        </member>
        <member name="P:NModel.Terms.Variable.FunctionSymbol">
            <summary>
            Returns the name of the variable.
            </summary>
        </member>
        <member name="P:NModel.Terms.Variable.Arguments">
            <summary>
            Returns the empty sequence
            </summary>
        </member>
        <member name="M:NModel.Terms.Variable.ToString">
            <summary>
            Pretty printing
            </summary>
            <returns>The variable name</returns>
        </member>
        <member name="M:NModel.Terms.Variable.ToCompactString">
            <summary>
            Same as ToString()
            </summary>
        </member>
        <member name="M:NModel.Terms.Variable.Substitute(NModel.Map{NModel.Terms.Variable,NModel.Terms.Term})">
            <summary>
            Returns the term given by the substitution if this variable 
            appears in the substitution, returns this variable otherwise.
            </summary>
        </member>
        <member name="T:NModel.Utilities.ArgumentType">
            <summary>
            Used to control parsing of command line arguments.
            </summary>
        </member>
        <member name="F:NModel.Utilities.ArgumentType.Required">
            <summary>
            Indicates that this field is required. An error will be displayed
            if it is not present when parsing arguments.
            </summary>
        </member>
        <member name="F:NModel.Utilities.ArgumentType.Unique">
            <summary>
            Only valid in conjunction with Multiple.
            Duplicate values will result in an error.
            </summary>
        </member>
        <member name="F:NModel.Utilities.ArgumentType.Multiple">
            <summary>
            Inidicates that the argument may be specified more than once.
            Only valid if the argument is a collection
            </summary>
        </member>
        <member name="F:NModel.Utilities.ArgumentType.AtMostOnce">
            <summary>
            The default type for non-collection arguments.
            The argument is not required, but an error will be reported if it is specified more than once.
            </summary>
        </member>
        <member name="F:NModel.Utilities.ArgumentType.LastOccurenceWins">
            <summary>
            For non-collection arguments, when the argument is specified more than
            once no error is reported and the value of the argument is the last
            value which occurs in the argument list.
            </summary>
        </member>
        <member name="F:NModel.Utilities.ArgumentType.MultipleUnique">
            <summary>
            The default type for collection arguments.
            The argument is permitted to occur multiple times, but duplicate 
            values will cause an error to be reported.
            </summary>
        </member>
        <member name="F:NModel.Utilities.ArgumentType.AtLeastOnce">
            <summary>
            The default type for non-collection arguments.
            The argument is not required, but an error will be reported if it is specified more than once.
            </summary>
        </member>
        <member name="T:NModel.Utilities.ArgumentAttribute">
            <summary>
            Allows control of command line parsing.
            Attach this attribute to instance fields of types used
            as the destination of command line argument parsing.
            </summary>
        </member>
        <member name="M:NModel.Utilities.ArgumentAttribute.#ctor(NModel.Utilities.ArgumentType)">
            <summary>
            Allows control of command line parsing.
            </summary>
            <param name="type"> Specifies the error checking to be done on the argument. </param>
        </member>
        <member name="P:NModel.Utilities.ArgumentAttribute.Type">
            <summary>
            The error checking to be done on the argument.
            </summary>
        </member>
        <member name="P:NModel.Utilities.ArgumentAttribute.DefaultShortName">
            <summary>
            Returns true if the argument did not have an explicit short name specified.
            </summary>
        </member>
        <member name="P:NModel.Utilities.ArgumentAttribute.ShortName">
            <summary>
            The short name of the argument.
            Set to null means use the default short name if it does not
            conflict with any other parameter name.
            Set to String.Empty for no short name.
            This property should not be set for DefaultArgumentAttributes.
            </summary>
        </member>
        <member name="P:NModel.Utilities.ArgumentAttribute.DefaultLongName">
            <summary>
            Returns true if the argument did not have an explicit long name specified.
            </summary>
        </member>
        <member name="P:NModel.Utilities.ArgumentAttribute.LongName">
            <summary>
            The long name of the argument.
            Set to null means use the default long name.
            The long name for every argument must be unique.
            It is an error to specify a long name of String.Empty.
            </summary>
        </member>
        <member name="P:NModel.Utilities.ArgumentAttribute.DefaultValue">
            <summary>
            The default value of the argument.
            </summary>
        </member>
        <member name="P:NModel.Utilities.ArgumentAttribute.HasDefaultValue">
            <summary>
            Returns true if the argument has a default value.
            </summary>
        </member>
        <member name="P:NModel.Utilities.ArgumentAttribute.HasHelpText">
            <summary>
            Returns true if the argument has help text specified.
            </summary>
        </member>
        <member name="P:NModel.Utilities.ArgumentAttribute.HelpText">
            <summary>
            The help text for the argument.
            </summary>
        </member>
        <member name="T:NModel.Utilities.DefaultArgumentAttribute">
            <summary>
            Indicates that this argument is the default argument.
            '/' or '-' prefix only the argument value is specified.
            The ShortName property should not be set for DefaultArgumentAttribute
            instances. The LongName property is used for usage text only and
            does not affect the usage of the argument.
            </summary>
        </member>
        <member name="M:NModel.Utilities.DefaultArgumentAttribute.#ctor(NModel.Utilities.ArgumentType)">
            <summary>
            Indicates that this argument is the default argument.
            </summary>
            <param name="type"> Specifies the error checking to be done on the argument. </param>
        </member>
        <member name="T:NModel.Utilities.ErrorReporter">
            <summary>
            A delegate used in error reporting.
            </summary>
        </member>
        <member name="T:NModel.Utilities.Parser">
             <summary>
             Parser for command line arguments.
            
             The parser specification is infered from the instance fields of the object
             specified as the destination of the parse.
             Valid argument types are: int, uint, string, bool, enums
             Also argument types of Array of the above types are also valid.
             
             Error checking options can be controlled by adding a ArgumentAttribute
             to the instance fields of the destination object.
            
             At most one field may be marked with the DefaultArgumentAttribute
             indicating that arguments without a '-' or '/' prefix will be parsed as that argument.
            
             If not specified then the parser will infer default options for parsing each
             instance field. The default long name of the argument is the field name. The
             default short name is the first character of the long name. Long names and explicitly
             specified short names must be unique. Default short names will be used provided that
             the default short name does not conflict with a long name or an explicitly
             specified short name.
            
             Arguments which are array types are collection arguments. Collection
             arguments can be specified multiple times.
             </summary>
        </member>
        <member name="F:NModel.Utilities.Parser.NewLine">
            <summary>
            The System Defined new line string.
            </summary>
        </member>
        <member name="M:NModel.Utilities.Parser.ParseArgumentsWithUsage(System.String[],System.Object)">
            <summary>
            Parses Command Line Arguments. Displays usage message to Console.Out
            if /?, /help or invalid arguments are encounterd.
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.ParseArgumentsWithUsage(System.String[],System.Type)">
            <summary>
            Parses Command Line Arguments. Displays usage message to Console.Out
            if /?, /help or invalid arguments are encounterd.
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.ParseArguments(System.String[],System.Object)">
            <summary>
            Parses Command Line Arguments. 
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.ParseArguments(System.String[],System.Type)">
            <summary>
            Parses Command Line Arguments. 
            Errors are output on Console.Error.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.ParseArguments(System.String[],System.Object,NModel.Utilities.ErrorReporter)">
            <summary>
            Parses Command Line Arguments. 
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <param name="reporter"> The destination for parse errors. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.ParseArguments(System.String[],System.Type,NModel.Utilities.ErrorReporter)">
            <summary>
            Parses Command Line Arguments. 
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="arguments"> The actual arguments. </param>
            <param name="destination"> The resulting parsed arguments. </param>
            <param name="reporter"> The destination for parse errors. </param>
            <returns> true if no errors were detected. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.ParseHelp(System.String[])">
            <summary>
            Checks if a set of arguments asks for help.
            </summary>
            <param name="args"> Args to check for help. </param>
            <returns> Returns true if args contains /? or /help. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.ArgumentsUsage(System.Type)">
            <summary>
            Returns a Usage string for command line argument parsing.
            Use ArgumentAttributes to control parsing behaviour.
            Formats the output to the width of the current console window.
            </summary>
            <param name="argumentType"> The type of the arguments to display usage for. </param>
            <returns> Printable string containing a user friendly description of command line arguments. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.ArgumentsUsage(System.Type,System.Int32)">
            <summary>
            Returns a Usage string for command line argument parsing.
            Use ArgumentAttributes to control parsing behaviour.
            </summary>
            <param name="argumentType"> The type of the arguments to display usage for. </param>
            <param name="columns"> The number of columns to format the output to. </param>
            <returns> Printable string containing a user friendly description of command line arguments. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.IndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>
            Searches a StringBuilder for a character
            </summary>
            <param name="text"> The text to search. </param>
            <param name="value"> The character value to search for. </param>
            <param name="startIndex"> The index to stat searching at. </param>
            <returns> The index of the first occurence of value or -1 if it is not found. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.LastIndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>
            Searches a StringBuilder for a character in reverse
            </summary>
            <param name="text"> The text to search. </param>
            <param name="value"> The character to search for. </param>
            <param name="startIndex"> The index to start the search at. </param>
            <returns>The index of the last occurence of value in text or -1 if it is not found. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.#ctor(System.Type,NModel.Utilities.ErrorReporter)">
            <summary>
            Creates a new command line argument parser.
            </summary>
            <param name="argumentSpecification"> The type of object to  parse. </param>
            <param name="reporter"> The destination for parse errors. </param>
        </member>
        <member name="M:NModel.Utilities.Parser.ParseArgumentList(System.String[],System.Object)">
            <summary>
            Parses an argument list into an object
            </summary>
            <param name="args"></param>
            <param name="destination"></param>
            <returns> true if an error occurred </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.Parse(System.String[],System.Object)">
            <summary>
            Parses an argument list.
            </summary>
            <param name="args"> The arguments to parse. </param>
            <param name="destination"> The destination of the parsed arguments. </param>
            <returns> true if no parse errors were encountered. </returns>
        </member>
        <member name="M:NModel.Utilities.Parser.GetUsageString(System.Int32)">
            <summary>
            A user firendly usage string describing the command line argument syntax.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Parser.HasDefaultArgument">
            <summary>
            Does this parser have a default argument.
            </summary>
            <value> Does this parser have a default argument. </value>
        </member>
        <member name="T:NModel.Utilities.Graph.GraphDirection">
            <summary>
            Describes the direction of graph layout.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphDirection.TopToBottom">
            <summary>
            Layout direction is from top to bottom
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphDirection.LeftToRight">
            <summary>
            Layout direction is from left to right
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphDirection.RightToLeft">
            <summary>
            Layout direction is from right to left
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphDirection.BottomToTop">
            <summary>
            Layout direction is from bottom to top
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.StateShape">
            <summary>
            Possible shapes of states
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.StateShape.Box">
            <summary>
            Rectangular box
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.StateShape.Circle">
            <summary>
            Round circle
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.StateShape.Diamond">
            <summary>
            Diamond
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.StateShape.Ellipse">
            <summary>
            Ellipse
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.StateShape.Octagon">
            <summary>
            Octagon
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.StateShape.Plaintext">
            <summary>
            Plain text with no surrounding border
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.TransitionLabel">
            <summary>
            Determines what is shown as a transition label.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.TransitionLabel.None">
            <summary>
            Label is omitted.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.TransitionLabel.ActionSymbol">
            <summary>
            Action symbol is shown.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.TransitionLabel.Action">
            <summary>
            Full action is shown.
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.CustomLabelProvider">
            <summary>
            Delegate that maps an IState to a string that is used to label it.
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.StateProvider">
            <summary>
            Delegate that maps a term to a model program state
            </summary>
            <param name="state">given term</param>
            <returns>corresponding model program state</returns>
        </member>
        <member name="T:NModel.Utilities.Graph.MultiLabeledTransition">
            <summary>
            Represents transitions that may have multiple labels
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.MultiLabeledTransition.StartState">
            <summary>
            Start state of the transition (readonly)
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.MultiLabeledTransition.EndState">
            <summary>
            End state of the transition (readonly)
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.MultiLabeledTransition.CreateOnePerLabel">
            <summary>
            Enumerate all the labels in this multilabeled transition as 
            multilabeled transition with a single label
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.MultiLabeledTransition.Create(NModel.Terms.Term,NModel.Terms.Term,NModel.Terms.Term,NModel.Terms.Term)">
            <summary>
            Create a multilabeled transition with a compound label, if labelOut is non-null, the label is 
            considered as a Mealy label with an input part labelIn and an output part labelOut
            </summary>
            <param name="startState">given start state</param>
            <param name="labelIn">input part of the label</param>
            <param name="labelOut">output part of the label</param>
            <param name="endState">given end state</param>
        </member>
        <member name="M:NModel.Utilities.Graph.MultiLabeledTransition.Create(NModel.Terms.Term,NModel.Terms.Term,NModel.Terms.Term)">
            <summary>
            Create a multilabeled transition with the given input label. 
            Same as MultiLabeledTransition.Create(startState, labelIn, null, endState)
            </summary>
            <param name="startState">given start state</param>
            <param name="labelIn">given label</param>
            <param name="endState">given end state</param>
        </member>
        <member name="M:NModel.Utilities.Graph.MultiLabeledTransition.AddMealyLabel(NModel.Terms.Term,NModel.Terms.Term)">
            <summary>
            Add another compound Mealy label to the multilabeled transition
            </summary>
            <param name="labelIn">input part of the label</param>
            <param name="labelOut">output part of the label</param>
        </member>
        <member name="M:NModel.Utilities.Graph.MultiLabeledTransition.AddLabel(NModel.Terms.Term)">
            <summary>
            Add another label to the multilabeled transition
            </summary>
            <param name="labelIn">the label to add</param>
        </member>
        <member name="M:NModel.Utilities.Graph.MultiLabeledTransition.CombinedLabel(System.Boolean)">
            <summary>
            Create a combined string representation of all the labels with
            '\n' separating the different strings of the individual (compound) labels
            </summary>
            <param name="nameOnly">if true uses only the action names and ignores parameters</param>
        </member>
        <member name="M:NModel.Utilities.Graph.MultiLabeledTransition.GetActionLabel(NModel.Terms.CompoundTerm,NModel.Terms.CompoundTerm)">
            <summary>
            Formats an action for display in the view.
            </summary>
            <param name="start">Optional start action with input arguments.</param>
            <param name="finish">Optional finish action with output arguments and return value.</param>
            <returns>A nicely formatted string representing the action(s).</returns>
        </member>
        <member name="M:NModel.Utilities.Graph.MultiLabeledTransition.GetArgumentLabel(NModel.Sequence{NModel.Terms.Term})">
            <summary>
            Gets a comma-separated list of arguments as a string for use in an action label.
            </summary>
            <param name="arguments">Argument list.</param>
            <returns>String of the arguments.</returns>
        </member>
        <member name="T:NModel.Utilities.Graph.GraphParams">
            <summary>
            A class that is used as a parameter for generating Graphviz dot representation of an FSM.
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.GraphParams.#ctor(System.String,NModel.FSM)">
            <summary>
            The constructor that initializes the parameters using a name and a FSM.
            </summary>
            <param name="name">Name of the FSM.</param>
            <param name="fa"></param>
        </member>
        <member name="T:NModel.Utilities.Graph.DotWriter">
            <summary>
            Class for generating Graphviz dot fromat from finite state machines.
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.DotWriter.RunWithCommandLineArguments(System.String[])">
            <summary>
            A method that is used by the command line interface.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:NModel.Utilities.Graph.DotWriter.ToDot(NModel.Utilities.Graph.GraphParams)">
            <summary>
            Produce dot output of the graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Utilities.Graph.DotWriter.ToDotShape(NModel.Utilities.Graph.StateShape)">
            <summary>
            Map a state shape to corresponding dot node shape
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.CommandLineViewer">
            <summary>
            Represents a commandline utility that starts up mp2dot and writes out dot script for
            a product composition of provided model programs.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.CommandLineViewer.StateTooltipVars">
            <summary>
            A string that holds the list of state-variables that the user wants to be seen in the tooltips
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.CommandLineViewer.RunWithCommandLineArguments(System.String[])">
            <summary>
            Provides programmatic access to the commandline utility 'mp2dot.exe'.
            </summary>
            <param name="args">command line arguments: model program(s), optional settings for the viewer</param>
            <remarks>The settings are displayed when 'mpv.exe /?' is executed from the command line without arguments.</remarks>
        </member>
        <member name="T:NModel.Utilities.Graph.Color">
            <summary>Use this Color type for Dot instead of System.Drawing.Color</summary>
        </member>
        <member name="F:NModel.Utilities.Graph.Color.color">
            <summary>color name string</summary>
        </member>
        <member name="M:NModel.Utilities.Graph.Color.#ctor(System.String)">
            <summary>Constructor, parameter is color name string</summary>
        </member>
        <member name="M:NModel.Utilities.Graph.Color.FromName(System.String)">
            <summary>Similar to constructor, make Color from color name string</summary>
        </member>
        <member name="T:NModel.Utilities.Graph.DummyGraphViewForm">
            <summary>
            Used for creating an object, NOT a Windows form, that contains the GraphView instance
             This class plays similar role in mp2dot and NModel.Utilities.Graph 
             that class ModelProgramGraphViewForm plays in mpv and NModel.Visualization
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.DummyGraphViewForm.View">
            <summary>
            GraphView instance in DummyGraphViewForm
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.DummyGraphViewForm.#ctor(System.String)">
            <summary>
            Creates an object, not a Windows form, containing the GraphView instance.
            </summary>
            <param name="title">used as the title of the form if title != null</param>
        </member>
        <member name="T:NModel.Utilities.Graph.ExploredTransitions">
            <summary>
            Represents the explored part of the model program
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.ExploredTransitions.IsActionVisible(NModel.Terms.Term,NModel.Terms.CompoundTerm)">
            <summary>
            Returns true if the action is a label of a visible transition from the given node
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.ExploredTransitions.ShowTransition(NModel.Terms.Term,NModel.Terms.CompoundTerm)">
            <summary>
            Show the transition with the given action from the given state
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.ExploredTransitions.ShowOutgoing(NModel.Terms.Term)">
            <summary>
            Show all transitions from the given node
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.ExploredTransitions.HideOutgoing(NModel.Terms.Term)">
            <summary>
            Hide all previously shown transitions from the given node
            </summary>
            <param name="node">given node</param>
        </member>
        <member name="M:NModel.Utilities.Graph.ExploredTransitions.HideTransition(NModel.Terms.Term,NModel.Terms.CompoundTerm)">
            <summary>
            Hide the transition with the given action from the given node
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.ExploredTransitions.HideAll(NModel.Terms.Term,NModel.Terms.Symbol)">
            <summary>
            Hide all previously shown transitions with te given action symbol from the given node
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.ExploredTransitions.HideReachable(NModel.Terms.Term)">
            <summary>
            Hide all previously shown transitions from the given node
            and those that can be reached recursively
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.GraphView">
            <summary>
            Displays a finite state machine graph.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.exploredTransitions">
            <summary>
            Explored part of the model program
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.GraphView.SetModelProgram(NModel.Execution.ModelProgram)">
            <summary>
            Sets the initial state of the view 
            </summary>
            <param name="modelProgram1">given model program to be viewed</param>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.finiteAutomatonContext">
            <summary>
            Current context regarding which finite automaton is being viewed.
            Is a reduct of the top level machine.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.faInfo">
            <summary>
            Info regarding the top level FA that was set.
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.GraphView.#ctor">
            <summary>
            Creates a new graph giew
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.GraphView.SetStateMachine(NModel.FSM,NModel.Utilities.Graph.StateProvider)">
            <summary>
            View the given state machine
            </summary>
            <param name="fa">given finite automaton</param>
            <param name="stateProvider">optional model program state provider</param>
        </member>
        <member name="M:NModel.Utilities.Graph.GraphView.SetStateMachine(NModel.FSM,NModel.Utilities.Graph.StateProvider,NModel.Execution.ModelProgram,NModel.Set{NModel.Triple{NModel.Terms.Term,NModel.Terms.CompoundTerm,NModel.Terms.Term}})">
            <summary>
            Used internally by the derived viewer that may also set the modelprogram
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.GraphView.CustomLabelProvider">
            <summary>
            Delegate that maps a finite automata state to a string that is 
            used to label it.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.CustomStateLabelProvider">
            <summary>
            Function that maps a finite auomaton state to a string label used 
            instead of the default label that is the state id.
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.GraphView.FAInfo">
            <summary>
            Represents info about the original (top-level) FA
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.GraphView.ReductName">
            <summary>
            Represents the name of a reduct FA
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.nodes">
            <summary>
            Dictionary of nodes to be drawn by dot, after preprocessing by graphWorker.
            Based on nodes in NModel.Visualization GraphView
            Key of dictionary here is just incrementing integers
            NO THAT DIDN'T WORK - got duplicate values.  
            So let's use *same* item for both key and value
            Use Dictionary not Set because MultiLabeledTransition (below) is apparently not IComparable
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.transitions">
            <summary>
            Dictionary of transitions to be drawn by dot, after preprocessing by graphWorker.
            Based transitions in NModel.Visualization GraphView
            Key of dictionary here is just incrementing integers
            Use Dictionary not Set because MultiLabeledTransition (below) is apparently not IComparable
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.GraphView.graphWorker">
            <summary>
            Pre-process graph data before calling ToDot
            Reads data in finiteAutomatonContext, writes the two sets nodes and transitions
            Based on NModel.Visualization GraphView graphWorker_DoWork
            Comment out all uses of GLEE, events, and threads
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.GraphView.ToDot">
            COPIED FROM NModel.Visualization  GraphView ToDot
            contains: foreach (Node node in this.nodes.Values) ...
            <summary>
            Produce dot output of the graph
            </summary>
            <returns></returns>
        </member>
        <member name="M:NModel.Utilities.Graph.GraphView.DefaultNodeTooltip(NModel.Execution.IState)">
            <summary>
            Display the values of state variables        
            
            Copied from: NModel.Visualization.GraphView
            With the addition of the filtering abilities:
            [HideFromViewer] attribute and StateTooltipVars
            
            TO DO: Add new-line to separate the variables for readiness ("/n" doesn't work)
            </summary>
        </member>
        <member name="M:NModel.Utilities.Graph.GraphView.AddNodeTooltip(System.Text.StringBuilder,NModel.Terms.Term)">
            <summary>
            Add tooltip with state variables values
            
            </summary>
            <param name="sb"></param>
            <param name="node"></param>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.transitionLabels">
            <summary>
            Determines what is shown as a transition label.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.TransitionLabels">
            <summary>
            Determines what is shown as a transition label.
            </summary>
            DELETE following attributes used in GraphView.Settings.cs, intended to support GUI
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.nodeLabelsVisible">
            <summary>
            Visibility of node labels. Default is true.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.NodeLabelsVisible">
            <summary>
            Visibility of node labels. Default is true.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.initialStateColor">
            <summary>
            Background color of the initial state. Default is LightGray.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.InitialStateColor">
            <summary>
            Background color of the initial state. Default is LightGray.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.hoverColor">
            <summary>
            Line and action label color to use when edges or nodes are hovered over. Default is Lime.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.HoverColor">
            <summary>
            Line and action label color to use when edges or nodes are hovered over. Default is Lime.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.selectionColor">
            <summary>
            Background color to use when a node is selected. Default is Blue.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.SelectionColor">
            <summary>
            Background color to use when a node is selected. Default is Blue.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.livenessCheckIsOn">
            <summary>
            Mark states from which no accepting state is reachable in the current view. Default is false.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.LivenessCheckIsOn">
            <summary>
            Mark states from which no accepting state is reachable in the current view. Default is false.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.deadStateColor">
            <summary>
            The background color of dead states.
            Dead states are states from which no accepting state is reachable.
            Default is Yellow.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.DeadStateColor">
            <summary>
            The background color of dead states.
            Dead states are states from which no accepting state is reachable.
            Default is Yellow.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.safetyCheckIsOn">
            <summary>
            Whether to mark states that violate a state invariant. Default is false.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.SafetyCheckIsOn">
            <summary>
            Whether to mark states that violate a state invariant. Default is false.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.unsafeStateColor">
            <summary>
            Background color of states that violate a safety condition (state invariant). Default is Red.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.UnsafeStateColor">
            <summary>
            Background color of states that violate a safety condition (state invariant). Default is Red.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.maxTransitions">
            <summary>
            Maximum number of transitions to draw in the graph. Default is 100.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.MaxTransitions">
            <summary>
            Maximum number of transitions to draw in the graph. Default is 100.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.loopsVisible">
            <summary>
            Visibility of transitions whose start and end states are the same. Default is true.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.LoopsVisible">
            <summary>
            Visibility of transitions whose start and end states are the same. Default is true.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.deadstatesVisible">
            <summary>
            Visibility of of dead states. Default is true.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.DeadstatesVisible">
            <summary>
            Visibility of of dead states. Default is true.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.mergeLabels">
            <summary>
            Multiple transitions between same start and end states are shown as one transition with a merged label. Default is true.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.MergeLabels">
            <summary>
            Multiple transitions between same start and end states are shown as one transition with a merged label. Default is true.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.acceptingStatesMarked">
            <summary>
            Mark accepting states with a bold outline. Default is true.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.AcceptingStatesMarked">
            <summary>
            Mark accepting states with a bold outline. Default is true.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.stateShape">
            <summary>
            State shape. Default is Ellipse.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.StateShape">
            <summary>
            State shape. Default is Ellipse.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.direction">
            <summary>
            Direction of graph layout. Default is TopToBottom.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.Direction">
            <summary>
            Direction of graph layout. Default is TopToBottom.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.combineActions">
            <summary>
            Whether to view start actions and finish actions as single transitions. Default is false.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.CombineActions">
            <summary>
            Whether to view start actions and finish actions as single transitions. Default is false.
            </summary>
            <remarks>
            The default value is <c>false</c>, meaning that adjacent start/finish actions are not collapsed into a single edge.
            </remarks>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.Transitions">
            <summary>
            Shows the number of explored transitions
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.States">
            <summary>
            Shows the number of explored states
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.AcceptingStates">
            <summary>
            Shows the number of accepting states
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.DeadStates">
            <summary>
            Shows the number of dead states
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.UnsafeStates">
            <summary>
            Shows the number of unsafe states
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.excludeIsomorphicStates">
            <summary>
            Whether to discard isomorphic states when traversing the state space. Default is false.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.ExcludeIsomorphicStates">
            <summary>
            Whether to discard isomorphic states when traversing the state space. Default is false.
            </summary>
            <remarks>
            The default value is <c>false</c>, meaning that no isomorphism checks are performed.
            </remarks>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.CollapseExcludedIsomorphicStates">
            <summary>
            Whether to group isomorphic states together. Default is false.
            </summary>
            <remarks>
            The default value is <c>false</c>, meaning that no isomorphic states are not grouped. Has meaning only when <c>ExcludeIsomorphicStates</c> is <c>true</c>;
            </remarks>
        </member>
        <member name="F:NModel.Utilities.Graph.GraphView.initialTransitions">
            <summary>
            Number of transitions that are explored initially up to maxTransitions. Negative value implies no bound. Default is -1.
            </summary>
        </member>
        <member name="P:NModel.Utilities.Graph.GraphView.InitialTransitions">
            <summary>
            Number of transitions that are explored initially up to MaxTransitions. Negative value implies no bound. Default is -1.
            </summary>
        </member>
        <member name="T:NModel.Utilities.Graph.NodeLabel">
            <summary>
            Determines what is shown as a node label.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.NodeLabel.None">
            <summary>
            Label is omitted.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.NodeLabel.Id">
            <summary>
            Abstract Id is shown.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.NodeLabel.ControlMode">
            <summary>
            Control mode is shown.
            </summary>
        </member>
        <member name="F:NModel.Utilities.Graph.NodeLabel.StateVariables">
            <summary>
            All state variable values are shown.
            </summary>
        </member>
        <member name="T:NModel.Utilities.ReflectionHelper">
            <summary>
            Some helper functions commonly used to retrieve information through reflection.
            </summary>
        </member>
        <member name="F:NModel.Utilities.ReflectionHelper.modelBindingFlags">
            <summary>
            Flags used for accessing all members and types
            </summary>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.FindType(System.Collections.Generic.ICollection{System.Reflection.Assembly},System.String)">
            <summary>
            Find the given type in one of the libraries.
            </summary>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.FindMethod(System.Type,System.String,System.Type[],System.Type)">
            <summary>
            Find the method with the given name, given input argument types in the given type, that returns a value that implements the given interface type or subtype
            </summary>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.SplitFullMethodName(System.String,System.String@,System.String@)">
            <summary>
            Splits a fully qualified name typeName.methodName of a static method to its constituents,
            where typeName and methodName are nonempty strings.
            Assumes that fullName != null.
            </summary>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.IsCompilerGenerated(System.Reflection.MemberInfo)">
            <summary>
            Is <paramref name="m"/> an internal member like an iterator generated by the compiler?
            </summary>
            <param name="m">member info</param>
            <returns>True if <paramref name="m"/> is an internal, compiler-generated member info.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetMethodsForActions(System.Type)">
            <summary>
            Enumerate methods of type <paramref name="t"/> that have an associated <c>ActionAttribute</c>.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.HasActionAttribute(System.Reflection.MethodInfo)">
            <summary>
            Does <paramref name="method"/> have at least one [Action] attribute?
            </summary>
            <param name="method">The method</param>
            <returns>True if <paramref name="method"/> is an action method</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetModelActionAttributes(System.Reflection.MethodInfo)">
            <summary>
            Iterates through the [Action] attributes of <paramref name="method"/>
            </summary>
            <param name="method">The method</param>
            <returns>Enumerated [Action] attributes</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.TrimDigits(System.String)">
            <summary>
            Removes trailing digits 0..9 from a string
            </summary>
            <param name="s">The string</param>
            <returns>The trimmed string</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetEnablingConditionMethods(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Iterates through the enabling condition methods of <paramref name="actionMethod"/>. Each
            enabling condition is any method defined in the same class as <paramref name="actionMethod"/>
            whose name is <paramref name="actionMethod"/>.Name + "Enabled" + zero or more digits. Enabling conditions methods
            must return type <c>System.Boolean</c> and have a parameter list whose types are a prefix
            of <paramref name="inputParameters"/>
            </summary>
            <param name="actionMethod">The action method</param>
            <param name="inputParameterTypes">The input parameter types of <paramref name="actionMethod"/>, including
            the implicit <c>this</c> parameter if <paramref name="actionMethod"/> is an instance method.</param>
            <returns>Enumerated enabling condition methods.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetEnablingConditionDocumentation(System.Reflection.MemberInfo)">
            <summary>
            Get descriptions of all requirement attributes attached to the member info.
            </summary>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetEnablingMethodsRequirements(System.Reflection.MemberInfo)">
            <summary>
            Get ids and descriptions of all requirement attributes attached to the member info.
            </summary>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetEnablingMethods(System.Reflection.MethodInfo)">
            <summary>
            Return the enabling methods for a given action-method
            </summary>
            <param name="actionMethod"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetRequirementsInMethod(System.Reflection.MemberInfo)">
            <summary>
            Get ids and descriptions of all requirement attributes attached to the member info.
            </summary>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.ParametersArePrefix(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Are the input parameter types of <paramref name="methodInfo"/> a prefix of 
            the sequence <paramref name="inputParameterTypes"/>?
            </summary>
            <param name="methodInfo">The method</param>
            <param name="inputParameterTypes">The input types</param>
            <returns>True if prefix, false otherwise</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.HasNoOutputs(System.Reflection.MethodInfo)">
            <summary>
            Does the method have a nonvoid return value, out parameters or byref parameters? In other words,
            does the method return any outputs?
            </summary>
            <param name="method">The method</param>
            <returns>True if there are no outputs, false if some outputs exist.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.IsOutputParameter(System.Reflection.ParameterInfo)">
            <summary>
            Is the parameter an output or byref parameter? 
            </summary>
            <param name="pInfo">The parameter</param>
            <returns>True if the parameter is an output</returns>
            <remarks>Note:in the case of a ref parameter it is both input and output.</remarks>
        </member>
        <member name="P:NModel.Utilities.ReflectionHelper.HiddenVars">
            <summary>
            The list of the state variables that should be hidden from the viewer
            </summary>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.IsModelVariable(System.Reflection.FieldInfo)">
            <summary>
            Is the field a model variable?
            </summary>
            <param name="field">The field</param>
            <returns>True, if <paramref name="field"/> is a model variable.</returns>
            <remarks>A field is a model variable if all of the following conditions hold
            <list>
            <item>there is no [ExcludeFromState] attribute</item>
            <item>its type is not a compiler-generated type</item>
            <item>the field is not a compile-time constant</item>
            <item>the field is not a static readonly field</item>
            <item>the field is not a member of a compound value</item>
            </list>
            </remarks>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetModelVariables(System.Type)">
            <summary>
            Iterate through the model variables of a class.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.IsInModel(System.Type,System.String,NModel.Set{System.String})">
            <summary>
            Is the type <paramref name="t"/> included in the model <paramref name="modelName"/>?
            Additionally, if <paramref name="t"/> has one or more [Feature] attributes and 
            <paramref name="featureNames"/> is nonnull, does <paramref name="t"/> have a 
            [Feature] attribute whose name is found in <paramref name="featureNames"/>?
            </summary>
            <param name="t">The type to be tested</param>
            <param name="modelName">The name of the model</param>
            <param name="featureNames">Null if all features are to be included, or a nonnull set of
            feature names to be included.</param>
            <returns>True if <paramref name="t"/> is part of the model and feature set.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetActionLabel(System.Reflection.MethodInfo,NModel.Attributes.ActionAttribute,NModel.Terms.CompoundTerm@,NModel.Terms.CompoundTerm@)">
            <summary>
            Calculate the start and end action labels from an [Action] attribute
            </summary>
            <param name="method">The action method</param>
            <param name="actionAttribute">The action attribute of <paramref name="method"/></param>
            <param name="startActionLabel">Output parameter that returns the calculated start action label</param>
            <param name="finishActionLabel">Output parameter that returns the calculated finish action label. Null 
            if there is no fnish action label.</param>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.IsInputParameter(System.Reflection.ParameterInfo)">
            <summary>
            Does the parameter provide an input?
            </summary>
            <param name="pInfo">The parameter</param>
            <returns>True if the parameter provides an input.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetInputParameterTypes(System.Reflection.MethodInfo)">
            <summary>
            Get an array of types that represents the inputs to the method.
            </summary>
            <param name="methodInfo">The method</param>
            <returns>An array of input types, in the same order as their corresponding parameters. The implicit
            <c>this</c> argument is included in the array for instance methods.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetInputParameterNames(System.Reflection.MethodInfo)">
            <summary>
            Get an array of names that identify the inputs to the method.
            </summary>
            <param name="methodInfo">The method</param>
            <returns>An array of string names, in the same order as their corresponding parameters. The implicit
            <c>this</c> argument is included in the array for instance methods.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetOutputParameterTypes(System.Reflection.MethodInfo)">
            <summary>
            Get an array of types that represents the outputs of the method
            </summary>
            <param name="actionMethod">The method</param>
            <returns>An array of output types, return value type followed by the output parameter types, 
            in parameter-list order.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetOutputParameterNames(System.Reflection.MethodInfo)">
            <summary>
            Get an array of names that identify the outputs to the method.
            </summary>
            <param name="methodInfo">The method</param>
            <returns>An array of string names, in the same order as their corresponding parameters. The return
            value (if present) is given the name "result".</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetInputParameterIndices(NModel.Terms.CompoundTerm,System.Reflection.MethodInfo)">
            <summary>
            Computes the mapping from the parameter positions of the action label to the 
            parameter positions of the .NET method that implements the action.
            </summary>
            <param name="actionLabel"></param>
            <param name="actionMethod"></param>
            <returns>An array of integers where each entry is the index in the parameter list
            of the .NET method. The special value -1 is used to indicate the implicit "this"
            argument of an instance method.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.GetOutputParameterIndices(NModel.Terms.CompoundTerm,System.Reflection.MethodInfo)">
            <summary>
            Computes the mapping from the parameter positions of the action label to the 
            output parameter positions of the .NET method that implements the action.
            </summary>
            <param name="actionLabel">The finish action label</param>
            <param name="actionMethod">The action method</param>
            <returns>An array of integers where each entry is the index in the parameter list
            of the .NET method. The special value -1 is used to indicate the position of the the
            return value. The special value -2 is used to indicate an ignored argument.</returns>
        </member>
        <member name="M:NModel.Utilities.ReflectionHelper.FindAssembly(System.Collections.Generic.List{System.Reflection.Assembly},System.String)">
            <summary>
            Find the first assembly from the given list of assemblies that contains the given model program (namespace).
            </summary>
            <param name="assemblies">given assemblies</param>
            <param name="mp">given model program name (namespace)</param>
            <returns>The assembly that contains the given model program</returns>
        </member>
    </members>
</doc>
